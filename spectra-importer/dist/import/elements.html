<html><head><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
return settings;
}()
};(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
var factory = desugar(prototype);
prototype = factory.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return factory;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
this._doBehavior('beforeRegister');
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
proto._doBehaviorOnly('beforeRegister');
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
proto._doBehavior('registered');
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
self._doBehavior('attached');
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
self._doBehavior('detached');
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
this._doBehavior('attributeChanged', [
name,
oldValue,
newValue
]);
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.extend(DomModule.prototype, {
constructor: DomModule,
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_doBehavior: function (name, args) {
for (var i = 0; i < this.behaviors.length; i++) {
this._invokeBehavior(this.behaviors[i], name, args);
}
this._invokeBehavior(this, name, args);
},
_doBehaviorOnly: function (name, args) {
for (var i = 0; i < this.behaviors.length; i++) {
this._invokeBehavior(this.behaviors[i], name, args);
}
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true
};Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});Polymer.version = "1.6.1";Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});</script>

















<script>Polymer.Base._addFeature({
_prepTemplate: function () {
if (this._template === undefined) {
this._template = Polymer.DomModule.import(this.is, 'template');
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.extend(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.extend(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());Polymer.Base.extend(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>


















<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = this._modelForPath(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (IS_TOUCH_ONLY) {
return;
}
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse();
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
if (onload) {
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
return onload.call(self, e);
};
imprt.addEventListener('load', loadListener);
}
if (onerror) {
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: true
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, this._isStructured(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
this._notifyPath(this._fixPath(path, property, targetPath), value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = path.indexOf(name + '.') === 0;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = this._modelForPath(arg);
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, false, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node._notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg + '.') === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
this._notifyPath(this._fixPath(b, a, path), value);
} else if (path.indexOf(b + '.') == 0) {
this._notifyPath(this._fixPath(a, b, path), value);
}
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPathUp: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: true
});
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_modelForPath: Polymer.Base._modelForPath,
_pathMatchesEffect: Polymer.Base._pathMatchesEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
cssText += this.cssFromElement(e);
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += settings.useNativeShadow || cssBuildType === 'shady' ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.trim();
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'html';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
return api;
}();Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '));';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundTransformRule);
elementProto.__applyShimInvalid = false;
this.__currentElementProto = null;
},
transformRule: function (rule) {
rule.cssText = this.transformCssText(rule.parsedCssText);
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
transformCssText: function (cssText) {
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
return consumeCssProperties(cssText);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
return ApplyShim;
}();(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = parsedSelector === ':root';
var isHost = parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (cssBuild === 'shadow') {
isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
isHost = isHost && !isRoot;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
if (IS_IE) {
style.textContent = style.textContent;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepConstructor();
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure();
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transformRule(rule);
}
});
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = this._modelForPath(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: true,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
this.fire('dom-change');
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, this);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var parentNode = Polymer.dom(this).parentNode;
if (parentNode) {
var parent = Polymer.dom(parentNode);
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
parent.insertBefore(root, this);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(this).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.insertBefore(n, this);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});Polymer({
is: 'dom-bind',
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
this.fire('dom-change');
}
});</script>































<style>
  /*******************************
            Flex Layout
  *******************************/
  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }
  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }
  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }
  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }
  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }
  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }
  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }
  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }
  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }
  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }
  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }
  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }
  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }
  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }
  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }
  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }
  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }
  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }
  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }
  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }
  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }
  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }
  /* alignment in cross axis */
  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }
  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }
  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }
  /* alignment in main axis */
  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }
  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }
  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }
  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }
  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }
  /* self alignment */
  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }
  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }
  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }
  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }
  /*******************************
            Other Layout
  *******************************/
  .block {
    display: block;
  }
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
  .invisible {
    visibility: hidden !important;
  }
  .relative {
    position: relative;
  }
  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  body.fullbleed {
    margin: 0;
    height: 100vh;
  }
  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }
  /* fixed position */
  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }
  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }
  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }
  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }
  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }
</style>







<script>
  Polymer({
    is : 'ecosis-measurement-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Measurement;
    },

    attached : function() {
      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {
        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }

  })
</script>

<script>
  Polymer({
    is : 'ecosis-processing-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions['Processing Information'];
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }
  })
</script>

<script>
  Polymer({
    is : 'ecosis-instrument-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Instrument;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }

  })
</script>

















<script>
  Polymer({
    is : 'ecosis-metadata-docs',

    ready : function() {
      this.style.display = 'none';
      this.className = 'animated zoomIn';

      this.render();
    },

    toggle : function() {
      if( this.style.display == 'block' ) {
        this.style.display = 'none';
      } else {
        this.style.display = 'block';
      }
    },

    render : function() {
      var html = '';
      for( var cat in ecosis.ds.metadataDefinitions ) {
        var items = ecosis.ds.metadataDefinitions[cat];
        html += '<h4>'+cat+'</h4>';

        html += this.renderTable(items);
      }

      html += '<div class="help-block">If you need help adding EcoSIS metadata attributes, '+
              'please try out the <a href="https://github.com/CSTARS/ecosis-data-tool/releases" '+
              'target="_blank">EcoSIS Data Tool.</a></div>';

      this.innerHTML = html;
    },

    renderTable : function(items) {
      var table = '<div class="well"><table class="table">';

      for( var i = 0; i < items.length; i++ ) {
        var item = items[i];
        table +=
          '<tr>'+
            '<td>'+(item.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+' <b>'+item.name+'</b>' + 
            (item.description ? '<div class="help-block">'+item.description+'</div>' : '')+'</td>'+
            '<td style="text-transform: capitalize">'+item.input+'</td>'+
            '<td class="vocab" style="font-style: italic; color: #888">'+(item.vocabulary ? item.vocabulary.join(', ') : '')+'</td>'+
          '</tr>';
      }

      return table + '</table></div>';
    }
  })
</script>

















</head><body><div hidden="">

<dom-module id="ecosis-schema-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-schema-input',

    properties : {
      metadata : {
        type : String
      }
    },

    attached : function() {
      this.style.display = "block";

      this.schema = ecosis.ds.metadataLookup[this.metadata];
      this.flatName = this.schema.name.replace(/ /g, '');

      if( this.schema.input == 'controlled' || this.schema.input == 'controlled-single' ) {
        if( this.isYesNo(this.schema) ) {
          this.innerHTML = '<ecosis-radio-input metadata="'+this.metadata+'"></ecosis-radio-input>';
        } else {
          this.innerHTML = '<ecosis-controlled-input metadata="'+this.metadata+'"></ecosis-controlled-input>';
        }
      } else {

        // TODO: this needs to be a larger migration
        var name = this.schema.name;
        if( name === 'Citation DOI' ) {
          this.schema.description = 'If available, enter the pre-existing DOI for this dataset. Otherwise, request a dataset DOI from EcoSIS (below).';
          name = 'Dataset DOI';
        }

        var html =
          '<div class="form-group">'+
            '<label for="'+this.schema.flat+'Input" class="col-md-3 control-label">'  +
              (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '') + name +': </label>'+
            '<div class="col-md-7">'+
              '<input type="'+this.schema.input+'" class="form-control" />';

        if( this.schema.description || this.schema.input === 'split-text' ) {
          var help = this.schema.description || '';
          if( help.length > 0 ) {
            if( !help.match(/\.$/) ) {
              help += '.  ';
            } else {
              help += '  ';
            }
          }
          if( this.schema.input === 'split-text' ) {
            help += 'Comma separate for multiple values.';
          }

          html += '<div class="help-block">'+help+'</div>';
        }

        html += '</div></div>';

        this.innerHTML = html;

        this.querySelector('input').addEventListener('change', this.trigger.bind(this));
      }
    },

    isYesNo : function(schema) {
      if( !schema.vocabulary ) return false;
      if( schema.vocabulary.length != 2 ) return false;

      var c = 0;
      schema.vocabulary.forEach(function(vocab){
        if( vocab.toLowerCase() === 'yes' || vocab.toLowerCase() === 'no' ) {
          c++;
        }
      });
      if( c === 2 ) return true;
      return false;
    },

    setValue : function(value, otherValue) {
      if( this.schema.input == 'controlled' || this.schema.input == 'controlled-single' ) {
        if( this.isYesNo(this.schema) ) {
          this.querySelector('ecosis-radio-input').setValue(value);
        } else {
          this.querySelector('ecosis-controlled-input').setValue(value, otherValue);
        }
      } else {
        if( Array.isArray(value) ) {
          value = value.join(', ');
        }

        this.querySelector('input').value = value;
      }
    },

    trigger : function(e) {
      ecosis.ds.package['set'+this.flatName](e.currentTarget.value);
    }
  })
</script>

<dom-module id="ecosis-controlled-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>
    <div class="horizontal-form">
      <div class="form-group">
        <label id="label" for="input" class="col-md-3 control-label"></label>
        <div class="col-md-7">
          <select class="form-control" id="input" on-change="onSelectChange"></select>

          <div id="selected"></div>

          <div class="help-block" id="help" style="display:none"></div>

          <div id="otherRoot" style="display:none"></div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-controlled-input',

    properties : {
      metadata : {
        type : String
      }
    },

    ready : function() {
      this.selected = [];
      this.schema = ecosis.ds.metadataLookup[this.metadata];

      this.$.label.innerHTML = (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+this.schema.name;

      this.render();

      if( this.schema.description ) {
        this.$.help.style.display = 'block';
        this.$.help.innerHTML = this.schema.description;
      }

      if( this.schema.allowOther ) {
        var html = '<input type="text" class="form-control" id="other" placeholder="Please provide other value" />';
        this.$.otherRoot.innerHTML = html;

        this.$.other = this.$.otherRoot.querySelector('input');
        this.$.other.addEventListener('change', this.onChange.bind(this));
      }
    },

    render : function() {
      var options = '<option></option>';
      for( var i = 0; i < this.schema.vocabulary.length; i++ ) {
        var vocab = this.schema.vocabulary[i];
        if( this.selected.indexOf(vocab) > -1 ) continue;
        options += '<option value="'+this.schema.vocabulary[i]+'">'+this.schema.vocabulary[i]+'</option>'
      }
      this.$.input.innerHTML = options;

      var btns = '';
      for( var i = 0; i < this.selected.length; i++ ) {
        btns += '<a class="btn btn-primary btn-xs" style="margin:2px" value="'+this.selected[i]+
                '"><i class="fa fa-times"></i> '+this.selected[i]+'</a>';
      }
      this.$.selected.innerHTML = btns;

      $(this.$.selected).find('a').on('click', this.onRemove.bind(this));

      if( this.selected.indexOf('Other') == -1 ) {
        this.$.otherRoot.style.display = 'none';
      } else {
        this.$.otherRoot.style.display = 'block';
      }
    },

    onRemove : function(e) {
      var value = e.currentTarget.getAttribute('value');
      var index = this.selected.indexOf(value);
      if( index > -1 ) this.selected.splice(index, 1);

      if( value == 'Other' ) {
        this.$.otherRoot.style.display = 'none';
        if( this.schema.allowOther ) {
          this.$.other.value = '';
        }
      }

      ecosis.ds.package['set'+this.schema.fnName](this.getValue());

      this.render();
    },

    getValue : function() {
      var value = this.selected.join(',');
      if( this.schema.allowOther ) {
        if( this.$.other.value.length > 0 && value.length > 0 ) {
          value += ',';
        }
        value += this.$.other.value;
      }
      return value;
    },

    onSelectChange : function() {
      if( this.$.input.value == '' ) return;

      if( this.schema.input === 'controlled-single' ) {
        this.selected = [this.$.input.value];
      } else {
        this.selected.push(this.$.input.value);
      }

      this.onChange();
    },

    onChange : function() {
      ecosis.ds.package['set'+this.schema.fnName](this.getValue());
      this.render();
    },

    setValue: function(value, otherValue) {
      if( typeof value === 'string' ) {
        value = [value];
      }

      this.selected = value;
      for( var i = 0; i < this.selected.length; i++ ) {
        this.selected[i] = this.selected[i].trim();
      }
      for( var i = this.selected.length-1; i >= 0; i-- ) {
        if( this.selected[i] == '' ) {
          this.selected.splice(i, 1);
        }
      }

      if( this.schema.allowOther && otherValue ) {
        this.$.otherRoot.style.display = (value.length > 0) ? 'block' : 'none';
        if( Array.isArray(otherValue) ) {
          otherValue = otherValue.join(', ');
        }
        this.$.other.value = otherValue;
      }

      this.render();
    }
  })
</script>

<dom-module id="ecosis-radio-input">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div class="horizontal-form">
      <div class="form-group">
        <label id="label" for="input" class="col-md-3 control-label"></label>
        <div class="col-md-7" style="padding-top:10px">
          <label>
            <input type="radio" id="yes" value="Yes" on-change="onChange"> Yes
          </label>&nbsp;&nbsp;
          <label>
            <input type="radio" id="no" value="No" on-change="onChange"> No
          </label>

          <div class="help-block" id="help" style="display:none"></div>
        </div>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-radio-input',

      properties : {
        metadata : {
          type : String
        }
      },

      attached : function() {
        this.schema = ecosis.ds.metadataLookup[this.metadata];
        this.$.yes.setAttribute('name', this.schema.flat+'-radio');
        this.$.no.setAttribute('name', this.schema.flat+'-radio');
        this.$.label.innerHTML = this.schema.name;
      },

      onChange : function(e) {
        this.selected = [e.currentTarget.getAttribute('value')];
        ecosis.ds.package['set'+this.schema.fnName](e.currentTarget.getAttribute('value'));
      },

      setValue: function(value) {
        if( value.toLowerCase() === 'yes' ) {
          this.$.yes.checked = true;
        } else if( value.toLowerCase() === 'no' ) {
          this.$.no.checked = true;
        }
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-theme-input">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div id="root"></div>
    <ecosis-gcmd-input id="gcmd"></ecosis-gcmd-input>

  </template>

  <script>
    Polymer({
      is : 'ecosis-theme-input',

      ready : function() {
        this.schema = ecosis.ds.metadataDefinitions.Theme;
      },

      attached : function() {

        var col1 = '';
        var col2 = '';

        var c = 0;
        for( var i = 0; i < this.schema.length; i++ ) {
          if( this.schema[i].name == 'Keywords' ) continue;
          if( this.schema[i].name == 'NASA GCMD Keywords' ) continue;

          var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

          if( c % 2 == 0 ) col1 += input;
          else col2 += input;
          c++;
        }

        this.$.root.innerHTML =
          '<div class="row">'+
            '<div class="col-md-6">'+ col1 + '</div>'+
            '<div class="col-md-6">'+ col2 + '</div>'+
          '</div>';

        ecosis.ds.on('load', this.setValues.bind(this));
      },

      setValues : function() {
        for( var i = 0; i < this.schema.length; i++ ) {
          if( this.schema[i].name == 'Keywords' ) continue;

          var name = this.schema[i].fnName;
          var value = ecosis.ds.package['get'+name]();

          if( this.schema[i].name == 'NASA GCMD Keywords' ) {
            if( !value ) value = '[]';
            value = JSON.parse(value);
            this.$.gcmd.setTokens(value);
            continue;
          }

          var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

          

          var other = '';
          if( this.schema[i].allowOther ) {
            other = ecosis.ds.package['get'+name+'Other']();
          }

          ele.setValue(value, other);
        }
      }


    })
  </script>
</dom-module>




<dom-module id="ecosis-citation-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>

    <div class="help-block">
      Citation will be generated as you complete the fields below. This is how your EcoSIS dataset will be cited by others.
    </div>

    <div class="horizontal-form">
      <div class="form-group">
        <label class="col-md-2 control-label">Dataset Citation:</label>
        <div class="col-md-10" id="citation"></div>
      </div>

      <div class="form-group">
        <label class="col-md-2 control-label">Author(s):</label>
        <div class="col-md-10">
          <ecosis-author-input metadata="Author"></ecosis-author-input>
        </div>
      </div>

      <div id="colRoot"></div>
    </div>

  </template>

  <script>
    Polymer({
      is : 'ecosis-citation-input',

      ready : function() {
        this.schema = ecosis.ds.metadataDefinitions.Citation;
        this.customInputList = ['Citation','Website','Author'];
      },

      attached : function() {
        var col1 = '';
        var col2 = '';

        var c = 0;
        for( var i = 0; i < this.schema.length; i++ ) {
          // inserted at top of basic info form, skip here
          if( this.customInputList.indexOf(this.schema[i].name) > -1 ) continue;
          
          c++;
          var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

          if( c % 2 == 1 ) col1 += input;
          else col2 += input;
        }

        this.$.colRoot.innerHTML =
          '<div class="row">'+
            '<div class="col-md-6">'+ col1 + '</div>'+
            '<div class="col-md-6">'+ col2 + '</div>'+
          '</div>';

        ecosis.ds.on('load', this.setValues.bind(this));
        ecosis.ds.on('update', this.setCitation.bind(this));
      },

      setValues : function() {
        for( var i = 0; i < this.schema.length; i++ ) {
          if( this.schema[i].name == 'Website' ) continue;

          if( this.schema[i].name == 'Citation' ) {
            this.setCitation();
            continue;
          }

          var ele = this.querySelector('[metadata="'+this.schema[i].name+'"]');
          if( !ele ) continue;

          var name = this.schema[i].fnName;
          var value = ecosis.ds.package['get'+name]();

          var other = '';
          if( this.schema[i].allowOther ) {
            other = ecosis.ds.package['get'+name+'Other']();
          }

          ele.setValue(value, other);

          if( this.schema[i].name == 'Citation DOI' ) {
            if( ecosis.ds.package.getDoi().value ) {
              ele.style.display = 'none';
            } else {
              ele.style.display = 'block';
            }
          }
        }
      },

      setCitation : function() {
        var citation = [];

        var authors = ecosis.ds.package.getAuthor().split(',');
        authors = authors.map(function(author){
          return author.trim();
        });

        if( authors.length === 1 ) {
          citation.push(authors[0]);
        } else if ( authors.length === 2 ) {
          citation.push(authors.join(' and '));
        } else if( authors.length >= 3) {
          var last = authors.pop();
          citation.push(authors.join(', ')+' and '+last);
        }

        if( ecosis.ds.package.getYear() ) {
          citation.push(ecosis.ds.package.getYear());
        }

        citation.push(ecosis.ds.package.getTitle());

        citation.push('Data set. Available on-line [http://ecosis.org] from the Ecological Spectral Information System (EcoSIS)')

        var doi = ecosis.ds.package.getDoi().value;
        if( !doi ) {
          doi = ecosis.ds.package.getCitationDOI();
        }
        if( doi ) {
          citation.push(doi);
        }

        citation = citation.join('. ');
        if( ecosis.ds.package.getCitation() !== citation ) {
          ecosis.ds.package.setCitation(citation);
        }

        this.$.citation.innerHTML = citation;
      }
    })
  </script>
</dom-module>
<dom-module id="ecosis-location-input">
  <style>
    :host {
      display : block;
    }
  </style>
  <template>
    <div class="well">

      <div class="horizontal-form">
        <div class="form-group">
          <label id="label" for="input" class="col-md-3 control-label">Location Name</label>
          <div class="col-md-7">
            <input type="text" class="form-control" id="input" on-change="onNameChange">
            <div class="help-block" id="help">You can comma separate</div>
          </div>
        </div>
      </div>

      <h5>Bounding Box</h5>
      <div id="map" style="height: 400px"></div>
      <div class="help-block">Draw bounding box for dataset.  If you provide latitude and
      longitude or geojson field(s) in your spectra, a bounding box for your dataset will
      be automatically calculated for search.</div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-location-input',

    attached : function() {
      this.drawing = false;

      // HACK, clicking the goecode menu fires a click on the map as well.
      // Can't seem to find where to intercept event.  Ignoring with flag for now...
      this.geocodeMenuClicked = false;

      this.map = L.map(this.$.map, {
          center: [0, 0],
          zoom: 2,
          noWrap : true
      });

      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        noWrap : true,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(this.map);
      L.Control.geocoder()
        .on('markgeocode', this.onGeocodeSelect.bind(this))
        .addTo(this.map);

      this.map.on('click', this.onClick.bind(this));
      this.map.on('mousemove', this.onMouseMove.bind(this));

      ecosis.ds.on('load', this.onLoad.bind(this));
    },

    onLoad : function() {
      var names = ecosis.ds.package.getLocationName();
      if( Array.isArray(names) ) {
        names = names.join(', ');
      }
      this.$.input.value = names;

      var geojson = ecosis.ds.package.getGeoJson();
      if( Object.keys(geojson).length === 0 ) return;

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": geojson
      };

      try {
        this.polygon = L.geoJson(geojsonFeature);
        this.polygon.addTo(this.map);
        this.polygon.on('click', this.onFeatureClick.bind(this));
      } catch(e) {}
    },

    onNameChange : function() {
      ecosis.ds.package.setLocationName(this.$.input.value);
    },

    onShow : function() {
      this.drawing = false;

      setTimeout(function(){
        this.map.invalidateSize();
        if( this.polygon ) {
          this.map.fitBounds(this.polygon.getBounds());
        }
      }.bind(this), 50);
    },

    onGeocodeSelect : function() {
      this.geocodeMenuClicked = true;
      setTimeout(function(){
        this.geocodeMenuClicked = false;
      }.bind(this), 100);
    },

    onClick : function(e) {
      if( this.geocodeMenuClicked ) {
        return;
      }

      if( this.drawing ) {
        this.drawing = false;
        this.setPolygon(e.latlng);
        return;
      }

      this.drawing = true;
      this.p1 = e.latlng;
    },

    onFeatureClick : function(e) {
      if( this.drawing ) {
        return this.onClick(e);
      }

      // else clear
      if( this.polygon ) {
        this.map.removeLayer(this.polygon);
      }

      ecosis.ds.package.setGeoJson(null);
    },

    onMouseMove : function(e) {
      if( !this.drawing ) return;

      if( this.polygon ) {
        this.map.removeLayer(this.polygon);
      }
      var p2 = e.latlng;

      var coordinates = [[
          [this.p1.lng, this.p1.lat],
          [this.p1.lng, p2.lat],
          [p2.lng, p2.lat],
          [p2.lng, this.p1.lat],
          [this.p1.lng, this.p1.lat]
      ]];

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type" : "Polygon",
            "coordinates" : coordinates
          }
      };

      this.polygon = L.geoJson(geojsonFeature);
      this.polygon.on('click', this.onFeatureClick.bind(this));
      this.polygon.addTo(this.map);
    },

    setPolygon : function(p2) {
      var geojson = {
        "type" : "Polygon",
        "coordinates" : [[
            [this.p1.lng, this.p1.lat],
            [this.p1.lng, p2.lat],
            [p2.lng, p2.lat],
            [p2.lng, this.p1.lat],
            [this.p1.lng, this.p1.lat]
        ]]
      }

      ecosis.ds.package.setGeoJson(geojson);
    }

  })
</script>

<dom-module id="ecosis-title-input">
  <style>
    :host {
      display: block;
    }
    span.label {
      font-size: 12px;
    }
    #titleLabel {
      font-weight: bold;
    }
  </style>

  <template>
    <div id="editMode" style="display:none" class="form-horizontal">
      <div class="form-group">
        <label class="col-md-2 control-label">Title</label>
        <div class="col-md-9" style="padding-top:7px">
          <div><span id="titleLabel"></span></div>
          <div style="font-size:12px;color:#888;font-style:italic">
            URL: <span id="urlLabel"></span>
          </div>
        </div>
      </div>
    </div>

    <div id="inputMode" class="form-horizontal">
      <div class="form-group">
        <label for="titleInput" class="col-md-2 control-label">Title</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="titleInput" placeholder="Unique Dataset Title" on-blur="onBlur" on-keyup="onTitleInputChange">
          <div id="static"></div>
          <span id="verifyingTitleLabel" class="label label-info" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Verifying name...
          </span>

          <span class="label label-danger" style="display:none" id="invalid"></span>

          <span class="label label-success" style="display:none" id="valid">
            URL: <span id="urlLabelInput"></span>
          </span>

          <div id="message" class="help-block">
            Please <span class="text text-warning">do not use '_' or '-'</span> in your title use spaces instead.  We want
            your title to be as human readable as possible!
          </div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-title-input',

    ready : function() {
      this.currentName = null;
      this.verify = new ecosis.app.UiBuffer(this._verify, 500, this);

      ecosis.ds.on('load', this.onDataReady.bind(this));
      this.validName = false;
    },

    onDataReady : function() {
      if( ecosis.ds.editMode ) {
        this.$.titleInput.value = ecosis.ds.package.getTitle();
        this.$.static.innerHTML = ecosis.ds.package.getTitle();
        this.$.urlLabel.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.package.getName();

        this.checkDoiStatus();

        return;
      }

      this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/';
    },

    checkDoiStatus : function() {
      var status = ecosis.ds.package.getDoi().status;
      if( status && status.value ) {
        if( status.value.toLowerCase() === 'applied' ) {
          this.$.static.style.display = 'block';
          this.$.titleInput.style.display = 'none';
          this.$.message.style.display = 'none';
        }
      }
    },

    onTitleInputChange : function() {
      this.verify();
    },

    onBlur : function() {
      this.verify();
    },

    _verify : function() {
      if( ecosis.ds.editMode && ecosis.ds.package.getName() && this.currentName === null ) {
        this.currentName = ecosis.ds.package.getName();
      }

      this.$.verifyingTitleLabel.style.display = 'inline-block';
      this.$.invalid.style.display = 'none';
      this.$.valid.style.display = 'none';
      this.validName = false;

      // TODO: verify this has been removed
      // if we are in edit mode and the current, cleaned, name is equal to the 'updated' name
      // then there is nothing to check, they are just updating the title.  This will throw
      // a false positive if we check for name in use (cause it is, by this dataset);
      //if( ecosis.ds.editMode && ecosis.ds.package.getName() === this.currentName ) {
      //  return;
      //}

      ecosis.ds.package.setTitle(this.$.titleInput.value, function(err, resp){
        this.$.verifyingTitleLabel.style.display = 'none';
        if( err ) {
          this.$.invalid.style.display = 'inline-block';
          this.$.invalid.innerHTML = err.message;
          this.fire('update');
          return;
        }

        //this.$.nameLabel.innerHTML = ecosis.ds.package.getName();
        this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.package.getName();
        this.$.valid.style.display = 'inline-block';
        this.validName = true;

        this.fire('update');
      }.bind(this));
    }

  });
</script>

<dom-module id="ecosis-keyword-input">
  <style>
    :host {
      display : block;
    }
    span.label {
      font-size: 12px;
      position: absolute;
      right: 15px;
      top: 15px;
    }
    a.btn {
      margin: 5px;
    }
  </style>
  <template>

    <div class="form-horizontal">
      <div class="form-group">
        <label for="keywordInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Keywords</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="keywordInput" on-keyup="onInputChange" placeholder="Search Keywords">
          <div class="help-block">
            Search for EcoSIS keywords or create new keywords.  Comma separate to add more than one keyword at a time.  Use
            the 'enter' key to create new keyword(s).
          </div>
          <span id="searchingPanel" class="label label-primary" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Searching...
          </span>

          <div id="resultRoot"></div>
          <div id="currentKeywordsRoot"></div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-keyword-input',

    ready : function() {
        this.tokens = [];
        this.focus = false;
        this.searchTimer = -1;
    },

    // fires when text is typed input field
    onInputChange : function(e) {
        if( e.which == 13 ) this.createToken();
        else this.search();
    },

    search : function(){
        if( this.searchTimer != -1 ) clearTimeout(this.searchTimer);
        if( this.$.keywordInput.value == '' ) {
          this.setSearching(false);
          this.$.resultRoot.innerHTML = '';
          return;
        }

        this.setSearching(true);

        this.searchTimer = setTimeout(function(){
          ecosis.ckan.tagSearch(this.$.keywordInput.value, 10, function(resp){
            this.setSearching(false);

            this.results = resp.results;
            this.renderResults();
          }.bind(this));
        }.bind(this), 500);
    },

    createToken : function() {
      var parts = this.$.keywordInput.value.split(',');
      for( var i = 0; i < parts.length; i++ ) {
        var value = this.clean(parts[i]);

        if( value.length == 0 ) continue;

        var t = {
            label : value,
            value : value
        }

        this.addToken(t, true);
      }

      this.$.keywordInput.value = '';
      this.$.resultRoot.innerHTML = '';
    },

    addResult : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        var name = this.results[index].name;

        this.addToken({label:name, value:name}, true);

        this.$.keywordInput.value = '';
        this.$.resultRoot.innerHTML = '';
        this.renderTokens();
    },

    addToken : function(token, fireEvent) {
        if( !token.value || token.value == '' ) return;

        for( var i = 0; i < this.tokens.length; i++ ) {
            if( this.tokens[i].value == token.value ) return;
        }

        token.label = token.value;
        this.tokens.push(token);

        ecosis.ds.package.addKeyword(token.value);

        this.renderTokens();
    },

    renderResults : function() {
      var btns = '';
      for( var i = 0; i < this.results.length; i++ ) {
        btns += '<a class="btn btn-default btn-sm ecosis-keyword-input" style="text-transform:initial" index="'+i+'" ><i class="fa fa-plus"></i> '+this.results[i].name+'</a>';
      }
      this.$.resultRoot.innerHTML = btns.length > 0 ? '<div class="well">Suggestions:<br />'+btns+'</div>' : '';

      $(this.$.resultRoot).find('a').on('click', this.addResult.bind(this));
    },

    renderTokens : function() {
      var btns = '';
      for( var i = 0; i < this.tokens.length; i++ ) {
        btns += '<a class="btn btn-primary btn-sm ecosis-keyword-input" style="text-transform:initial" index="'+i+'"><i class="fa fa-times"></i> '+this.tokens[i].label+'</a>';
      }
      this.$.currentKeywordsRoot.innerHTML = btns;

      $(this.$.currentKeywordsRoot).find('a').on('click', this.onTokenClick.bind(this));
    },

    getTokens : function() {
        return this.tokens;
    },

    setTokens : function(tokens) {
        this.tokens.splice(0,this.tokens.length);
        for( var i = 0; i < tokens.length; i++ ) {
            this.addToken({label: tokens[i].name, value : tokens[i].name});
        }

        this.renderTokens();
    },

    onTokenClick : function(e) {
        var index = parseInt(e.currentTarget.getAttribute("index"));
        var token = this.tokens.splice(index,1)[0];

        ecosis.ds.package.removeKeyword(token.value);

        // don't set focus to input
        e.stopPropagation();

        this.renderTokens();
    },

    setSearching : function(searching) {
      this.$.searchingPanel.style.display = searching ? 'inline-block' : 'none';
    },

    clean : function(txt) {
      return txt.replace(/[^A-Za-z0-9-_\s]/g, '').trim();
    }
  });
</script>

<dom-module id="ecosis-linked-data-input">
  <template>
    <style>
      :host {
        display: block;
      }
      [hide="true"] {
        display: none;
      }
      .form-inline .form-group {
        padding: 0 30px;
      }
    </style>

    <div class="help-block">
      Links to additional related information and data.  Here you can link your spectral
      data to external sites and datasets.  You can also link to papers
      which are useful in describing this dataset.
    </div>

    <template is="dom-repeat" items="{{list}}">
      <div class="form-inline">
        <div class="form-group">
          <label for="">Title</label>
          <input type="text" class="form-control" placeholder="Ex: Fluxnet" value="{{item.label::input}}" on-input="checkFilled" on-blur="fireUpdate">
        </div>
        <div class="form-group">
          <label for="">URL or DOI</label>
          <input type="text" class="form-control" style="min-width: 300px" placeholder="Ex: http://fluxnet.ornl.gov/site/646" value="{{item.url::input}}" on-input="checkFilled" on-blur="fireUpdate">
        </div>
        <a class="btn btn-default" index$="{{index}}" on-click="remove" hide$="{{item.last}}"><i class="fa fa-trash"></i></a>
      </div>
    </template>

  </template>
  <script>
    Polymer({
      is: 'ecosis-linked-data-input',

      properties : {
        list : {
          type : Array,
          value : function() {
            return [{
              label : '',
              url : '',
              last : 'true'
            }];
          }
        }
      },

      setData : function(data) {
        var hasData = false;
        if( data && data.length > 0 ) {
          hasData = true;
        }

        if( !hasData ) {
          data = [{
            label : '',
            url : '',
            last : 'true'
          }];
        }

        this.list = data;
        this.checkFilled();
      },

      getData : function() {
        var arr = [];

        for( var i = 0; i < this.list.length; i++ ) {
          if( this.list[i].label.length > 0 && this.list[i].url.length > 0 ) {
            arr.push({
              label : this.list[i].label,
              url : this.list[i].url
            });
          }
        }

        return arr;
      },

      remove : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        this.splice('list', index, 1);
        this.fireUpdate();
      },

      checkFilled : function() {
        if( !this.list ) return;
        if( this.list.length === 0 ) return;

        var item = this.list[this.list.length-1];
        if( item.label.length > 0 && item.url.length > 0 ) {
          this.push('list',{
            label : '',
            url : '',
            last : 'true'
          });
        }

        for( var i = 0; i < this.list.length-1; i++ ) {
          if( this.list[i].last == 'true') {
            this.set('list.'+i+'.last', 'false');
          }
        }
      },

      fireUpdate : function() {
        ecosis.ds.package.setLinkedData(this.getData());
      }

    });
  </script>
</dom-module>

<dom-module id="ecosis-author-input">
  <template>
    <style>
      :host {
        display: block;
      }
      #list div:nth-last-of-type(1) a {
        display: none;
      }
    </style>

    <div id="list">
      <template is="dom-repeat" items="{{authors}}" id="repeat">
        <div class="layout horizontal" style="margin-top: 10px">
          <input type="text" class="form-control" value="[[item]]" index$="[[index]]" on-input="onEdit" style="margin-right:20px">
          <a class="btn btn-default" index$="[[index]]" on-click="removeAuthor"><i class="fa fa-trash"></i></a>
        </div>
      </template>
    </div>
    
  </template>
  <script>
    Polymer({
      is: 'ecosis-author-input',

      properties : {
        authors : {
          type : Array,
          notify : true,
          value: function() { 
            return ['']; 
          }
        }
      },

      setValue : function(value) {
        this.value = value;
        var tmp = this.value.split(',');
        tmp = tmp.map(function(val){
          return val.trim();
        });
        this.authors = tmp;
        this.authors.push('');
      },

      removeAuthor : function(e) {
        this.splice('authors', parseInt(e.currentTarget.getAttribute('index')), 1);
        this.updateValue();
      },

      onEdit : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        this.authors[index] = e.currentTarget.value.replace(/,/g, ' ');
        
        if( this.authors[this.authors.length-1] ) {
          this.push('authors', '');
        } else if ( !this.authors[this.authors.length-1] && !this.authors[this.authors.length-2] ) {
          this.splice('authors', this.authors.length-1, 1);
        }

        this.updateValue();
      },

      updateValue : function() {
        var tmp = [];
        for( var i = 0; i < this.authors.length; i++ ) {
          if( this.authors[i].replace(/ /g,'') ) tmp.push(this.authors[i]); 
        }

        this.value = tmp.join(', ');

        this.debounce('setValue', function(){
          ecosis.ds.package.setAuthor(this.value);
        }, 500);
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-gcmd-input">
  <style>
    :host {
      display : block;
    }
    span.label {
      font-size: 12px;
      position: absolute;
      right: 15px;
      top: 15px;
    }
    a.btn {
      margin: 5px;
    }
  </style>
  <template>

    <div class="form-horizontal">
      <div class="form-group">
        <label for="keywordInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> GCMD Keywords</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="keywordInput" on-input="onInputChange" placeholder="Search GCMD Keywords">
          <div class="help-block">
            Select spectroscopy-related keywords from the NASA Global Change Master Directory's controlled keyword vocabularies. (http://gcmd.nasa.gov/learn/keyword_list.html)
          </div>
          <span id="searchingPanel" class="label label-primary" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Searching...
          </span>

          <div id="resultRoot"></div>
          <div id="currentKeywordsRoot"></div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-gcmd-input',

    ready : function() {
        this.tokens = [];
        this.focus = false;
        this.searchTimer = -1;
    },

    // fires when text is typed input field
    onInputChange : function(e) {
        if( e.which == 13 ) this.createToken();
        else this.search();
    },

    search : function(){
        if( this.searchTimer != -1 ) clearTimeout(this.searchTimer);
        if( this.$.keywordInput.value == '' ) {
          this.setSearching(false);
          this.$.resultRoot.innerHTML = '';
          return;
        }

        this.setSearching(true);

        this.searchTimer = setTimeout(function(){
          ecosis.ckan.gcmdSuggest(this.$.keywordInput.value, function(resp){
            this.setSearching(false);

            this.results = resp;
            this.renderResults();
          }.bind(this));
        }.bind(this), 500);
    },

    createToken : function() {
      var parts = this.$.keywordInput.value.split(',');
      for( var i = 0; i < parts.length; i++ ) {
        var value = this.clean(parts[i]);

        if( value.length == 0 ) continue;

        var t = {
            label : value,
            value : value
        }

        this.addToken(t, true);
      }

      this.$.keywordInput.value = '';
      this.$.resultRoot.innerHTML = '';
    },

    addResult : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        var item = this.results[index];

        this.addToken({label:item.keywords.join(' > '), value: item.id}, true);

        this.$.keywordInput.value = '';
        this.$.resultRoot.innerHTML = '';
        this.renderTokens();
    },

    addToken : function(token, setKeywords) {
        if( !token.value || token.value == '' ) return;

        for( var i = 0; i < this.tokens.length; i++ ) {
            if( this.tokens[i].value == token.value ) return;
        }

        this.tokens.push(token);
        if( setKeywords ) {
          ecosis.ds.package.setNASAGCMDKeywords(JSON.stringify(this.tokens));
        }

        this.renderTokens();
    },

    renderResults : function() {
      var btns = '';
      for( var i = 0; i < this.results.length; i++ ) {
        if( i === 10 ) break;
        btns += '<div style="text-transform:capitalize; cursor:pointer; padding: 10px" index="'+i+'" ><i class="fa fa-plus"></i> '+this.results[i].keywords.join(' > ')+'</div>';
      }
      this.$.resultRoot.innerHTML = btns.length > 0 ? '<div>'+btns+'</div>' : '';

      $(this.$.resultRoot).find('div[index]').on('click', this.addResult.bind(this));
    },

    renderTokens : function() {
      var btns = '';
      for( var i = 0; i < this.tokens.length; i++ ) {
        btns += '<div class="btn btn-primary btn-sm ecosis-keyword-input" style="text-transform:capitalize;display:block;margin-bottom: 15px;white-space:initial" index="'+i+'"><i class="fa fa-times"></i> '+this.tokens[i].label+'</div>';
      }
      this.$.currentKeywordsRoot.innerHTML = btns;

      $(this.$.currentKeywordsRoot).find('div[index]').on('click', this.onTokenClick.bind(this));
    },

    getTokens : function() {
        return this.tokens;
    },

    setTokens : function(tokens) {
        this.tokens.splice(0,this.tokens.length);
        for( var i = 0; i < tokens.length; i++ ) {
            this.addToken({label: tokens[i].label, value : tokens[i].value});
        }

        this.renderTokens();
    },

    onTokenClick : function(e) {
        var index = parseInt(e.currentTarget.getAttribute("index"));
        var token = this.tokens.splice(index,1)[0];

        ecosis.ds.package.setNASAGCMDKeywords(JSON.stringify(this.tokens));

        // don't set focus to input
        e.stopPropagation();

        this.renderTokens();
    },

    setSearching : function(searching) {
      this.$.searchingPanel.style.display = searching ? 'inline-block' : 'none';
    },

    clean : function(txt) {
      return txt.replace(/[^A-Za-z0-9-_\s]/g, '').trim();
    }
  });
</script>
<dom-module id="ecosis-header">
  <style>
    :host {
      display: block;
    }
    #root.static {
      background-color: rgb(70, 70, 70);
    }
    #root.static a {
      color: white !important;
    }
    #root.static .navbar-brand {
      color: white !important;
    }
    #root.static li.active a {
      color: #222 !important;
    }
    #root.static li.open a {
      color: #222 !important;
    }
    #staticMessage {
      position: fixed;
      z-index: 25;
      top: 62px;
      text-align: center;
      padding: 4px 0 2px 0;
      background-color: rgba(255,255,255,.5);
      width: 100%;
      border-bottom: 1px solid #ccc;
    }
  </style>
  <template>
    <nav class="navbar navbar-default navbar-fixed-top" id="root">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#ecosis-header-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">EcoSIS Importer<span id="score2" class="visible-xs-inline"></span></span>
        </div>

        <div class="collapse navbar-collapse" id="ecosis-header-collapse">
          <ul class="nav navbar-nav">

            <li class="active">
              <a id="basicInfo">
                <i class="fa fa-info-circle"></i><span class="hidden-sm">  Basic</span> Information
              </a>
            </li>

            <li class="dropdown" id="resourcesDropdown" style="display:none">
              <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                <i class="fa fa-files-o"></i> Resources <span class="caret"></span>
              </a>
              <ul class="dropdown-menu" role="menu">
                <li><a id="addResources"><i class="fa fa-plus"></i> Add Resources</a></li>
                <li><a id="currentResources"><i class="fa fa-list"></i> Current Resources</a></li>
              </ul>
            </li>

            <li><a id="advanced" style="display:none"><i class="fa fa-cog"></i> Advanced</a></li>
            <li><a id="push" style="display:none"><i class="fa fa-check-circle-o" id="publishedIcon"></i> Publish</a></li>
            <li id="score" class="hidden-xs" style="padding-top:18px"></li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li>
              <a href="http://tutorial.ecosis.org" target="_blank">
                <i class="fa fa-question-circle"></i><span class="hidden-sm"> Help</span>
              </a>
            </li>
            <li>
              <a id="exit" href="/dataset/">
                <i class="fa fa-sign-in"></i><span class="hidden-sm">  Exit</span>
              </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="staticMessage" style="display:none">
      <i class="fa fa-warning"></i> A EcoSIS DOI as been applied to the dataset.  You can no longer make changes to 
      the dataset resources.  You can still edit the metadata.
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-header',

    properties : {
      hack : {
        type : String,
        value : ''
      }
    },

    ready : function() {
      this.$.basicInfo.setAttribute('href', '#basic-info');
      this.$.addResources.setAttribute('href', '#add-resources');
      this.$.currentResources.setAttribute('href', '#current-resources');
      this.$.advanced.setAttribute('href', '#advanced');
      this.$.push.setAttribute('href', '#push');

      $(window).on('hashchange', this.updateActiveTab.bind(this));
      this.updateActiveTab();

      if( ecosis.ds.editMode ) {
        ecosis.ds.on('load', function(pkg){
          if( ecosis.ds.editMode ) this.setBackBtn();
          this.checkDoiStatus();
        }.bind(this));
      } else {
        this.$.exit.setAttribute('href', '/dataset/');
      }

      var fn = new ecosis.app.UiBuffer(this.onScoreUpdated, 100, this);
      ecosis.ds.on('update', fn);
      ecosis.ds.on('load', fn);
    },

    attached : function() {
      if( ecosis.ds.editMode ) {
        this.$.resourcesDropdown.style.display = 'block';
        this.$.advanced.style.display = 'block';
        this.$.push.style.display = 'block';
      }
    },
    
    checkDoiStatus : function() {
      var status = ecosis.ds.package.getDoi().status;
      if( status && status.value ) {
        if( status.value.toLowerCase() === 'applied' ) {
          this.$.root.classList.add('static');
          this.$.staticMessage.style.display = 'block';
          this.$.addResources.style.display = 'none';
        }
      }
    },

    setBackBtn : function() {
      this.$.exit.setAttribute('href', '/dataset/'+ecosis.ds.package.getName());
    },

    updateActiveTab : function() {
      $('li').removeClass('active');

      var loc = window.location.hash.replace(/#/,'');
      var ele = $(this).find('a[href="#'+loc+'"]');

      if( ele.length > 0 && (loc == 'add-resources' || loc == 'current-resources') ) {
        $(this.$.resourcesDropdown).addClass('active');
      } else if ( ele.length > 0 ) {
        ele.parent().addClass('active');
      } else {
        $(this.$.basicInfo).parent().addClass('active');
      }
    },

    onScoreUpdated : function() {
      var result = ecosis.ds.getScore();

      if( ecosis.ds.result && ecosis.ds.lastPushed ) {
        var resp = ecosis.ds.checkChanges();
        if( resp.unpublishedChanges ) {
          this.updatePublishedIconStatus('changes');
        } else {
          this.updatePublishedIconStatus('published'); 
        }
      } else {
        this.updatePublishedIconStatus('notpublished'); 
      }

      if( result.score === this.lastScore ) {
        return;
      }
      this.lastScore = result.score;

      var label = 'success';
      if( result.score < 3 ) label = 'danger';
      else if( result.score < 8 ) label = 'warning';

      this.$.score.innerHTML = '<span style="display:inline-block" class="label label-'+label+' animated zoomIn">'+result.score+'/'+result.total+'</span>';
      this.$.score2.innerHTML = '<span class="label label-'+label+'">'+result.score+'/'+result.total+'</span>';
    },

    updatePublishedIconStatus : function(status) {
      if( status === 'changes' ) {
        this.$.publishedIcon.className = 'fa fa-warning text text-warning';
      } else if( status === 'published' ) {
        this.$.publishedIcon.className = 'fa fa-check-circle-o text text-success';
      } else {
        this.$.publishedIcon.className = 'fa fa-check-circle-o';
      }
    }

  });
</script>

<dom-module id="ecosis-dataformat-help">
  <style>
      table.preview {
          width: 100%;
          border-spacing: 0px;
          border-collapse: separate;
          border-top: 1px solid #ddd;
          border-left: 1px solid #ddd;
          background-color: white;
      }
      table.preview td {
          padding: 10px;
          border-right: 1px solid #ddd;
          border-bottom: 1px solid #ddd;
      }
      table.preview td.attr {
          font-weight: bold;
      }
      .file {
          background-color: #dff0d8;
      }
      .column {
          background-color: #fcf8e3;
      }
      .data {
          background-color: #d9edf7;
      }
      .note {
          padding: 10px 0;
          color: #777;
          font-size: 13px;
      }
      .note-label {
          padding: 3px;
          border-radius: 3px;
          font-weight: bold;
      }
      table.preview td.highlight {
          border-left: 1px solid red;
          border-right: 1px solid red;
      }
      table.preview td.highlight-row {
          border-top: 1px solid red;
          border-bottom: 1px solid red;
      }
      :host {
        display: block;
      }
  </style>
  <template>

    <div class="well">
        EcoSIS accepts data in several tabular formats.  These tabular files can have measurements laid out by column or by row.
    </div>

    <div id="column">
        <h4>Column Orientation</h4>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">id</td>
                <td class="column">id1</td>
                <td class="column highlight" style="border-top:1px solid red">id2</td>
                <td class="column">id3</td>
            </tr>
            <tr>
                <td class="column attr">USDA Code</td>
                <td class="column">ORYZA</td>
                <td class="column highlight">ORYZA</td>
                <td class="column">ACRU</td>
            </tr>
            <tr>
                <td class="column attr">LAI (m2/m2)</td>
                <td class="column">1.812</td>
                <td class="column highlight">.441</td>
                <td class="column">1.501</td>
            </tr>
            <tr>
                <td class="column attr">NDVI</td>
                <td class="column">.53</td>
                <td class="column highlight">.5</td>
                <td class="column">.48</td>
            </tr>
            <tr>
                <td class="data attr">400</td>
                <td class="data">.34</td>
                <td class="data highlight">.345</td>
                <td class="data">.454</td>
            </tr>
            <tr>
                <td class="data attr">410</td>
                <td class="data">.400</td>
                <td class="data highlight" style="border-bottom:1px solid red">.430</td>
                <td class="data">.568</td>
            </tr>
        </tbody></table>
    </div>

    <div id="row">
        <h4>Row Orientation</h4>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">datetime</td>
                <td class="column attr">id</td>
                <td class="column attr">Metadata Attribute</td>
                <td class="column attr">USDA Code</td>
                <td class="column attr">LAI (m2/m2)</td>
                <td class="data attr">400</td>
                <td class="data attr">410</td>
            </tr>
            <tr>
                <td class="column attr highlight-row" style="border-left: 1px solid red">2008-07-24</td>
                <td class="column highlight-row">id1</td>
                <td class="column highlight-row">metadata value 1</td>
                <td class="column highlight-row">ORYZA</td>
                <td class="column highlight-row">1.190</td>
                <td class="data highlight-row">.53</td>
                <td class="data highlight-row" style="border-right: 1px solid red">.487</td>
            </tr>
            <tr>
                <td class="column attr">2008-07-25</td>
                <td class="column">id2</td>
                <td class="column">metadata value 2</td>
                <td class="column">ACRU</td>
                <td class="column">0.606</td>
                <td class="data">.50</td>
                <td class="data">.400</td>
            </tr>
        </tbody></table>
    </div>

    <div class="note">
        <h5>Wavelengths</h5>
        Any <span class="data note-label">numeric</span> field name will be considered
        <span class="data note-label">wavelength measurement</span>.  All other fields will be considered
        <span class="column note-label">metadata</span>.  Metadata fields can supply units.
    </div>

    <div class="note">
        <h5>Global Metadata</h5>
        <span class="file note-label">Global File Metadata</span> is applied to everything in the file
        and is completely <b>optional</b>.  You can also upload a seperate metadata file which can be
        joined to your data later on in the import process.
    </div>

    <div class="note">
      <h5>Units</h5>
      Units can be specified by placing them in parentheses <b>(m2/m2)</b> after the field name.
    </div>

    <div style="margin-top:15px">
        Still lost?  <a href="http://tutorial.ecosis.org/walkthrough/#/7" target="_blank">Click
          here</a> to checkout the tutorial on data formats.
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataformat-help',

    setType : function(type) {
      if( type == 'column' ) {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'none';
      } else if( type == 'row' ) {
        this.$.column.style.display = 'none';
        this.$.row.style.display = 'block';
      } else {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'block';
      }
    }
  });
</script>

<dom-module id="ecosis-datasheet-select-panel">
  <style>
    :host {
      display: block;
    }
    .alert-default {
      background-color: #888;
      color : white;
    }
    .alert-primary {
      background-color: #2196f3;
      color: white;
    }
  </style>

  <template>
    <div id="well" class="">
      <div class="layout horizontal center">
        <div>
          <a class="btn btn-default" on-click="back" id="back">
            <i class="fa fa-arrow-left" style="color:#888"></i>
          </a>
        </div>
        <div style="padding:0 15px">Sheet:</div>
        <div class="flex" style="text-align:center; padding: 0 25px 0 0">
            <select id="select" class="form-control" on-change="onSelect"></select>
        </div>
        <div>
          <a class="btn btn-default" on-click="forward" id="forward">
            <i class="fa fa-arrow-right" style="color:#888"></i>
          </a>
        </div>
    </div>
  </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-select-panel',

    update : function(resource) {
      this.resource = resource;
      this.selected = 0;

      var options = '';
      for( var i = 0; i < resource.datasheets.length; i++ ) {
        var ds = resource.datasheets[i];
        var name = ds.sheetId.split('-')[1]
        options += '<option value="'+i+'">'+name+'</option>';
      }
      this.$.select.innerHTML = options;
      this.updateClass();
    },

    onSelect : function() {
      this.selected = parseInt(this.$.select.value);
      this.updateClass();
      this.fire('select', this.selected);
    },

    back : function() {
      this.selected--;
      if( this.selected < 0 ) {
        this.selected = 0;
        return;
      }
      this.$.select.value = this.selected+'';
      this.updateClass();
      this.fire('select', this.selected);
    },

    forward : function() {
      this.selected++;
      if( this.selected >= this.resource.datasheets.length ) {
        this.selected = this.resource.datasheets.length-1;
        return;
      }
      this.$.select.value = this.selected+'';
      this.updateClass();
      this.fire('select', this.selected);
    },

    updateClass : function() {
      var css = 'style-scope ecosis-datasheet-select-panel alert ';

      if( !this.resource ) return;
      if( !this.resource.datasheets ) return;
      if( this.resource.datasheets.length <= this.selected ) return;

      var sheet = this.resource.datasheets[this.selected];
      if( sheet.ignored ) {
        css += 'alert-default';
      } else if ( sheet.metadata ) {
        css += 'alert-primary';
      } else {
        css += 'alert-success'
      }

      this.$.well.className = css;
    },

    setDisabled : function(disable) {
      if( disable ) {
        this.$.forward.setAttribute('disabled', '');
        this.$.back.setAttribute('disabled', '');
        this.$.select.setAttribute('disabled', '');
      } else {
        this.$.forward.removeAttribute('disabled');
        this.$.back.removeAttribute('disabled');
        this.$.select.removeAttribute('disabled');
      }
    }
  });
</script>

<dom-module id="ecosis-metadata-join-panel">
  <template>
    <div id="hasMatches">
      <select id="joinId" class="form-control" on-change="onJoinIdChange"></select>
      <div id="msg"></div>
    </div>
    <div id="noMatches" class="text text-warning">
      The field names (keys) in this sheet do not match any other data sheet.  To join
      this metadata you must use common keys in both your metadata sheet and your
      data sheet.  This key is often known as a primary key in SQL/relational land.<br><br>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-metadata-join-panel',

    ready : function() {
      this.updateTimer = -1;
    },

    update : function(datasheet, resource) {
      if( datasheet ) this.datasheet = datasheet;
      if( resource ) this.resourceId = resource.id;

      var options = '<option></option>';
      var knownAttrs = ecosis.ds.getDatasheetAttributes();
      var c = 0;

      for( var i = 0; i < this.datasheet.attributes.length; i++ ) {
        var attr = this.datasheet.attributes[i];
        if( knownAttrs.indexOf(attr) > -1 ) {
          options += '<option value="'+attr+'" '+
              (this.datasheet.joinOn == attr ? 'selected' : '') +
              '>'+attr+'</option>';
          c++;
        }
      }
      this.$.joinId.innerHTML = options;

      if( c == 0 ) {
        this.$.noMatches.style.display = 'block';

        // show all
        for( var i = 0; i < this.datasheet.attributes.length; i++ ) {
          var attr = this.datasheet.attributes[i];
          options += '<option value="'+attr+'" '+
              (this.datasheet.joinOn == attr ? 'selected' : '') +
              '>'+attr+'</option>';
        }
        this.$.joinId.innerHTML = options;

      } else {
        this.$.noMatches.style.display = 'none';
      }

      var matchCount = 0;
      for( var key in this.datasheet.matches ) {
        matchCount += this.datasheet.matches[key]
      }
      //this.$.matchCountLabel.innerHTML = matchCount;
    },

    onJoinIdChange : function() {
      this.datasheet.joinOn = this.$.joinId.value;
      this.updateServer();
    },


    updateServer : function() {
      this.fire('joinon-selected', this.datasheet.joinOn);
    },

    setUpdating : function(updating) {
      if( updating ) {
        this.$.filenameMatch.setAttribute('disabled', '');
        this.$.looseMatch.setAttribute('disabled', '');
        this.$.joinId.setAttribute('disabled', '');

        this.$.matchCountPanel.style.display = 'none';
        this.$.updatingPanel.style.display = 'block';

        this.fire('metadata-update', {updating: true});
      } else {
        this.$.filenameMatch.removeAttribute('disabled');
        this.$.looseMatch.removeAttribute('disabled');
        this.$.joinId.removeAttribute('disabled');

        this.$.matchCountPanel.style.display = 'inline-block';
        this.$.updatingPanel.style.display = 'none';

        this.fire('metadata-update', {updating: false});
      }
    },

  })
</script>
<dom-module id="ecosis-datasheet-panel">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>

    <div id="main" class="animated fadeIn">
      <h6 id="titleLabel" style="display:none"></h6>

      <ecosis-sheet-preview id="preview" style="margin-bottom: 25px"></ecosis-sheet-preview>

      <span class="alert alert-danger" style="display:none" id="parseError">
          Error parsing file
      </span>

      <span class="alert alert-warning" style="display:none" id="repeatsWarning"></span>

      <h4 class="page-header"><i class="fa fa-cogs"></i> Sheet Settings</h4>

      <!-- Is Metadata -->
      <div id="metadataSelectPanel">
        <div class="form-horizontal">
          <div class="form-group">

            <label for="inputIsMetadata" class="col-md-2 control-label">Joinable Metadata</label>
            <div class="col-md-10">
              <div class="checkbox">
                <label>
                  <input id="inputIsMetadata" type="checkbox" on-change="onMetadataUpdate"> This sheet contains metadata to be joined on given data.
                </label>
              </div>
            </div>

          </div>
          <div class="form-group" id="joinMetadataOuter">
            <label for="inputIsMetadata" class="col-md-2 control-label">Field To Join On <span style="color:#aaa">/ Primary Key</span></label>
            <div class="col-md-10">
                <ecosis-metadata-join-panel id="joinMetadata" on-joinon-selected="save">
                </ecosis-metadata-join-panel>
            </div>
          </div>
        </div>
      </div>

      <!-- Ignore -->
      <div class="form-horizontal">
        <div class="form-group">

          <label for="inputIgnore" class="col-md-2 control-label">Ignore</label>
          <div class="col-md-10">
            <div class="checkbox">
              <label>
                <input id="inputIgnore" type="checkbox" on-change="onIgnoreUpdate"> This sheet should not be parsed.
              </label>
            </div>
          </div>

        </div>
      </div>

      <!-- Datasheet Orientation -->
      <div class="form-horizontal" id="orientationPanel">
        <div class="form-group">

          <label class="col-md-2 control-label">Orientation</label>
          <div class="col-md-10">
            <div class="radio">
              <label>
                <input type="radio" id="columnInput" value="column" checked="" on-click="onOrientationChange">
                My observations are by column.
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" id="rowInput" value="row" on-click="onOrientationChange">
                My observations are by row.
              </label>
            </div>

            <a on-click="toggleHelp" style="cursor:pointer">Format Help.</a>
            <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>
          </div>

        </div>
      </div>

      <!-- Datasheet Seperator -->
      <div class="form-horizontal" id="seperatorPanel" style="display:none">
        <div class="form-group">

            <label class="col-md-2 control-label">File Seperator</label>
            <div class="col-md-10">
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="commaInput" value="," checked="" on-click="onSeperatorChange">
                  Comma
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="tabInput" value="tab" on-click="onSeperatorChange">
                  Tab
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="semicolonInput" value=";" on-click="onSeperatorChange">
                  Semicolon
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="otherInput" value="other" on-click="onSeperatorChange">
                  Other
                  <input type="text" id="otherSeperatorInput" on-blur="onSeperatorChange">
                </label>
              </div>
            </div>

            <a on-click="toggleHelp" style="cursor:pointer">Format Help.</a>
            <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>
          </div>
        </div>

      <div id="updatingPanel" class="alert alert-warning" style="display:none">
        <h6 style="color:white"><i class="fa fa-spinner fa-spin"></i> Updating...</h6>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-panel',

    ready : function() {
      this.sheet = null;
    },

    update : function(resource, datasheet) {
      this.resource = resource;
      this.sheet = datasheet;
    },

    save : function() {
      this.setSaving(true);

      var options = {
        layout : this.sheet.layout,
        metadata : this.sheet.metadata,
        ignore : this.sheet.ignore,
        joinOn : this.sheet.joinOn
      }

      if( this.sheet.seperator ) {
        options.seperator = this.sheet.seperator;
      }

      ecosis.ckan.processResource(
          ecosis.ds.package_id,
          this.sheet.resourceId,
          this.sheet.sheetId,
          options,
          function(resp){
            // set to timestamp for data changed stuff
            ecosis.ds.package.data.metadata_modified = resp.metadata_modified;
            resp = resp.result;

            if( Array.isArray(resp) ) {
              resp = resp[0];
            }

            this.setSaving(false);

            if( resp.error ) {
              // ERROR 16
              resp.code = 16;
              resp.message += '.  Error updating datasheet.';
              return ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
            }

            this.sheet = resp;
            ecosis.ds.setSheet(resp);

            ecosis.ds.fireUpdate();

            this.$.preview.update(this.sheet);

            this.updateMetadataUi();
            this.updateIgnoreUi();

            this.fire('sheet-update', {
              id : resp.resourceId,
              sheetId : resp.sheetId
            });
          }.bind(this)
      );
    },

    edit : function(callback) {
      // set title
      if( this.resource.datasheets.length == 1 ) {
        var title = this.sheet.name;
        if( this.sheet.sheetId ) title += ' ('+this.sheet.sheetId+')';
        this.$.titleLabel.innerHTML = title;
      } else { // title is shown by dropdown
        this.$.titleLabel.innerHTML = '';
      }

      this.$.preview.update(this.sheet);

      // show parse error
      if( this.sheet.error ) this.$.parseError.style.display = 'block';
      else this.$.parseError.style.display = 'none';

      // should we show the metadata selection
      if( this.sheet.ignore ) this.$.metadataSelectPanel.style.display = 'none';
      else this.$.metadataSelectPanel.style.display = 'block';


      // set the correct layout
      if( this.sheet.layout == 'column' ) {
        $(this.$.columnInput).prop('checked', true);
        $(this.$.rowInput).prop('checked', false);
      } else {
        $(this.$.columnInput).prop('checked', false);
        $(this.$.rowInput).prop('checked', true);
      }

      this.updateMetadataUi();
      this.updateIgnoreUi();
      this.updateSeperatorUi();

      // see if there are repeats
      if( this.sheet.repeatAttributes && !this.sheet.ignore) {
        var html = '<b>Warning.</b> You have repeat '+(this.layout === 'column' ? 'row' : 'column') +' attribute headers:';

        html += '<ul>';
        this.sheet.repeats.forEach(function(repeat){
          html += '<li>'+repeat+'</li>';
        });
        html += '</ul>';

        html += 'Possible solutions.  You may not have the sheet orientation set correctly.  Or you may have multiple attributes '+
                'defined with ().  Remember, units are specified by () and anything between parentheses will be removed from the '+
                'name and considered units for the attribute.';

        this.$.repeatsWarning.innerHTML = html;
        this.$.repeatsWarning.style.display = 'block';
      } else {
        this.$.repeatsWarning.style.display = 'none';
      }

      if( callback ) callback();
    },

    updateMetadataUi : function() {
      if( this.sheet.metadata) {
        this.$.joinMetadata.update(this.sheet, this.resource);
        this.$.joinMetadataOuter.style.display = 'block';
        $(this.$.inputIsMetadata).prop('checked', true);
      } else {
        this.$.joinMetadataOuter.style.display = 'none';
        $(this.$.inputIsMetadata).prop('checked', false);
      }
    },

    updateIgnoreUi : function() {
      var panels = ['orientationPanel', 'metadataSelectPanel'];

      if( this.sheet.ignore ) {
        panels.forEach(function(id){
          this.$[id].style.display = 'none';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', true);
        this.$.preview.style.display = 'none';
      } else {
        panels.forEach(function(id){
          this.$[id].style.display = 'block';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', false);
        this.$.preview.style.display = 'block';
      }
    },

    updateSeperatorUi : function() {
      if( !this.sheet.isCSV ) {
        this.$.seperatorPanel.style.display = 'none';
        return;
      }

      this.$.seperatorPanel.style.display = 'block';
      $(this).find('.orientation-radio').prop('checked', false);
      this.$.otherSeperatorInput.value = '';

      if( !this.sheet.seperator ) {
        this.$.commaInput.checked = true;
        return;
      }

      var options = [',', 'tab', ';'];
      if( options.indexOf(this.sheet.seperator) > -1 ) {
        $(this).find('[value="'+this.sheet.seperator+'"]').prop('checked', true);
        return;
      }

      this.$.otherInput.checked = true;
      this.$.otherSeperatorInput.value = this.sheet.seperator;
    },

    onOrientationChange : function(e) {
      this.sheet.layout = e.currentTarget.value;
      if( this.sheet.layout == 'column' ) {
        $(this.$.rowInput).prop('checked', false);
      } else {
        $(this.$.columnInput).prop('checked', false);
      }

      this.save();
    },

    onSeperatorChange : function(e) {
      var ele = e.currentTarget;

      if( ele.getAttribute('type') == 'radio' ) {
        $(this).find('.orientation-radio').prop('checked', false);
        $(ele).prop('checked', true);
      }

      var val = e.currentTarget.value;
      if( val === 'other' ) {
        val = this.$.otherSeperatorInput.value;
      }

      if( !val ) return;

      this.sheet.seperator = val;
      this.save();
    },

    toggleHelp : function() {
      $(this.$.formatHelp).toggle();
    },

    loadFullDatasheet : function(callback) {

      for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
        var sheet = ecosis.ds.datasheets[i];
        if( this.sheetId ) {
          if( sheet.resourceId == this.resourceid && sheet.sheetId == this.sheetId ) {
            this.sheet = sheet;
            break;
          }
        } else if( sheet.resourceId == this.resourceid ) {
          this.sheet = sheet;
        }
      }

      this.edit();

      if( callback ) callback();
    },

    setLoading : function(loading) {
      if( loading ) {
        this.$.main.style.display = 'none';
        this.$.loading.style.display = 'block';
      } else {
        this.$.main.style.display = 'block';
        this.$.loading.style.display = 'none';
      }
    },

    onMetadataPanelUpdate : function(e) {
      if( e.detail.updating ) {
        this.$.inputIsMetadata.setAttribute('disabled', '');
        this.$.inputIgnore.setAttribute('disabled', '');
      } else {
        this.$.inputIsMetadata.removeAttribute('disabled');
        this.$.inputIgnore.removeAttribute('disabled');
      }
    },

    onMetadataUpdate : function() {
      if( $(this.$.inputIsMetadata).is(':checked') ) {
        this.sheet.metadata = true;
        this.fire('type-change', {type: 'metadata'});
      } else {
        this.sheet.metadata = false;
        this.fire('type-change', {type: 'data'});
      }

      this.save();
    },

    onIgnoreUpdate : function() {
      if( $(this.$.inputIgnore).is(':checked') ) {
        this.sheet.ignore = true;
      } else {
        this.sheet.ignore = false;
      }

      this.save();
    },

    setSaving : function(saving) {
      this.$.updatingPanel.style.display = saving ? 'block' : 'none';

      if( saving ) {
        $(this).find('input').attr('disabled', '');
      } else {
        $(this).find('input').removeAttr('disabled');
      }
    }
  });
</script>
<dom-module id="ecosis-resource-panel">
  <style>
    :host {
      display: block;
    }
    a.btn-link {
      padding-top: 0;
    }
    span.label-danger {
      box-shadow: 0 0 5px white;
      border: 1px solid white;
    }
    input[type="checkbox"]:after {
      border: 2px solid white !important;
    }
    .alert-primary {
      background-color: #2196f3;
    }
    .alert-default {
      background-color: #888;
    }
    .file-metadata div {
      color: #eee;
      font-size: 11px;
      padding: 0 5px;
    }
    .file-metadata div span {
      font-weight: bold;
    }
    #titleLabel {
      font-weight: bold;
    }
  </style>

  <template>
    <template id="singleResource" is="dom-template">
      <div class="alert alert-default" id="root">
          <div class="layout horizontal">
            <div class="flex">
              <input type="checkbox" id="select" on-click="fireSelectEvent">
              <span id="titleLabel"></span>
              <a class="btn btn-link" style="color:white" on-click="delete" id="trashBtn"><i class="fa fa-trash"></i></a>
              <span class="label label-danger" id="deletePanel" style="display:none">
                <i class="fa fa-spinner fa-spin"></i> Deleting Resource...
              </span>
            </div>
            <div>
              <a class="btn btn-link" style="color:white" id="downloadBtn" target="_blank"><i class="fa fa-download"></i></a>

              <a class="btn btn-link" style="color:white" id="editLink" on-click="toggleEdit">
                <i class="fa fa-pencil" id="editLinkIcon"></i>
              </a>
            </div>
          </div>
          <div class="layout horizontal file-metadata">
            <div>Created: <span id="createdDate"></span></div>
            <div>Size: <span id="fileSize"></span></div>
          </div>
      </div>
    </template>

    <template id="zipResource" is="dom-template">
      <div class="panel panel-warning" id="root">
        <div class="panel-heading">
          <div class="layout horizontal">
            <div class="flex">
              <input type="checkbox" id="select" on-click="fireSelectEvent">

              <span id="titleLabel"></span>

              <a class="btn btn-link" style="color:white" on-click="delete" id="trashBtn"><i class="fa fa-trash"></i></a>

              <span class="label label-danger" id="deletePanel" style="display:none">
                <i class="fa fa-spinner fa-spin"></i> Deleting Resource...
              </span>
            </div>
            <div>
              <a class="btn btn-link" style="color:white" id="downloadBtn" target="_blank"><i class="fa fa-download"></i></a>
            </div>
          </div>
          <div class="layout horizontal file-metadata">
            <div>Created: <span id="createdDate"></span></div>
            <div>Size: <span id="fileSize"></span></div>
          </div>
        </div>
        <div class="panel-body">
          <ecosis-isotope id="zipResources" selector=".zip-item"></ecosis-isotope>
        </div>
      </div>
    </template>

    <div id="templateRoot"></div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-resource-panel',

    properties : {
      resourceid : {
        type : String
      },
      hasDoi : {
        type : Boolean
      }
    },

    ready : function() {
      this.datatypes = ['xls','xlsx','csv','tsv','spectra'];
      this.edit = false;
      this.resource = null;
    },

    attached : function() {
      if( !this.resourceid ) return;

      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        if( this.resourceid == resource.id ) {
          this.resource = resource;
          break;
        }
      }

      this.update();
    },

    updateNameLabel : function() {
      var parseInfo = '';
      if( this.resource.datasheets && this.resource.datasheets.length == 1 ) {
        var sheet = this.resource.datasheets[0];
        if( !sheet.ignore && sheet.name) {
          if( sheet.name.match(/(spectra|csv|tsv)$/i) ){
            parseInfo = ' ('+(this.resource.datasheets[0].layout || 'row')+'/'+(this.resource.datasheets[0].seperator || 'comma')+')';
          }
        }
      }

      this.querySelector('#titleLabel').innerHTML = this.resource.name+parseInfo;
    },

    update : function() {
      this.setAttribute('data-name', this.resource.name);

      if( this.resource.isZip ) {
        this.ele = this.$.zipResource.stamp();
      } else {
        this.ele = this.$.singleResource.stamp();
      }
      this.$.templateRoot.innerHTML = '';
      this.$.templateRoot.appendChild(this.ele.root);

      this.querySelector('#createdDate').innerHTML =  new Date(this.resource.created).toLocaleString();

      var size = this.resource.file_size;
      if( size < 999999 ) {
        size = Math.floor(size / 1000)+'kB';
      } else {
        size = (size / 1000000).toFixed(1)+'MB';
      }
      this.querySelector('#fileSize').innerHTML = size;

      this.setClass();

      if( !this.resource.datasheets ) {
        this.querySelector('#trashBtn').style.color = '#333';
      }

      if( this.resource.fromZip ) {
        this.querySelector('#select').style.display = 'none';
      }

      // hide edit button if invalid file type
      if( this.resource.datasheets && this.resource.datasheets.length > 0 && this.resource.datasheets[0].invalidFileType ) {
        var link = this.querySelector('#editLink');
        if( link ) link.style.display = 'none';
      } else {
        var link = this.querySelector('#editLink');
        if( link && !this.hasDoi ) link.style.display = 'inline-block';
      }

      this.updateNameLabel();

      if( this.resource.childResources ) {
        this.isotope = this.querySelector('#zipResources');
        this.isotope.clear();

        for( var i = 0; i < this.resource.childResources.length; i++ ) {
          var ele = document.createElement('ecosis-resource-panel');
          ele.style.width = '100%';
          ele.className = 'zip-item';
          ele.resource = this.resource.childResources[i]; // manually set
          this.isotope.append(ele);
          ele.update();
        }

        this.isotope.init();
      }

      var url = ecosis.ckan.host+'/dataset/'+this.resource.package_id+'/resource/'+this.resource.id+'/download/'+this.resource.name;

      this.querySelector('#downloadBtn').setAttribute('href', url);
    },

    sort : function(sortBy) {
      if( !this.isotope ) return;
      this.isotope.sort(sortBy);
    },

    filter : function(filter) {
      if( !this.isotope ) return;
      this.isotope.filter(filter);
    },

    setClass : function() {
      var type = this.getResourceType();

      // update icons as well;
      if( this.resource.fromZip ) {
        this.querySelector('#trashBtn').style.display = 'none';
        this.querySelector('#downloadBtn').style.display = 'none';
      } else {
        this.querySelector('#trashBtn').style.display = 'inline-block';
        this.querySelector('#downloadBtn').style.display = 'inline-block';
      }

      if( this.hasDoi ) {
        this.querySelector('#trashBtn').style.display = 'none';
        this.querySelector('#select').style.display = 'none';
        this.querySelector('#editLink').style.display = 'none';
      }

      // update css class
      if( this.resource.isZip ) {
        this.setAttribute('data-type', 'zip');
        return;
      }

      var className = this.getPanelClass(type);
      this.querySelector('#root').className = 'style-scope ecosis-resource-panel alert alert-'+className;
      this.setAttribute('data-type', className);
    },

    getPanelClass : function(type) {
      if( type == 'data' ) return 'success';
      if( type == 'metadata' ) return 'primary';
      if( type == 'multi' ) return 'info';
      return 'default';
    },

    getResourceType : function() {
      if( this.resource.datasheets && this.resource.datasheets.length == 1 ) {
        if( this.resource.datasheets[0].ignore ) {
          return 'ignored';
        } else if( this.resource.datasheets[0].metadata ) {
          return 'metadata';
        } else {
          return 'data';
        }
      } else if( this.resource.datasheets && this.resource.datasheets.length > 1 ) {
        return 'multi';
      }

      return 'ignored';
    },

    toggleEdit : function() {
      var resourcePopup = document.querySelector('#resourcePopup');

      resourcePopup.edit(this.resource, {
        onDatasheetUpdate : function() {
          this.setClass();
          this.updateNameLabel();
        }.bind(this)
      });

      this.edit = !this.edit;

      this.fire('editing', this.resourceid);
    },

    fireSelectEvent : function() {
      this.fire('resource-select');
    },

    select : function(select) {
      if( select ) $(this).find('#select').prop('checked', true);
      else $(this).find('#select').prop('checked', false);
    },

    isSelected : function() {
      return $(this).find('#select').is(':checked');
    },

    delete : function() {
      if( !confirm("Are you sure you want to remove: "+this.resource.name+"?") ) return;
      this.forceDelete();
    },

    forceDelete : function() {
      this.querySelector('#deletePanel').style.display = 'inline-block';

      ecosis.ckan.removeResource(this.resource.id,
        function(resp){
          this.querySelector('#deletePanel').style.display = 'block';

          if( resp.error ) {
            // ERROR 17
            resp.code = 17;
            resp.message += '. Server error deleting resource.';
            return ecosis.errorPopup.show(resp);
          }

          for( var i = ecosis.ds.resources.length-1; i >= 0; i-- ) {
            var r = ecosis.ds.resources[i];

            if( r.id == this.resourceid ) {
              ecosis.ds.resources.splice(i, 1);
            } else if ( r.zip && r.zip.resourceId == this.resourceid  ) {
              ecosis.ds.resources.splice(i, 1);
            }
          }
          ecosis.ds.fireUpdate();

          ecosis.ds.deleteResourceTime = new Date();
          ecosis.ds.checkChanges();

          var ele = this;
          $(this).hide('slow', function(){
            $(this).detach();
            ele.fire('update', ele.resourceid);
          });


        }.bind(this)
      );
    }
  });
</script>


<dom-module id="ecosis-sheet-preview">
  <style>
    :host {
      display: block
    }
    .info {
      margin-top: 10px !important;
    }
  </style>

  <template>
    <span class="pull-right label label-warning" id="loading" style="display:none"><i class="fa fa-spin fa-circle-o-notch"></i> Loading...</span>
    <h4 class="info page-header" id="info"></h4>

    <div id="nodata" style="display:none" class="text text-warning">
      No data in this sheet.
    </div>

    <div id="data">
      <div class="layout horizontal center">
          <a class="btn btn-default" id="leftArrow" on-click="moveLeft"><i class="fa fa-arrow-left"></i></a>

          <div class="flex" id="columnPreview" style="overflow:hidden">
            <div class="row">
              <div class="col-sm-6">
                <div id="columnTableRoot" style="height: 300px; overflow:auto; margin-left: 10px"></div>
              </div>
              <div class="col-sm-6" id="columnChartRoot" style="height: 300px"></div>
            </div>
          </div>

          <div class="flex" id="rowPreview" style="overflow:hidden">
            <div id="rowTableRoot" style="overflow:auto; margin-bottom: 35px"></div>
            <div id="rowChartRoot" style="height: 200px; margin: 25px 0 15px 0"></div>
          </div>

          <a class="btn btn-default" id="rightArrow" on-click="moveRight"><i class="fa fa-arrow-right"></i></a>
      </div>

      <div id="photoPreview" style="text-align:center"></div>

      <div id="sliderRoot" style="margin-top: 15px"></div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : "ecosis-sheet-preview",

    ready : function() {
      this.index = 0;
    },

    load : function(index) {
      if( index !== undefined ) this.index = index;

      if( this.index >= this.info.total ) {
        this.index = this.info.total-1;
      }
      if ( this.index < 0 ) {
        this.index = 0;
      }

      this.slider.slider('setValue', this.index+1);

      if( this.info.total == 0 ) {
        this.$.nodata.style.display = 'block';
        this.$.data.style.display = 'none';
        return;
      } else {
        this.$.nodata.style.display = 'none';
        this.$.data.style.display = 'block';
      }

      // this.$.info.innerHTML = '<i class="fa fa-spin fa-circle-o-notch"></i> Loading index: '+this.index;
      this.loading(true);

      if( this.sheet.metadata ) {
        ecosis.ckan.getMetadataChunk(
          this.sheet.packageId,
          this.sheet.resourceId,
          this.sheet.sheetId,
          this.index,
          this.renderMetadataResp.bind(this)
        );
      } else {
        ecosis.ckan.getSpectra(
          this.sheet.packageId,
          this.sheet.resourceId,
          this.sheet.sheetId,
          this.index,
          this.renderSpectraResp.bind(this)
        );
      }
    },

    renderMetadataResp : function(resp) {
      this.loading(false);
      if( resp.error ) {
        // ERROR 18
        resp.code = 18;
        return ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
      }


      this.renderTable(resp.metadata);
      var layout = this.sheet.layout || 'row';

      if( resp.joinKey && resp.metadata[resp.joinKey] ) {
        var joined = 'None';
        if( resp.joinedResources.length > 0 ) {
          joined = '';
          for( var i = 0; i < resp.joinedResources.length; i++ ) {
            joined += resp.joinedResources[i].name + (resp.joinedResources[i].sheetId ? ' - '+resp.joinedResources[i].sheetId.split('-')[1]+'' : '')+
              ' on '+(resp.joinedResources[i].layout || 'row')+' '+resp.joinedResources[i].index;
            if( i < resp.joinedResources.length-1 ) joined += ', ';
          }
        }

        this.$[layout+'ChartRoot'].innerHTML =
          '<h4 style="text-align:center">Joined On:</h4> '+
          '<h5 style="text-align:center">'+resp.joinKey+' = <span style="color:#888">'+resp.metadata[resp.joinKey]+'</span></h5>'+
          '<h4 style="text-align:center">Matches:</h4>'+
          '<h6 style="text-align:center; color:#888">'+joined+'</h6>';
      } else {
        this.$[layout+'ChartRoot'].innerHTML = '<div style="text-align:center" class="text text-warning"><i class="fa fa-warning"></i> No join key provided, please select one below</div>'
      }

      this.$.info.innerHTML =
        '<i class="fa fa-binoculars"></i> <span style="text-transform:capitalize">'+this.sheet.layout+'</span> Preview <small><b>'+(this.index+1)+'</b> of <b>'+this.info.total+'</b></small> '+
        '<small class="pull-right">Join Count: '+this.info.joinCount+'</small>';
    },

    renderSpectraResp : function(resp) {
      this.loading(false);
      if( resp.error ) {
        // ERROR 19
        resp.code = 19;
        ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
      }

      this.renderTable(resp, ['ecosis', 'datapoints']);
      var layout = this.sheet.layout || 'row';

      if( !(this.$[layout+'ChartRoot'].firstChild && this.$[layout+'ChartRoot'].firstChild.nodeName.toLowerCase() == 'ecosis-chart') ) {
        this.$[layout+'ChartRoot'].innerHTML = '<ecosis-chart></ecosis-chart>';
      }

      this.$.info.innerHTML = '<i class="fa fa-binoculars"></i> <span style="text-transform:capitalize">'+this.sheet.layout+'</span> Preview <small> <b>'+(this.index+1)+'</b> of <b>'+this.info.total+'</b></small>';

      var data = [];
      for( var key in resp.datapoints ) {
          data.push([
              parseFloat(key),
              parseFloat(resp.datapoints[key])
          ])
      }

      data.sort(function(a, b){
          if( a[0] > b[0] ) return 1;
          if( a[0] < b[0] ) return -1;
          return 0;
      });

      data.splice(0, 0, ['Wavelength', '']);

      // HACK:  FF seems to be slow upgrading the <ecosis-chart /> element :(
      setTimeout(function(){
        this.$[layout+'ChartRoot'].firstChild.setHeight(layout === 'row' ? 200 : 300);
        this.$[layout+'ChartRoot'].firstChild.options = {
          animation:{
            duration: 700,
            easing: 'out',
          }
        }
        this.$[layout+'ChartRoot'].firstChild.setData(data);
      }.bind(this), 200)

    },

    initSlider : function() {
      this.$.sliderRoot.innerHTML = '<input id="slider" style="width:100%" data-slider-id="ex1Slider" type="text"'+
        ' data-slider-min="1" data-slider-max="'+this.info.total+'" data-slider-step="1" data-slider-value="'+this.index+'"/>';

      this.$.slider = this.querySelector('#slider');
      this.slider = $(this.$.sliderRoot.firstChild).slider({});
      $(this.$.slider).parent().width('100%');

      var updateTimer = -1;

      this.slider.on('slideStop', function(e){
        if( updateTimer != -1 ) clearTimeout(updateTimer);
        updateTimer = setTimeout(function(){
          updateTimer = -1;
          this.load(e.value-1);
        }.bind(this), 100);
      }.bind(this));
    },

    getUnitsLabel : function(attr) {
      var units;
      if( this.sheet.units ) {
        if( this.sheet.units[attr] ) {
          units = this.sheet.units[attr];
        }
      }

      if( !units && this.units ) {
        if( this.units[attr] ) {
          units = this.units[attr];
        }
      }

      if( !units ) return '';

      return ' <span style="color:#aaa;font-size: 80%;font-weight:normal">('+units+')</span>';
    },

    setAllUnits : function(metadata) {
      this.units = null;
      if( !ecosis.ds.datasheets ) return;

      this.units = {};
      for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
        if( ecosis.ds.datasheets[i].units ) {
          var u = ecosis.ds.datasheets[i].units;
          for( var key in u ) {
            this.units[key] = u[key];
          }
        }
      }
    },

    renderTable : function(metadata, ignorelist) {
      if( ignorelist === undefined ) ignorelist = [];
      ignorelist.push('photo');

      var layout = this.sheet.layout || 'row';
      var table = '<h5>Metadata</h5><table class="table">';

      if( this.sheet.layout === 'column' ) {
        var c = 0;
        for( var key in metadata ) {
          if( ignorelist.indexOf(key.trim().toLowerCase()) > -1 ) continue;

          var units = this.getUnitsLabel(key);
          table += '<tr><td><span style="font-weight:bold">'+key+units+'</span></td><td>'+metadata[key]+this.getProcessInfo(key, metadata)+'</td></tr>';

          c++;
          if( c == 100 ) {
            table += '<tr><td>...</td><td>...</td></tr>';
            break;
          }
        }
      } else {
        var c = 0;
        var header = '<tr>';
        var data = '<tr>';
        for( var key in metadata ) {
          if( ignorelist.indexOf(key.trim().toLowerCase()) > -1 ) continue;

          var units = this.getUnitsLabel(key);
          header += '<th style="white-space:nowrap">'+key+units+'</th>';
          data += '<td style="white-space:nowrap; max-width: 250px; overflow:auto">'+metadata[key]+this.getProcessInfo(key, metadata)+'</td>';

          c++;
          if( c == 100 ) {
            header += '<td>...</td>';
            data += '<td>...</td>';
            break;
          }
        }
        table += header+'</tr>'+data+'</tr>';
      }

      var photoUrl = '';
      for( var key in metadata ) {
        if( key.trim().toLowerCase() === 'photo' ) {
          photoUrl = metadata[key];
          break;
        }
      }

      if( photoUrl ) {
        this.$.photoPreview.innerHTML = '<img src="'+photoUrl+'" class="img img-thumbnail" style="margin:10px; max-height: 350px" />';
        $(this.$.photoPreview)
          .find('img')
          .on('error', function(){
            this.$.photoPreview.innerHTML = '<a href="'+photoUrl+'" target="_blank" >Spectra Photo</a>';
          }.bind(this));
      } else {
        this.$.photoPreview.innerHTML = '';
      }

      this.$[layout+'TableRoot'].innerHTML = table+'</table>';

      $(this.$[layout+'TableRoot']).find('[data-toggle="tooltip"]').tooltip()
    },

    getProcessInfo : function(key, metadata) {
      if( !metadata.ecosis ) return '';
      if( !metadata.ecosis.processInfo ) return '';

      var matches = [];
      for( var i = 0; i < metadata.ecosis.processInfo.length; i++ ) {
        if( metadata.ecosis.processInfo[i].key == key ) {
          matches.push(metadata.ecosis.processInfo[i]);
        }
      }

      if( matches.length == 0 ) return '';

      var resp = '';
      for( var i = 0; i < matches.length; i++ ) {
          resp += this.getProcessMessage(matches[i]);
      }
      return resp;
    },

    getProcessMessage : function(info) {
      var header = '<div style="font-size:11px;color:#999;font-style:italic">';
      var footer = '</div>';

      header = '<a style="cursor:pointer" data-toggle="tooltip" data-placement="bottom" data-original-title="';
      footer = '">*</a>';

      if( info.type == 'join' ) {
        try {
          var name = ecosis.ds.resourceLookup[info.resourceId].name;
          return header+'Joined from '+name+(info.sheetId ? ' ('+info.sheetId.split('-')[1]+')' : '')+footer;
        } catch(e) {}
      } else if ( info.type == 'usda lookup') {
        return header+'Appended from USDA Symbol'+footer;
      } else if ( info.type == 'mapped') {
        return header+'Mapped from '+info.from+footer;
      }

      return '';
    },

    update : function(sheet, autoUpdateUnits) {
      if( sheet ) {
        this.sheet = sheet;
      }

      this.setAllUnits();

      if( this.sheet.ignore ) return;

      if( this.sheet.layout === 'column' ) {
        this.$.columnPreview.style.display = 'block';
        this.$.rowPreview.style.display = 'none';
        this.$.leftArrow.querySelector('i').className = 'fa fa-arrow-left';
        this.$.rightArrow.querySelector('i').className = 'fa fa-arrow-right';
      } else {
        this.$.columnPreview.style.display = 'none';
        this.$.rowPreview.style.display = 'block';
        this.$.leftArrow.querySelector('i').className = 'fa fa-arrow-up';
        this.$.rightArrow.querySelector('i').className = 'fa fa-arrow-down';
      }

      if( this.sheet.metadata ) {
        this.updateMetadata();
      } else {
        this.updateSpectra();
      }
    },

    updateMetadata : function() {
      ecosis.ckan.getMetadataInfo(this.sheet.packageId, this.sheet.resourceId, this.sheet.sheetId, function(resp){
        this.loading(false);
        this.info = resp;
        this.initSlider();
        this.load();
      }.bind(this));
    },

    updateSpectra : function() {
      ecosis.ckan.getSpectraCount(this.sheet.packageId, this.sheet.resourceId, this.sheet.sheetId, function(resp){
        this.loading(false);
        this.info = resp;
        this.initSlider();
        this.load();
      }.bind(this));
    },

    loading : function(loading) {
      if( loading ) this.$.loading.style.display = 'inline-block';
      else this.$.loading.style.display = 'none';
    },

    moveLeft : function() {
      this.index--;
      this.load();
    },

    moveRight : function() {
      this.index++;
      this.load();
    }

  })
</script>

<dom-module id="ecosis-resource-popup">
  <template>
    <div class="modal fade" id="popup">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>
            <h4 class="modal-title" id="title"></h4>
          </div>
          <div class="modal-body" style="padding: 25px">
            <ecosis-datasheet-select-panel style="display:none" id="datasheetSelector" on-select="onDatasheetSelected">
            </ecosis-datasheet-select-panel>

            <ecosis-datasheet-panel id="datasheetUI" on-sheet-update="onDatasheetUpdate">
            </ecosis-datasheet-panel>
          </div>
          <div class="modal-footer">
            <div class="singleMode">
              <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            </div>
            <div class="wizardMode">
              <div class="layout horizontal">
                <div>
                  <button type="button" id="prev" class="btn btn-default" on-click="prev">Previous</button>
                </div>
                <div class="flex" style="text-align:center">
                  <button type="button" class="btn btn-primary" data-dismiss="modal">Finished</button>
                </div>
                <div>
                  <button type="button" id="next" class="btn btn-default" on-click="next">Next</button>
                </div>
              </div>
            </div>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-resource-popup',

    ready : function() {
      this.popup = $(this.$.popup);
      this.popup.remove();
      $('body').append(this.popup);

      this.popup.modal({
        show: false,
        backdrop : 'static'
      });
    },

    next : function() {
      this.index++;
      if( this.index > this.resources.length-1 ) {
        this.index = this.resources.length - 1;
        return;
      }
      this.updateNav();
      this.show(this.resources[this.index]);
    },

    prev : function() {
      this.index--;
      if( this.index < 0 ) {
        this.index = 0;
        return;
      }
      this.updateNav();
      this.show(this.resources[this.index]);
    },

    updateNav : function() {
      if( this.index == 0 ) this.$.prev.setAttribute('disabled','disabled');
      else this.$.prev.removeAttribute('disabled');

      if( this.index >= this.resources.length-1 ) this.$.next.setAttribute('disabled','disabled');
      else this.$.next.removeAttribute('disabled');
    },

    setMode : function(mode) {
      if( mode === 'single' ) {
        $(this.$.popup).find('.singleMode').show();
        $(this.$.popup).find('.wizardMode').hide();
      } else {
        $(this.$.popup).find('.singleMode').hide();
        $(this.$.popup).find('.wizardMode').show();
      }
    },

    uploadWizard : function(resources, handlers ) {
      this.setMode('wizard');
      this.resources = resources;
      this.index = 0;
      this.updateNav();
      this.handlers = handlers;
      this.show(resources[0]);
    },

    edit : function(resource, handlers) {
      this.setMode('single');
      this.handlers = handlers;
      this.show(resource);
    },

    show : function(resource) {
      this.resource = resource;

      this.$.title.innerHTML = this.resource.name;

      if( !this.resource.datasheets ) {
        this.$.datasheetSelector.style.display = 'none';
      } else if( this.resource.datasheets.length <= 1 ) {
        this.$.datasheetSelector.style.display = 'none';
      } else {
        this.$.datasheetSelector.style.display = 'block';
        this.$.datasheetSelector.update(this.resource);
      }

      this.selectDatasheet(0);

      this.popup.modal('show');
    },

    onDatasheetUpdate : function() {
      this.$.datasheetSelector.updateClass();
      if( this.handlers ) this.handlers.onDatasheetUpdate();
    },

    selectDatasheet : function(index, edit) {
      // required for datasheet display
      if( this.resource.name.match(/\.csv$/i) || this.resource.name.match(/\.spectra$/i) ) {
        this.resource.datasheets[index].isCSV = true;
      } else {
        this.resource.datasheets[index].isCSV = false;
      }

      // set the resource and sheet we are going to render
      this.$.datasheetUI.update(this.resource, this.resource.datasheets[index]);
      this.$.datasheetUI.edit();
    },

    onDatasheetSelected : function(e) {
      this.selectDatasheet(e.detail, true);
    }
  })
</script>

<dom-module id="ecosis-error-popup">
  <template>
    <div class="modal fade" id="popup" style="z-index: 10000">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close singleMode" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>
            <h4 class="modal-title text text-danger">Badness</h4>
          </div>

          <div class="modal-body" style="padding: 0 25px">
            <h5 class="text text-danger">Error: <span id="message"></span></h5>

            <div id="report" style="margin: 50px 15px 20px 15px">
              If you feel this is a bug, please help us fix by reporting
              <a href="https://github.com/CSTARS/ckanext-ecosis/issues/new" target="_blank">here on GitHub</a>!
              <br><b>Copy and paste</b> message below into GitHub Issue:
            </div>
            <div class="well">
              <div> - <b>Package ID:</b> <span id="project"></span></div>
              <div> - <b>Message:</b> <span id="message2"></span></div>
              <div> - <b>Code:</b> <span id="code"></span></div>
              <div> - <b>User Agent:</b> <span id="useragent"></span></div>
              <div id="gitInfo"></div>
              <div>[Any Additional Info Here]</div>
            </div>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->

  </template>

  <script>
    Polymer({
      is : "ecosis-error-popup",

      ready : function() {
        this.popup = $(this.$.popup);
        this.popup.remove();
        $('body').append(this.popup);

        this.popup.on('hidden.bs.modal', function(){
          if( this.priorPopup ) this.priorPopup.modal('show');
        }.bind(this));

        this.popup.modal({
          show: false,
          backdrop : 'static'
        });
      },

      show : function(e, popup) {
        this.priorPopup = popup;
        if( popup ) {
          popup.modal('hide');
          setTimeout(function(){
            this._show(e);
          }.bind(this), 350);
        } else {
          this._show(e);
        }
      },

      _show : function(e) {
        var msg = '';
        var body;

        // hack
        if( e.details && e.details.response && e.details.response.body ) {
          body = e.details.response.body;
          if( typeof body === 'object' && body.error ) {
            let keys = Object.keys(body.error);
            keys.forEach(key => {
              if( key.match(/^__/) ) return;
              if( Array.isArray(body.error[key]) ) {
                msg += body.error[key].join('. ')+'. ';
              } else {
                msg += body.error[key]+'. ';
              }
            });
          }
        }


        if( !msg && e.details && e.details.message ) {
          msg = e.details.message;
        }

        this.$.message.innerHTML = msg || e.message || '';
        this.$.message2.innerHTML = e.message || '';
        this.$.project.innerHTML = ecosis.ds.package_id;
        this.$.code.innerHTML = e.code || -1;
        this.$.useragent.innerHTML = navigator.userAgent;

        var html = '';
        if( ecosis.git ) {
          for( var key in ecosis.git ) {
            html += '<div> - <b>'+key+':</b> '+ecosis.git[key]+'</div>';
          }
          html += '<br />';
        }
        this.$.gitInfo.innerHTML = html;

        this.popup.modal('show');
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-upload-splash">
  <template>
    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-body" style="padding: 25px">

            <div class="alert alert-success"><h5 style="color:white">Upload Complete!</h5></div>

            <div style="text-align:center" id="hasResources">
              <h3><i class="fa fa-cogs"></i> Configure Resources</h3>

              <div style="margin: 10px 0 30px 0">
                You will now have a chance to configure your uploaded resources.
              </div>
            </div>

            <div style="text-align:center">
              <a class="btn btn-default btn-lg" on-click="hide">Continue</a><a>
            </a></div><a>


          </a></div><a>
        </a></div><!-- /.modal-content --><a>
      </a></div><!-- /.modal-dialog --><a>
    </a></div><!-- /.modal --><a>

  </a></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-upload-splash',

    ready : function() {
      this.popup = $(this.$.popup);
      this.popup.remove();
      $('body').append(this.popup);

      this.popup.modal({
        show: false,
        backdrop : 'static'
      });

      this.popup.on('hidden.bs.modal', function(){
        if( this.resources.length == 0 ) return;
        this.wizard.uploadWizard(this.resources, this.handlers);
      }.bind(this));

      this.wizard = document.querySelector('ecosis-resource-popup');
    },

    show : function(resources, handlers) {
      this.resources = resources;
      this.handlers = handlers;

      if( resources.length == 0 ) {
        this.$.hasResources.style.display = 'none';
      } else {
        this.$.hasResources.style.display = 'block';
      }

      this.popup.modal('show');
    },

    hide : function() {
      this.popup.modal('hide');
    }
  });
</script>

<dom-module id="ecosis-chart">
  <style>
    :host {
        display: block;
    }
  </style>

  <template>
    <div id="root" style="height:400px"></div>

    <div id="noData" style="color:#888">
      No spectral data to chart.
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-chart',

    properties : {
      animate : {
          type : Boolean,
          value : false
      },
      type : {
        type : String
      }
    },

    ready : function() {
      this.dt = null;
      this.chart = null;
      this.height = 400;

      this.updateTimer = -1;

      this.onLoadHandlerSet = false;

      this.options = null;
      this.cols = null;

      $(window).on('resize', function(){
          this.redraw();
      }.bind(this));
    },

    setHeight : function(height) {
      this.height = height;
      this.$.root.style.height = height+'px';
    },

    setOnloadHandler : function() {
        if( this.onLoadHandlerSet ) return;

        // put in global scope by cwn-datastore
        chartLoadHandlers.push(function(){
            this.update();
        }.bind(this));
    },

    setData : function(data) {
      this.data = data;
      this.update();
    },

    update : function() {
        if( !window.google.visualization ) return this.setOnloadHandler();
        if( !window.google.visualization.LineChart ) return this.setOnloadHandler();

        if( this.isEmpty() ) {
          this.$.root.style.display = 'none';
          this.$.noData.style.display = 'block';
          return;
        }
        this.$.root.style.display = 'block';
        this.$.noData.style.display = 'none';

        if( !this.chart ) {
            if( this.type ) {
                this.chart = new google.visualization[this.type](this.$.root);
            } else {
                this.chart = new google.visualization.LineChart(this.$.root);
            }
        }

        if( this.updateTimer == -1 ) clearTimeout(this.updateTimer);
        this.updateTimer = setTimeout(function() {
            this.updateTimer = -1;
            this._update();
        }.bind(this), 500);
    },

    _update : function() {
        if( this.cols ) {
            this.dt = new google.visualization.DataTable();
            for( var i = 0; i < this.cols.length; i++ ) {
                this.dt.addColumn(this.cols[i]);
            }
            this.dt.addRows(this.data);
        } else {
            this.dt = google.visualization.arrayToDataTable(this.data);
        }

        this.redraw();
    },

    isEmpty : function() {
        if( !this.data ) {
            return true;
        }
        if( this.data.length < 2 ) {
            return true;
        }
        if( this.data[0].length == 0 ) {
            return true;
        }

        return false;
    },

    redraw : function() {
        if( !this.chart || !this.dt ) return;

        var options = {
            legend : {
                position : 'none'
            }
        };

        if( this.options ) {
            for( var key in this.options ) {
                options[key] = this.options[key];
            }
        }

        this.chart.draw(this.dt, options);
    }
  });
</script>

<dom-module id="ecosis-isotope">
  <template>
    <style>
      :host {
        display : block
      }
    </style>

    <div id="grid">
      <content></content>
    </div>
  </template>


  <script>
    Polymer({
      is : 'ecosis-isotope',

      properties : {
        selector : {
          type : String,
          value : ''
        }
      },

      clear : function() {
        this.$.grid.innerHTML = '';
      },

      append : function(child) {
        this.$.grid.appendChild(child);
      },

      init : function() {
        if( this.grid ) this.grid.isotope('destroy');

        this.grid = $(this.$.grid).isotope({
          // options
          itemSelector: this.selector,
          layoutMode: 'vertical',
          getSortData: {
            name: '[data-name]', // value of attribute
            type: '[data-type]'
          },
          sortAscending: true,
          sortBy : 'name'
        });

        setTimeout(function(){
          this.grid.isotope('updateSortData').isotope();
        }.bind(this), 500)
      },

      html : function(html) {
        this.$.grid.innerHTML = html;
        this.init();
      },

      sort : function(sortBy) {
        this.grid.isotope({sortBy : sortBy});
      },

      filter : function(filter) {
        this.grid.isotope({filter : filter});
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-doi">
  <template>
    <style>
      :host {
        display: block;
      }
      #panel {
        margin-bottom: 40px;
      }
      .alert.alert-warning {
        margin-top: 15px
      }
    </style>

    <h4 class="page-header">
      <a class="btn-toggle" on-click="toggleCat"><i class="fa fa-arrow-right"></i></a> EcoSIS Dataset DOI
    </h4>
    
    <div id="panel" style="display:none">

      <div id="needsData" class="subpanel">
        <div class="text text-warning"><b>Warning:</b> Once a DOI is applied, you can only edit the metadata
          for this dataset.
        </div>
        
        <br>

        <div>To request a EcoSIS DOI you must enter the following metadata:</div>
        <table class="table" id="needsDataTable"></table>
      </div>

      <div class="subpanel" id="otherMessage"></div>

      <div id="request" class="subpanel">
        <div class="text text-warning"><b>Warning:</b> Once a DOI is applied, you will only be able to edit the metadata.  
          Make sure ALL data (file resources) are valid and complete before proceeding.
        </div>

        <a class="btn btn-default btn-request" on-click="requestDoi">Request Dataset Doi</a>
      </div>


      <div id="requesting" class="subpanel">
        Your doi has been approved and a request is being made for the DOI.
      </div>

      <div id="pendingApproval" class="subpanel">
        Your dataset is pending review by a EcoSIS administrator.  The DOI requester 
        <span id="requestedBy"></span> will be notified when the dataset is approved or if more information
        is required.
        <br>

         <div class="text text-warning">Warning: Once a DOI is applied, only be able to edit the metadata.
             Make sure ALL data is valid and complete before proceeding.
        </div>

        <a class="btn btn-warning btn-request" on-click="cancelRequest">Cancel Doi Request</a>
       
      </div>

      <div id="pendingRevision" class="subpanel">
        Your dataset has been reviewed by a EcoSIS administrator and further updates
        are required for a DOI.  If you are ready to re-submit your dataset, please click below.<br>

        <a class="btn btn-default btn-request" on-click="requestDoi">Resubmit Doi Request</a>
        <a class="btn btn-warning btn-request" on-click="cancelRequest">Cancel Doi Request</a>
        
        <div class="text text-warning"><b>Warning:</b> Once a DOI is applied, only be able to edit the metadata.    
        Make sure ALL data is filled out, valid and complete before proceeding.
        </div>
      </div>

      <div id="accepted" class="subpanel">
        Your dataset has been approved for a DOI.  The DOI is being generated and
        should be assigned shortly.
      </div>

      <div id="applied" class="subpanel">
        <div><b>Dataset DOI:</b> <span id="appliedLabel"></span></div>
        <div id="devMsg" style="display:none">This is NOT a real DOI.  Only datasets in 
        production system (<a href="http://data.ecosis.org">data.ecosis.org</a>) will be given actual DOI numbers.</div>
      </div>
    
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-doi',

      setData : function(pkg, pushed) {
        this.pkg = pkg;
        this.pushedToSearch = pushed;
        this.pkg.on('save-end', function(){
          if( this.doiUpdating ) {
            window.location.reload();
          } else {
            this.render();
          }
        }.bind(this));
        this.render();
      },
      
      requestDoi : function(e) {
         if( $(e.currentTarget).hasClass('disabled') ) {
           return;
         }
        
         this.doiUpdating = true;
         if( this.pkg.requestDoi() ) {
           $(this)
            .find('.btn-request')
            .addClass('disabled')
            .attr('disabled', 'disabled');
         } else {
           $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');
         }
      },
      
      cancelRequest : function(e) {
         if( $(e.currentTarget).hasClass('disabled') ) {
           return;
         }
        
         this.doiUpdating = true;
         if( this.pkg.cancelDoiRequest() ) {
           $(this)
            .find('.btn-request')
            .addClass('disabled')
            .attr('disabled', 'disabled');
         } else {
           $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');
         }
      },
      
      // re-render
      onGitInfoLoad : function() {
        this.render();
      },

      render : function() {
        if( !this.pkg ) return;
        
        var doi = this.pkg.getDoi();
        $(this).find('.subpanel').hide();
        
        if( ecosis.git && ecosis.git.branch !== 'master' ) {
          this.$.devMsg.style.display = 'block';
        }

        // cleanup request btns
        $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');

        if( !doi.status.value ) {
          this.verify();
          return;
        }

        if( doi.status.value === 'Pending Approval' ) {
          this.$.pendingApproval.style.display = 'block';
          this.$.requestedBy.innerHTML = doi.status ? doi.status.requested_by : '';
          return;
        }

        if( doi.status.value === 'Pending Revision' ) {
          this.$.pendingRevision.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Requesting' ) {
          this.$.requesting.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Accepted' ) {
          this.$.accepted.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Applied' ) {
          this.$.applied.style.display = 'block';
          this.$.appliedLabel.innerHTML = doi.value;
          return;
        }
      },

      verify : function() {
        this.$.needsData.style.display = 'none';

        if( ecosis.ds.package.getCitationDOI() ) {
          this.$.otherMessage.style.display = 'block';
          this.$.otherMessage.innerHTML = '<div class="text text-danger">Your dataset already has a DOI provided in the <b>Citation: Dataset DOI</b> field.</div>';
          return;
        }

        this.$.otherMessage.style.display = 'none';
        var html = '';

        var extras = ['Theme','Ecosystem Type','Acquisition Method'];
        var valid = {
          description : false,
          keywords : false,
          organization : false,
          public : false,
          author : false,
          'author email': false,
          maintainer : false,
          'maintainer email': false,
          'push to search': false
        };

        extras.forEach(function(e){
          if( this.pkg.getExtra(e) !== '' ) {
            valid[e] = true;
          } else {
            valid[e] = false;
          }
        }.bind(this));

        if( this.pkg.getDescription() !== '' ) {
          valid.description = true;
        }
        if( this.pkg.getKeywords().length > 0 ) {
          valid.keywords = true;
        }
        if( this.pkg.getOrganization() !== '' ) {
          valid.organization = true;
        }
        if( !this.pkg.isPrivate() ) {
          valid.public = true;
        }
        if( this.pkg.getAuthor() !== '' ) {
          valid.author = true;
        }
        if( this.pkg.getAuthorEmail() !== '' ) {
          valid['author email'] = true;
        }
        if( this.pkg.getMaintainer() !== '' ) {
          valid.maintainer = true;
        }
        if( this.pkg.getMaintainerEmail() !== '' ) {
          valid['maintainer email'] = true;
        }
        if( (this.pushedToSearch instanceof Date) === true ) {
          valid['push to search'] = true;
        }

        var canRequest = true;
        var c = 0;
        for( var key in valid ) {
          if( valid[key] === false ) {
            canRequest = false;
            html += this.addRow(key, false);
          } else {
            html += this.addRow(key, true);
          }

          c++;
          if( c % 2 === 0 ) {
            html += '</tr><tr>';
          }
        }

        this.$.needsDataTable.innerHTML = '<tr>'+html+'</tr>';

        this.updateRequestBtnVisibility(canRequest, html);
      },

      updateRequestBtnVisibility : function(canRequest, html) {
        if( canRequest ) {
          this.$.request.style.display = 'block';
        } else {
          this.$.needsData.style.display = 'block';
        }
      },

      addRow : function(key, value) {
        return '<td>'+
            '<i class="fa text fa-'+(value ? 'check text-success' : 'times text-danger')+'"></i>'+
          '</td><td style="text-transform:capitalize">'+
            key+
          '</td>';
      },
      
      toggleCat : function(e) {
        if( this.$.panel.style.display == 'none' ) {
          e.currentTarget.querySelector('i').className = 'fa fa-arrow-down';
          this.$.panel.classList.add('animated','fadeIn');
          this.$.panel.style.display = 'block';
          if( this.$.panel.onShow ) this.$[id].onShow();
        } else {
          e.currentTarget.querySelector('i').className = 'fa fa-arrow-right';
          this.$.panel.style.display = 'none';
        }
      },


    });
  </script>
</dom-module>

<dom-module id="ecosis-page-basic-info">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    .save-label {
        position: fixed;
        top: 65px;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    a {
      cursor: pointer;
    }
  </style>
  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>



    <div class="well" style="font-size: 14px; color: #888">
      <h5>Welcome <span id="usernameLabel"></span></h5>
      Fill out the basic information for your dataset.  Then you can add resource files such as metadata or spectra.<br>
      <b>First time adding data?</b>  Checkout the <a href="http://tutorial.ecosis.org/" target="_blank">screencast and tutorial.</a>
      <br><br>
      <div>
        <i class="fa fa-star" style="color:#2196f3"></i> = Recommented Input.  If you can't fill out everything, please try
        and at least fill out any starred field.
      </div>
    </div>

    <div id="createFromTemplate" style="display:none; text-align:right">
      <div>
        <a class="btn btn-link" on-click="toggleCreateFromTemplate"><i class="fa fa-magic"></i> Create From Template</a>
        <div class="help-block">Use template file from prior dataset to get started.</div>
      </div>
      <div id="createFromTemplatePanel" style="display:none">
        Select File: <input type="file" on-change="createFromTemplateInput" style="display:inline-block" id="createFromTemplateInput">
      </div>
      <div id="createTemplateSuccess" style="display:none"><span class="label label-success">Success!</span></div>
    </div>

    <h4 class="page-header">Basic Information <small cat="basic"></small></h4>
    <ecosis-title-input id="titleInput" on-update="updateCreateBtnState"></ecosis-title-input>

    <div class="form-horizontal">

      <!-- Description -->
      <div class="form-group">
        <label for="textArea" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Description</label>
        <div class="col-md-9">
          <textarea class="form-control" rows="3" id="descriptionInput" on-change="onDescriptionInputChange"></textarea>
        </div>
      </div>

      <ecosis-keyword-input id="keywordInput"></ecosis-keyword-input>

      <div class="form-group">
        <label for="licenseInput" class="col-md-2 control-label">License: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="licenseInput" on-change="onLicenseInputChange">
            <option>Loading...</option>
          </select>
        </div>
      </div>

      <div class="form-group">
        <label for="organizationInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Organization: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="organizationInput" on-change="onOrganizationInputChange">
            <option>Loading...</option>
          </select>

          <div class="help-block">
            To add datasets to an <a href="/organization" target="_blank">organization</a>, <a href="/dashboard/organizations" target="_blank">you</a>
            must be a member of the organization with a role of 'editor' or 'admin'.
          </div>
        </div>
      </div>

      <div class="form-group">
        <label for="visibilityInput" class="col-md-2 control-label">Visibility: </label>
        <div class="col-md-9">
          <select class="form-control" id="visibilityInput" disabled="" on-change="onVisibilityInputChange">
            <option value="false">Public</option>
            <option value="true">Private</option>
          </select>

          <div class="help-block" id="visibilityWarnLabel">
            You must select an organization if you wish to set the dataset to private, otherwise the dataset must be public.
          </div>
        </div>
      </div>

      <!-- Version -->
      <div class="form-group">
        <label for="versionInput" class="col-md-2 control-label">Version</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="versionInput" on-change="onVersionInputChange">
        </div>
      </div>

      <!-- Website -->
      <div class="form-group">
        <label for="websiteInput" class="col-md-2 control-label">Website</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="websiteInput" on-change="onWebsiteInputChange">
        </div>
      </div>

      <h4 class="page-header">
          <a class="btn-toggle" on-click="toggleCat" cat="themeInput">
          <i class="fa fa-arrow-right"></i></a> Theme <small cat="theme"></small>
      </h4>
      <ecosis-theme-input id="themeInput" style="display:none"></ecosis-theme-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="measureInput">
          <i class="fa fa-arrow-right"></i></a> Measurement <small cat="measurement"></small>
      </h4>
      <ecosis-measurement-input id="measureInput" style="display:none"></ecosis-measurement-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="processingInput">
        <i class="fa fa-arrow-right"></i></a> Processing Information <small cat="processing information"></small>
      </h4>
      <ecosis-processing-input id="processingInput" style="display:none"></ecosis-processing-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="instrumentInput">
          <i class="fa fa-arrow-right"></i></a> Instrument <small cat="instrument"></small>
      </h4>
      <ecosis-instrument-input id="instrumentInput" style="display:none"></ecosis-instrument-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="locationInput">
        <i class="fa fa-arrow-right"></i></a> Location <small cat="location"></small>
      </h4>
      <ecosis-location-input id="locationInput" style="display:none"></ecosis-location-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="linkedDataInput">
        <i class="fa fa-arrow-right"></i></a> Linked Resources &amp; Papers <small cat="linked"></small>
      </h4>
      <ecosis-linked-data-input id="linkedDataInput" style="display:none"></ecosis-linked-data-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="citationInput">
          <i class="fa fa-arrow-right"></i></a> Dataset Citation <small cat="citation"></small>
      </h4>
      <ecosis-citation-input id="citationInput" style="display:none"></ecosis-citation-input>

      <ecosis-doi id="doi" style="display:none"></ecosis-doi>

    </div>

    <!-- Create Dataset -->
    <a id="createDatasetBtn" class="btn btn-primary" style="display:none">Create Dataset</a>


    <div id="editModeFooter" style="display:none">
      Now <a href="#add-resources">add resources</a> to your dataset. <br>
    </div>

    <div class="layout horizontal" style="margin-top: 15px">
      <div class="flex">
        <a class="btn btn-primary" style="display:none" id="goToBtn" href="#add-resources"><i class="fa fa-plus"></i> Add Resources</a>
        <a class="btn btn-primary" style="display:none" id="goToListBtn" href="#current-resources"><i class="fa fa-list"></i> Current Resources</a>


        <a class="btn btn-primary" style="display:none" on-click="create" id="createBtn"><i class="fa fa-plus"></i> Create Dataset</a>

        <div id="helpCreatePanel" class="text text-warning" style="display:none">
          You must provide a valid dataset title to create.
        </div>
      </div>
      <div>
        <a class="btn btn-default" style="display:none" on-click="delete" id="deleteBtn"><i class="fa fa-trash"></i> Delete Dataset</a>
      </div>
    </div>

    <div class="well" style="margin-top: 30px">
      <div class="bugs" style="margin-top:20px">
        <i class="fa fa-bug"></i>  Found a bug?  Have an issue?  Let us know <a href="https://github.com/CSTARS/ckanext-ecosis/issues" target="_blank">here!</a>
      </div>

      <div class="gitInfo" id="gitInfo" style="display:none">
        <div><b>Branch:</b> <span id="gitBranchLabel"></span></div>
        <div><b>Version:</b> <span id="gitVersionLabel"></span></div>
        <div><b>Commit:</b> <span id="gitCommitLabel"></span></div>
      </div>
    </div>

    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-hidden="true"></button>
            <h4 class="modal-title">Welcome to the EcoSIS Data Importer!</h4>
          </div>
          <div class="modal-body" style="padding: 25px">
            <p>A quick note before you continue.</p>


            <p style="padding:30px 0" class="text text-success">
              Through EcoSIS you will be <b>publishing</b> your data to the world. In
              order to make datasets presentable and <b>searchable</b>, please give them clear
              <b>human-readable</b> titles and descriptions, and include as much
              dataset-level metadata as possible.  Include enough information so
              so a complete outsider can understand what the dataset is and is not.
            </p>

            <h5>tl;dr</h5>

            <ul>
              <li>Publish for others.</li>
              <li>Human-readable titles and descriptions.</li>
              <li>Fill out as much as you can.</li>
            </ul>

            <div class="help-block">
              Remember EcoSIS is what the <b>community</b> makes it to be.
            </div>

            <div style="text-align:center">
              <a class="btn btn-success btn-lg" data-dismiss="modal">Continue</a><a>
            </a></div><a>

          </a></div><a>
        </a></div><!-- /.modal-content --><a>
      </a></div><!-- /.modal-dialog --><a>
    </a></div><!-- /.modal --><a>

  </a></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-basic-info',

    ready : function() {
      this.updateTimer = -1;

      if( ecosis.user ) this.setUsername();
      else ecosis.on('user-load', this.setUsername.bind(this));

      if( ecosis.ds.editMode ) {
        this.setMode('edit');
        if( ecosis.ds.loaded ) this.onDataLoad();
        else ecosis.ds.on('load', this.onDataLoad.bind(this));
      } else {
        this.setMode('create');
        this.showCreatePopup();
      }

      this.updateScores();

      ecosis.ckan.getLicenseList(this.setLicenseList.bind(this));

      ecosis.ckan.gitInfo(function(resp){
        this.git = resp;

        if( !resp.error ) {
          ecosis.git = resp;
        }

        if( this.git.branch != 'master' ) {
          this.$.gitInfo.style.display = 'block';
          this.$.gitBranchLabel.innerHTML = this.git.branch;
          this.$.gitVersionLabel.innerHTML = this.git.version;
          this.$.gitCommitLabel.innerHTML = this.git.commit;
        }
        
        // HACK
        document.querySelector('ecosis-doi').onGitInfoLoad();
      }.bind(this));

      var fn = new ecosis.app.UiBuffer(this.updateScores, 100, this);
      ecosis.ds.on('load', fn);
      ecosis.ds.on('update', fn);
      ecosis.ds.package.on('save-start', this.saveStart.bind(this));
      ecosis.ds.package.on('save-end', this.saveEnd.bind(this));
    },

    showCreatePopup : function() {
      this.popup = $(this.$.popup).remove();
      $('body').append(this.popup);
      this.popup.modal({show:true});
    },

    setMode : function(mode) {
      this.mode = mode;
      if( mode == 'create' ) {
        this.$.createBtn.style.display = 'inline-block';
        this.$.createFromTemplate.style.display = 'block';
        this.updateCreateBtnState();

        if( ecosis.defaultGroup ) {
          this.$.organizationInput.value = ecosis.defaultGroup;
          this.onOrganizationInputChange();
        }
      } else {
        this.$.doi.style.display = 'block';
        this.$.goToBtn.style.display = 'inline-block';
        this.$.goToListBtn.style.display = 'inline-block';
        this.$.createFromTemplate.style.display = 'none';


        var status = ecosis.ds.package.getDoi().status;
        var hasDOI = false;
        if( status && status.value ) {
          if( status.value.toLowerCase() === 'applied' || status.value.toLowerCase() === 'pending approval' ) {
            hasDOI = true;
          }
        }

        this.$.deleteBtn.style.display = hasDOI ? 'none' : 'inline-block';
        this.$.goToBtn.style.display = hasDOI ? 'none' : 'inline-block';
      }
    },

    onDataLoad : function() {
      var pkg = ecosis.ds.package;

      this.$.descriptionInput.value = pkg.getDescription();
      this.$.keywordInput.setTokens(pkg.getKeywords());
      this.$.licenseInput.value = pkg.getLicenseId();
      this.$.organizationInput.value = pkg.getOrganization();
      this.$.visibilityInput.value = pkg.isPrivate() ? 'true' : 'false';
      this.$.versionInput.value = pkg.getVersion();
      this.$.websiteInput.value = pkg.getWebsite();
      this.$.linkedDataInput.setData(pkg.getLinkedData());
      this.$.doi.setData(pkg, ecosis.ds.lastPushed);
      this.updateVisibilityControl();
    },

    updateVisibilityControl : function() {
      if( !ecosis.ds.package.getOrganization() ) {
        this.$.visibilityInput.setAttribute('disabled', '');
        this.$.visibilityInput.value = 'false';
        ecosis.ds.package.setPrivate(false);
        this.$.visibilityWarnLabel.style.display = 'block';
      } else {
        this.$.visibilityInput.removeAttribute('disabled');
        this.$.visibilityWarnLabel.style.display = 'none';
        this.$.visibilityInput.value = ecosis.ds.package.isPrivate() ? 'true' : 'false';
      }
    },

    updateCreateBtnState : function() {
      if( this.mode === 'edit' ) return;

      if( this.$.titleInput.validName ) {
        this.$.createBtn.removeAttribute('disabled');
        this.$.helpCreatePanel.style.display = 'none';
      } else {
        this.$.createBtn.setAttribute('disabled', 'disabled');
        this.$.helpCreatePanel.style.display = 'block';
      }
    },

    setLicenseList : function(resp) {
      if( resp.error ) return console.log('Error loading licenses :(');

      this.licenses = resp;
      var options = '<option></option>';
      for( var i = 0; i < resp.length; i++ ) {
        var item = resp[i];
        options += '<option value="'+item.id+'">'+item.title+'</option>';
      }
      this.$.licenseInput.innerHTML = options;
    },

    setUsername : function() {
      if( !ecosis.user ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
        return;
      } else if( !ecosis.user.loggedIn ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
        return;
      }

      this.$.usernameLabel.innerHTML = ecosis.user.username;

      // set user orgs
      var options = '<option></option>';
      for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
        var org = ecosis.user.organizations[i];
        options += '<option value="'+org.id+'" '+(ecosis.defaultGroup === org.id ? 'selected' : '' )+'>'+org.display_name+'</option>';
      }
      this.$.organizationInput.innerHTML = options;
    },

    delete : function() {
      if( !confirm('Are you sure your want to remove this dataset?') ) return;
      if( !confirm('Are you REALLY sure your want to remove this dataset?!?') ) return;

      ecosis.ds.package.delete(function(resp) {
          if( resp.error ) {
            return ecosis.errorPopup.show(resp);
          }

          alert('dataset deleted.');
          window.location = '/dataset';
        }
      );
    },

    create : function() {
      if( this.$.createBtn.hasAttribute('disabled') ) return;

      this.$.createDatasetBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Creating...';
      this.$.createDatasetBtn.setAttribute('disabled', 'disabled');

      ecosis.ds.package.create(function(resp) {
        this.$.createDatasetBtn.innerHTML = '<i class="fa fa-plus"></i> Create Dataset';
        this.$.createDatasetBtn.removeAttribute('disabled');

        if( resp.error ) {
          return ecosis.errorPopup.show(resp);
        }

        // set the page
        window.location = '/import/?id='+resp.id+'#add-resources';
      }.bind(this));
    },

    updateScores : function() {
      var breakdown = ecosis.ds.getScore().breakdown;
      var $this = $(this);

      for( var key in breakdown ) {
        $this.find('small[cat="'+key+'"]').html(breakdown[key].score+'/'+breakdown[key].total);
      }
    },

    saveStart : function() {
      if( this.mode === 'create' ) return;
      this.$.saveLabel.style.display = 'block';
    },

    saveEnd : function(resp) {
      if( this.mode === 'create' ) return;
      this.$.saveLabel.style.display = 'none';

      if( resp.details && resp.details.doiApplied ) {
        return alert('You cannot update this dataset.  EcoSIS DOI has been applied');
      }

      if( resp.error ) {
        return ecosis.errorPopup.show(resp);
      }
      document.querySelector('ecosis-header').setBackBtn(resp.name);
    },

    /* change handlers */
    onOrganizationInputChange : function() {
      ecosis.ds.package.setOrganization(this.$.organizationInput.value, function(){
        this.updateVisibilityControl();
      }.bind(this));
    },

    onDescriptionInputChange : function() {
      ecosis.ds.package.setDescription(this.$.descriptionInput.value);
    },

    onLicenseInputChange : function() {
      var license_id = this.$.licenseInput.value;
      var license_title = '';

      for( var i = 0; i < this.licenses.length; i++ ) {
        if( this.licenses[i].id == ecosis.ds.package.getLicenseId() ) {
          license_title = this.licenses[i].title;
          break;
        }
      }

      ecosis.ds.package.setLicense(license_id, license_title);
    },

    onVisibilityInputChange : function() {
      ecosis.ds.package.setPrivate(this.$.visibilityInput.value == 'true' ? true : false);

      // push to search needs to know
      this.fire('visibility-change');
    },

    onVersionInputChange : function() {
      ecosis.ds.package.setVersion(this.$.versionInput.value);
    },

    onWebsiteInputChange : function() {
      ecosis.ds.package.setWebsite(this.$.websiteInput.value);
    },

    onLinkedDataChange : function() {
      ecosis.ds.package.setLinkedData(this.$.linkedDataInput.getData());
    },

    toggleCat : function(e) {
      var id = e.currentTarget.getAttribute('cat');

      if( this.$[id].style.display == 'none' ) {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-down';
        this.$[id].className = 'animated fadeIn';
        this.$[id].style.display = 'block';
        if( this.$[id].onShow ) this.$[id].onShow();
      } else {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-right';
        this.$[id].style.display = 'none';
      }
    },

    toggleCreateFromTemplate : function() {
      $(this.$.createFromTemplatePanel).toggle('slow');
    },

    createFromTemplateInput : function(e) {
      try {
        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        if( files.length == 0 ) return;

        var reader = new FileReader();
        var contents, parts;

        reader.onload = function(e) {
          try {
            var data = JSON.parse(e.target.result);
            ecosis.ds.loadFromTemplate(data);
            this.onDataLoad();
            this.$.createTemplateSuccess.style.display = 'block';
            this.toggleCreateFromTemplate();
            this.$.createFromTemplateInput.value = '';

            setTimeout(function(){
              this.$.createTemplateSuccess.style.display = 'none';
            }.bind(this), 5000);
          } catch(e) {
            this.$.createFromTemplateInput.value = '';
            alert('Error reading template file');
          }
        }.bind(this);
        reader.readAsText(files[0]);

      } catch(e) {
        this.$.createFromTemplateInput.value = '';
        alert('Error reading template file');
      }
    }

  })
</script>

<dom-module id="ecosis-page-current-resources">
  <style>
    :host {
      display : block;
      padding: 0 5%;
    }
    #legend {
      padding: 20px 0;
    }
    #filterPopup {
      display : none;
      position: absolute;
      right : 25px;
      margin: 10px 15px 15px 15px;
      padding: 15px;
      background-color: white;
      box-shadow: 0 0 5px #ccc;
      z-index: 100;
      font-size: 16px;
    }
  </style>

  <template>

    <h4 class="page-header">
      <span>Current Resources</span>

      <div class="pull-right" style="margin-top: -10px">
        <div class="btn-group">
          <a class="btn btn-default active" on-click="toggleSortName" id="sortName">Sort by Name</a>
          <a class="btn btn-default" on-click="toggleSortType" id="sortType">Sort by Type</a>
        </div>

        <div class="btn btn-default" on-click="toggleFilter">Filter</div>
        <div id="filterPopup">
          <button type="button" class="close" aria-label="Close" on-click="toggleFilter"><span aria-hidden="true"></span></button>
          <h5 class="page-header" style="margin-top:5px">Show</h5>

          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="success">
              <span class="text text-success">Data Sheet</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="primary">
              <span class="text text-primary">Metadata Sheet</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="zip">
              <span class="text text-warning">Zip Package</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="info">
              <span class="text text-info">Multi-Sheet File</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="default">
              <span class="text text-default">Ignored</span>
            </label>
          </div>
        </div>
      </div>
    </h4>

    <div id="removeAll" style="margin-bottom: 20px">
      <a class="btn btn-link" on-click="selectAll">Select All</a>
      <a class="btn btn-link" on-click="unselectAll">Unselect All</a>

      <a class="btn btn-danger pull-right" id="deleteAll" on-click="deleteAll" style="display:none">Delete All Selected</a>
    </div>
    <ecosis-isotope id="resourceRoot" selector=".data-item"></ecosis-isotope>

    <div id="noResources" style="display:none">
      Your dataset does not contain any resource files.  Click <a id="addLink">here</a> to upload resources.
    </div>

    <div id="legend">
      <div style="float:right">
        Click the <i class="fa fa-pencil"></i> icon to inspect or edit a resource.
      </div>

      <h6 style="margin-bottom:0">Resource List Legend</h6>
      <span class="label label-success">Data Sheet</span>
      <span class="label label-primary">Metadata Sheet</span>
      <span class="label label-warning">Zip Package</span>
      <span class="label label-info">Multi-Sheet File</span>
      <span class="label label-default">Ignored</span>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-current-resources',

    ready : function() {
      if( ecosis.ds.loaded ) this.render();
      else ecosis.ds.on('load', this.render.bind(this));

      this.$.addLink.setAttribute('href', '#add-resources');
    },

    onShow : function() {
      this.render();
    },

    render : function() {
      this.checkDoiStatus();

      if( ecosis.ds.resources.length == 0 ) {
        this.$.noResources.style.display = 'block';
        this.$.legend.style.display = 'none';
        this.$.removeAll.style.display = 'none';
        return;
      } else {
        this.$.noResources.style.display = 'none';
        this.$.legend.style.display = 'block';
        if( !this.hasDOI ) {
          this.$.removeAll.style.display = 'block';
        }
      }

      var html = '';


      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        if( resource.fromZip ) continue;

        html += '<ecosis-resource-panel resourceid="'+resource.id+'" '+(this.hasDOI ? 'has-doi' : '')+' style="width:100%" class="data-item"></ecosis-resource-panel>';
      }

      this.$.resourceRoot.html(html);

      // listen for all update events
      $(this.$.resourceRoot)
        .find('ecosis-resource-panel')
        .on('update', this.onResourceUpdate.bind(this))
        .on('resource-select', this.onResourceSelect.bind(this));


      this.$.resourceRoot.init();
    },

    checkDoiStatus : function() {
      var status = ecosis.ds.package.getDoi().status;
      if( status && status.value ) {
        if( status.value.toLowerCase() === 'applied' || status.value.toLowerCase() === 'pending approval') {
          this.hasDOI = true;
          this.$.removeAll.style.display = 'none';
        }
      }
    },

    toggleFilter : function() {
      $(this.$.filterPopup).toggle();
    },

    toggleSortName : function() {
      $(this.$.sortName).addClass('active');
      $(this.$.sortType).removeClass('active');
      this.sort('name');
    },

    toggleSortType : function() {
      $(this.$.sortName).removeClass('active');
      $(this.$.sortType).addClass('active');
      this.sort(['type','name']);
    },

    sort : function(sortValue) {
      this.$.resourceRoot.sort(sortValue);
      var zips = this.querySelectorAll('ecosis-resource-panel.data-item[data-type="zip"]');
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].sort(sortValue);
      }
    },

    filter : function() {
      var filters = this.querySelectorAll('.filter');
      var filter = [];
      for( var i = 0; i < filters.length; i++ ) {
        if( !$(filters[i]).prop('checked') ) continue;
        filter.push('[data-type="'+filters[i].getAttribute('data-type')+'"]');
      }

      filter = filter.join(', ');

      // empty filter breaks isotope
      if( filter == '' ) filter = '*';

      var zips = this.querySelectorAll('ecosis-resource-panel.data-item[data-type="zip"]');
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].filter(filter);
      }

      this.$.resourceRoot.filter(filter);

      // make sure everything is correct
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].filter(filter);
      }

      this.$.resourceRoot.filter(filter);
    },

    // make sure all resource panel css classes are correct
    verifyPanelCss : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        eles[i].setClass();
      }
    },

    onResourceSelect : function() {
      this.updateSelectState();
    },

    deleteAll : function() {
      if( !confirm('Are you sure you want to delete all selected resources?') ) return;

      var eles = this.querySelectorAll('ecosis-resource-panel');
      var ids = [], usedEles = [];
      for( var i = 0; i < eles.length; i++ ) {
        if( !eles[i].isSelected() || eles[i].resource.fromZip ) continue;
        eles[i].querySelector('#deletePanel').style.display = 'inline-block';
        ids.push(eles[i].resource.id);
        usedEles.push(eles[i]);
      }

      ecosis.ckan.deleteResources(ids, function(resp){
        if( resp.error ) {
          // ERROR 11
          resp.code = 11;
          return ecosis.errorPopup.show(resp);
        }

        for( var i = 0; i < usedEles.length; i++ ) {
          $(usedEles[i]).remove();
        }

        for( var i = ecosis.ds.resources.length - 1; i >= 0; i-- ) {
          if( ids.indexOf(ecosis.ds.resources[i].id) > -1 ) {
            ecosis.ds.resources.splice(i, 1);
          }
        }

        ecosis.ds.fireUpdate();

        ecosis.ds.deleteResourceTime = new Date();
        ecosis.ds.checkChanges();

        if( ecosis.ds.resources.length == 0 ) {
          this.$.noResources.style.display = 'block';
          this.$.legend.style.display = 'none';
          this.$.removeAll.style.display = 'none';
        }

        this.$.deleteAll.style.display = 'none';
      }.bind(this));
    },

    selectAll : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        if( eles[i].style.display === 'none' ) continue;
        eles[i].select(true);
      }
      this.updateSelectState();
    },

    unselectAll : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) eles[i].select(false);
      this.updateSelectState();
    },

    updateSelectState : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        if( eles[i].isSelected() ) {
          this.$.deleteAll.style.display = 'block';
          return;
        }
      }
      this.$.deleteAll.style.display = 'none';
    },

    onResourceUpdate : function(e) {
      var id = e.originalEvent.detail;

      var panels = this.$.resourceRoot.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < panels.length; i++ ) {
        if( panels[i].edit && panels[i].resourceid != id ) {
          var panel = panels[i]
          // hide resource
          panel.toggleEdit();
          // clear cached 'full' datasheet
          if( panel.$.datasheetUI ) {
            panel.$.datasheetUI.datasheet = null;
          }
        }
      }

      if( ecosis.ds.resources.length == 0 ) {
        this.$.noResources.style.display = 'block';
        this.$.legend.style.display = 'none';
        this.$.removeAll.style.display = 'none';
      }

    }


  });
</script>

<dom-module id="ecosis-page-add-resource">
  <style>
    :host {
      display: block;
      padding: 0 5% 50px 5%;
    }
    #dropZone {
        border: 2px dashed #bbb;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        border-radius: 5px;
        padding: 25px;
        font-size: 20pt;
        color: #bbb;
        background-color: white;
        margin: 15px 0 0 0;
    }
  </style>

  <template>
    <h4 class="page-header">Add Resources</h4>

    <h5 style="margin-bottom: 0">Select files to be uploaded</h5>
    <div style="font-size:12px;color:#888; margin-bottom: 30px">
        <span>Add new files below by using the file selector or drag files over the drop zone.</span>
    </div>

    <div class="well well-sm">

      <div class="form-horizontal">
        <div class="form-group">
          <label class="col-md-3 control-label">
              Default Orientation<br>
              <a on-click="toggleHelp" style="cursor: pointer">What is this?</a>
          </label>

          <div class="col-md-7">
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="columnInput" value="column" checked="" on-click="onRadioChange">
                My observations are by column.
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="rowInput" value="row" on-click="onRadioChange">
                My observations are by row.
              </label>
            </div>
          </div>
        </div>
      </div>

      <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>

    </div>
    <!-- end well -->

    <div id="processing" style="display: none">
        <h4 class="alert alert-success">
          <div><i class="fa fa-spin fa-circle-o-notch"></i> Uploading &amp; Processing Files...</div>
          <div style="font-size:12px">This may take a couple minutes, depending on the size of your upload.</div>
        </h4>
        <div id="uploadStatusTable"></div>
    </div>

    <div class="fileinput" id="fileInputPanel">
        <div>
            <input type="file" style="margin:30px 0 0 15px" id="file" name="file" multiple="" on-change="handleFileSelect">
            <!--<input type="file" style="display:none" id="addFileTesting" name="addFileTesting" multiple="" /> -->
        </div>

        <div class="file-select-group">
            <div id="dropZone"><b>OR</b> drag and drop files here</div>
        </div>
    </div>

    <div id="completePanel" style="display:none; margin-top:20px;">
      <a id="completePanelLink" class="btn btn-primary animated fadeInDownBig"><i class="fa fa-list"></i> Open resource list</a>
    </div>

    <div style="margin-top: 40px">
      <a on-click="toggleInfoPanel" style="cursor:pointer">Supported file types and the Ecosis Metadata Editor</a>
    </div>
    <div id="infoPanel" style="display:none" class="animated fadeIn">
        <h6 class="page-header">Supported File Types</h6>
        <div class="well well-sm">
            <div>Currently the following tabular file types will be parsed.</div>
            <ul>
                <li>.xls</li>
                <li>.xlsx</li>
                <li>.csv</li>
                <li>.tsv (Tab Separated Value)</li>
                <li>.spectra (parsed as .tsv)</li>
                <li>.zip<span class="green">*</span></li>
            </ul>
            <div><span class="green">*</span>Zip files will be extracted on the server.
              Any files contained within the zip file that have supported extension will be parsed.</div>
            <div>Other file extensions are accepted but will not be parsed.</div>
        </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-add-resource',

    ready : function() {
      this.$.dropZone.addEventListener('dragover', this.handleDragOver.bind(this), false);
      this.$.dropZone.addEventListener('drop', this.handleFileSelect.bind(this), false);

      this.staggedFiles = [];
      this.newResourceIds = [];

      this.defaultType = 'column';
      this.$.formatHelp.setType('column');

      this.$.completePanelLink.setAttribute('href', '#current-resources');
    },

    onRadioChange : function() {
      if( $(this.$.columnInput).is(':checked') ) {
        this.$.formatHelp.setType('column');
        this.defaultType = 'column';
      } else {
        this.$.formatHelp.setType('row');
        this.defaultType = 'row';
      }
    },

    handleDragOver : function (evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    },

    handleFileSelect : function(evt) {
      evt.stopPropagation();
      evt.preventDefault();

      this.setProcessing(true);

      var files = evt.dataTransfer ? evt.dataTransfer.files : evt.target.files; // FileList object.

      this.staggedFiles = [];
      this.newResourceIds = [];

      for( var i = 0; i < files.length; i++ ) {
          this.staggedFiles.push({
              file : files[i],
              name : files[i].name,
              aborted : false,
              xhr : null,
              progress : 0,
              type : this.defaultType,
              speed : '0Mbps'
          });
      }

      this.renderUploadStatusTable();
      this.uploadFiles(this.defaultType, 0);
    },

    setProcessing : function(processing) {
      if( processing ) {
        this.$.fileInputPanel.style.display = 'none';
        this.$.processing.style.display = 'block';
      } else {
        this.$.fileInputPanel.style.display = 'block';
        this.$.processing.style.display = 'none';
      }
    },

    onUploadComplete : function() {
      if( this.newResourceIds.length == 0 ) {
        this.onProcessingComplete();
        return;
      }

      ecosis.ckan.processResource(
          ecosis.ds.package_id, this.newResourceIds, null, {layout: this.defaultType},
          function(resp) {
              if( resp.error ) {
                // ERROR 3
                resp.code = 3;
                return ecosis.errorPopup.show(resp);
              }

              // proly a smarter way to do things, but for now, reload entire workspace
              ecosis.ckan.getWorkspace(ecosis.ds.package_id, function(result){
                if( result.error ) {
                  // ERROR 4
                  result.code = 4;
                  return ecosis.errorPopup.show(result);
                }

                ecosis.ds.runAfterResourceAdd(result);
                this.onProcessingComplete();
                this.fire('resource-add');
                this.showUploadWizard();
              }.bind(this));
          }.bind(this)
      )
    },

    showUploadWizard : function() {
      var resources = [];
      for( var i = 0; i < this.newResourceIds.length; i++ ) {
        var resource = ecosis.ds.resourceLookup[this.newResourceIds[i]];
        if( !resource.datasheets ) continue;

        if( resource.childResources ) {
          for( var j = 0; j < resource.childResources.length; j++ ) {
            if( !resource.childResources[j].datasheets ) continue;
            if( resource.datasheets.length == 1 && resource.datasheets[0].invalidFileType ) continue;

            resources.push(resource.childResources[j]);
          }
        } else if ( resource.datasheets.length == 1 && resource.datasheets[0].invalidFileType ) {
          continue;
        } else {
          resources.push(resource);
        }
      }

      document.querySelector('ecosis-upload-splash').show(resources,{
        onDatasheetUpdate : function(){
          // make sure all panels have correct css after update
          document.querySelector('ecosis-page-current-resources').verifyPanelCss();
        }
      });
    },

    onProcessingComplete : function() {
      this.$.file.value = '';
      this.setProcessing(false);

      this.$.completePanel.style.display = 'block';
    },

    uploadFiles : function(type, index) {
        if( this.staggedFiles.length <= index ) {
            // now tell server to parse resources with given type
            this.onUploadComplete();
            return;
        }

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.aborted ) {
            index++;
            this._uploadFiles(type, index);
            return;
        }


        var file = this.staggedFiles[index].file;
        var reader = new FileReader();

        reader.onload = function(e) {
            staggedFile.xhr = ecosis.ckan.addResource(
                ecosis.ds.package_id,
                {
                    contents : e.target.result,
                    mimetype : file.type,
                    filename : file.name
                },
                function(resp) {
                    if( resp.error ) console.log('Error adding resource: '+file.name);

                    // save this, when we are done, we will set default parse type
                    this.newResourceIds.push(resp.id);

                    index++
                    this.uploadFiles(type, index);
                }.bind(this),
                function(progress, speed) {
                    this.staggedFiles[index].speed = speed;
                    this.staggedFiles[index].progress = progress;
                    this.updateStatusText(index);
                }.bind(this)
            );
        }.bind(this);
        reader.readAsArrayBuffer(file);
    },

    abort : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        e.currentTarget.style.display = 'none';

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.progress == 100 ) return;

        staggedFile.aborted = true;

        this.updateStatusText(index);

        if( staggedFile.xhr ) {
            staggedFile.xhr.abort();
            index++;
            this._uploadFiles(this.defaultType, index);
        }
    },

    toggleHelp : function() {
        $(this.$.formatHelp).toggle();
    },

    toggleInfoPanel : function() {
      if( this.$.infoPanel.style.display == 'none') {
        $(this.$.infoPanel).show();
        $(window).scrollTop(254);
      } else {
        $(this.$.infoPanel).hide();
      }
    },

    renderUploadStatusTable : function() {
      var table = '<table class="table" style="text-align: left">';

      for( var i = 0; i < this.staggedFiles.length; i++ ) {
        var file = this.staggedFiles[i];
        var status = this.getFileStatus(file);

        table +=
          '<tr>'+
            '<td><b>'+file.name+'</b></td>'+
            '<td style="color:#888" index="'+i+'">'+status.message+'</td>'+
            '<td>'+
              '<a class="btn btn-default" index="'+i+'" '+(status.code == 2 ? 'style="display:none"' : '')+'>Abort</a>'+
            '</td>'+
          '</tr>'
      }
      table += '</table>';

      this.$.uploadStatusTable.innerHTML = table;

      $(this.$.uploadStatusTable)
        .find('a')
        .on('click', this.abort.bind(this));
    },

    getFileStatus : function(file) {
      if( file.progress != 100 && !file.aborted ) {
        return {code: 1, message: 'Uploading: '+file.progress+'% @ '+file.speed};
      } else if ( file.progress == 100 && !file.aborted ) {
        return {code: 2, message : 'Upload Complete. Processing...'};
      } else if( file.aborted ) {
        return {code: -1, message: '<span class="label label-danger">Aborted</span>'};
      }

      return '';
    },

    updateStatusText : function(index) {
      var td = this.$.uploadStatusTable.querySelector('td[index="'+index+'"]');
      if( td ) {
        var status = this.getFileStatus(this.staggedFiles[index]);
        td.innerHTML = status.message;
        if( status.code == 2 ) {
          var btn = this.$.uploadStatusTable.querySelector('a[index="'+index+'"]');
          btn.style.display = 'none';
        }
      }
    }


  });
</script>

<dom-module id="ecosis-attribute-mapping">
  <style>
    :host {
      display: block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    table.table th {
      border : none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div style="padding: 15px">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h3 class="panel-title">Map your spectra metadata names to EcoSIS names</h3>
        </div>
        <div class="panel-body">
          <h5 class="page-header" style="margin-top:0">By File</h5>

          <div class="horizontal layout">
              <div class="flex">
                  <a class="btn btn-default" target="_blank" id="mapTemplate">Download Alias Template</a>
              </div>
              <div class="flex">
                  Upload Template: <input type="file" style="margin-top:5px" id="map" name="map" on-change="processMap">

                  <span class="label label-success" id="mapSuccessLabel" style="display:none">Success!</span>
              </div>
          </div>
          <div class="help-block">
            Use this to bulk upload and set the attribute name aliases.  This is aliases template file can be
            reused across your datasets.  NOTE:  This will overwrite all current aliases.
          </div>

          <h5 class="page-header">Individually</h5>
          <div class="help-block">
            Use this to add individual spectra metadata aliases.
          </div>

          <table class="table">
            <tbody><tr>
              <th>EcoSIS</th>
              <th></th>
              <th id="dsTitleLabel"></th>
              <th></th>
            </tr>
            <tr>
              <td>
                <select id="newEcosis" class="form-control"></select>
              </td>
              <td>
                <i class="fa fa-arrow-right"></i>
              </td>
              <td>
                <select id="newCustom" class="form-control"></select>
              </td>
              <td>
                <a class="btn btn-primary" on-click="add" style="margin: 5px"><i class="fa fa-plus"></i> Add</a>
              </td>
            </tr>
          </tbody></table>

          <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
  			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>

        </div>
      </div>

      <div class="panel panel-primary" id="currentPanel">
        <div class="panel-heading">
          <h3 class="panel-title">Current Aliases</h3>
        </div>
        <div class="panel-body" id="currentMapRoot"></div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-attribute-mapping',

    ready : function() {
      ecosis.ds.on('load', function(){
        this.$.dsTitleLabel.innerHTML = ecosis.ds.package.getTitle();
        this.updateSelectList();
        this.updateMap();
      }.bind(this));
    },

    onShow : function() {
      this.updateSelectList();
      this.updateMap();
      this.$.mapTemplate.setAttribute('href', ecosis.ckan.host+'/ecosis/package/getTemplate?mapOnly=true&id='+ecosis.ds.package_id);
    },

    setTopMapping : function(panel) {
      this.topPanel = panel;
    },

    processMap : function(e) {
      try {
        e.stopPropagation();
        e.preventDefault();

        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        if( files.length == 0 ) return;

        var reader = new FileReader();
        var contents, parts;

        reader.onload = function(e) {
          try {
            var data = JSON.parse(e.target.result);
            if( data.map ) {
              data.aliases = data.map;
            }

            var newAliases = {};
            for( var key in data.aliases ) {
              if( data.aliases[key] ) {
                newAliases[key] = data.aliases[key];
              }
            }

            ecosis.ds.package.setAliases(newAliases);
            ecosis.ds.updateAliasLookup();
            this.updateSelectList();
            this.updateMap();

            this.$.map.value = '';

            this.$.mapSuccessLabel.style.display = 'inline-block';
            setTimeout(function(){
              this.$.mapSuccessLabel.style.display = 'none';
            }.bind(this), 5000);
          } catch(e) {
            this.$.map.value = '';
            alert('Error loading attribute map');
          }
        }.bind(this);

        reader.readAsText(files[0]);
      } catch(e) {
        this.$.map.value = '';
        alert('Error loading attribute map');
      }
    },

    addFromSuggest : function(custom, trait) {
      var aliases = ecosis.ds.package.getAliases();
      aliases[trait] = custom;

      ecosis.ds.package.setAliases(aliases);
      ecosis.ds.updateAliasLookup();
      this.updateMap();
      this.updateSelectList();
    },

    updateMap : function() {
      var c = 0, item = {};
      var map = ecosis.ds.attributeMap;
      this.attrMapList = [];

      for( var key in map ) {
          if( map[key] && map[key].length > 0 ) {
              this.attrMapList.push({
                  ecosis : key,
                  custom : map[key]
              });
          } else {
              delete map[key]
          }
      }

      this.attrMapList.sort(function(a, b){
          if( a.ecosis > b.ecosis ) return 1;
          if( a.ecosis < b.ecosis ) return -1;
          return 0;
      });

      this.renderCurrentList();
    },

    updateSelectList : function() {
      this.selectList = [];
      this.customList = [];

      var html = '<optgroup><option></option></optgroup>';

      for( var key in ecosis.ds.metadataDefinitions ) {
          html += '<optgroup label="'+key+'">';

          var attrs = ecosis.ds.metadataDefinitions[key];

          for( var i = 0; i < attrs.length; i++ ) {
              if( !ecosis.ds.attributeMap[attrs[i].name] ) {
                  html += '<option value="'+attrs[i].name+'">'+attrs[i].name+'</option>'
              }
          }
          html += '</optgroup>';
      }

      this.$.newEcosis.innerHTML = html;


      var attrs = {}, sheet;
      if( ecosis.ds.datasheets ) {
        for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
          sheet = ecosis.ds.datasheets[i];
          for( var j = 0; j < sheet.attributes.length; j++ ) {
            attrs[sheet.attributes[j]] = 1;
          }
        }
      }

      attrs = Object.keys(attrs);

      for( var i = 0; i < attrs.length; i++ ) {
          if( ecosis.ds.attributeMap[attrs[i]] ) continue;
          this.customList.push(attrs[i]);
      }

      this.customList.sort(function(a, b){
          if( a.toLowerCase() > b.toLowerCase() ) return 1;
          if( a.toLowerCase() < b.toLowerCase() ) return -1;
          return 0;
      });

      html = '<option></option>';
      for( var i = 0; i < this.customList.length; i++ ) {
        html += '<option value="'+this.customList[i]+'">'+this.customList[i]+'</option>'
      }
      this.$.newCustom.innerHTML = html;

      if( this.topPanel ) {
        this.topPanel.update(this.customList);
      }
    },

    renderCurrentList : function() {
      if( Object.keys(ecosis.ds.attributeMap).length == 0 ) {
        this.$.currentMapRoot.innerHTML = 'No attributes currently mapped';
        return;
      }

      var table =
        '<table class="table">'+
          '<tr>'+
              '<th>EcoSIS</th>'+
              '<th>'+ecosis.ds.package.getTitle()+'</th>'+
              '<th>Remove</th>'+
          '</tr>';

      for( var i = 0; i < this.attrMapList.length; i++ ) {
        var item = this.attrMapList[i];
        table += '<tr>'+
              '<td>'+item.ecosis+'</td>'+
              '<td>'+item.custom+'</td>'+
              '<td><a class="btn btn-default" attribute="'+item.custom+'"><i class="fa fa-trash"></i></a></td>'+
          '</tr>';
      }
      table += '</table>';

      this.$.currentMapRoot.innerHTML = table;

      $(this.$.currentMapRoot)
        .find('a.btn')
        .on('click', this.remove.bind(this));

    },

    remove : function(e) {
      var custom = e.currentTarget.getAttribute('attribute');
      var ecosisAttr = ecosis.ds.inverseAttributeMap[custom];

      if( !confirm('Are you sure you want to remove the mapping: '+ecosisAttr+' = '+custom+'?') ) return;

      delete ecosis.ds.attributeMap[ecosisAttr];
      delete ecosis.ds.inverseAttributeMap[custom];

      this.save(ecosis.ds.attributeMap);
    },

    add : function() {
      var ecosisAttr = this.$.newEcosis.value;
      var custom = this.$.newCustom.value;

      if( ecosisAttr.length == 0 || custom.length == 0 ) return alert('Please select both attributes to map first');

      ecosis.ds.attributeMap[ecosisAttr] = custom;
      ecosis.ds.inverseAttributeMap[custom] = ecosisAttr;

      this.$.newEcosis.value = '';
      this.$.newCustom.value = '';

      this.save(ecosis.ds.attributeMap);
    },

    updateAttrMapList : function(newMap) {
      this.attrMapList = [];

      var c = 0, item = {};
      var map = newMap || this.map;

      if( newMap ) {
          ecosis.ds.attributeMap = newMap;
          ecosis.ds.inverseAttributeMap = {};

          for( var key in newMap ) {
              if( newMap[key] != '' ) ecosis.ds.inverseAttributeMap[newMap[key]] = key;
          }
      }

      this.save(newMap);
    },

    save : function(newMap) {
      this.$.saveLabel.style.display = 'block';

      var options = {
        map : newMap
      };

      ecosis.ds.package.setAliases(newMap);
      ecosis.ds.updateAliasLookup();

      this.updateMap();
      this.updateSelectList();
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }

  })
</script>

<dom-module id="ecosis-top-mapping">
  <template>
    <style>
      .card {
        margin: 15px 10px;
        padding: 10px;
        box-shadow: 0 0 5px #ccc;
      }
    </style>

    <div style="padding: 15px">
      <div class="panel panel-primary" id="root">
        <div class="panel-heading">
          <h3 class="panel-title">Standardize Your Plant Trait Names</h3>
        </div>
        <div class="panel-body">
          <div class="help-block">Use standard names when providing plant trait information.  Below,
            <span id="countLabel"></span> of your spectra metadata attribute names have suggested standard trait names.
            Now many of your spectra metadata attributes may not be traits, but for those that are, please
            try and set aliases to an appropriate, standardized name.
          </div>

          <div class="layout horizontal center">
            <div>
              <a class="btn btn-default" style="margin-right: 30px"><i class="fa fa-arrow-left"></i></a>
            </div>
            <div class="flex">
              <select class="form-control" id="selector" on-change="suggest"></select>
            </div>
            <div>
              <a class="btn btn-default" style="margin-left: 30px"><i class="fa fa-arrow-right"></i></a>
            </div>
          </div>

          <h5 id="suggestLabel" style="display:none; margin-top: 30px">Suggestions</h5>

          <template is="dom-repeat" items="{{suggestions}}">
            <div class="card">
              <h4 class="page-header" style="margin:0">
                <span>{{item.preferredLabel}}</span>
                <small>{{item.subClassOfClean}}</small>
                <a class="btn btn-primary pull-right" on-click="onSelect" index$="{{index}}">Select</a>
              </h4>

              <div style="margin-bottom: 20px">{{item.definition.value}}</div>
              <div class="help-block"><b>Reference</b>: <span>{{item.definition.reference.value}}</span></div>

              <div hidden$="{{!item.prefUnit.value}}"><b>Units:</b> <span>{{item.prefUnit.value}}</span></div>
              <div hidden$="{{!item.alternativeLabel}}"><b>Alt Label:</b> <span>{{item.alternativeLabel}}</span></div>
              <div hidden$="{{!item.relatedTermClean}}"><b>Related:</b> <span>{{item.relatedTermClean}}</span></div>
              <div hidden$="{{!item.abbrivation}}"><b>Abbrivation:</b> <span>{{item.abbrivation}}</span></div>
              <div><b>TOP Link:</b> <a href$="{{item.link}}" target="_blank">More Info</a></div>
            </div>
          </template>

          <div style="text-align: right; margin-top: 30px">
            Powered By: <a href="http://top-thesaurus.org/" target="_blank">TOP Thesaurus</a>
          </div>
        </div>
      </div>

      <div style="text-align:center" id="allGoodMessage" class="well">
        We have no suggestions at this time for your spectra metadata attribute names.
      </div>

      <div style="text-align:center">
        Looking for the complete list of standard plant trait names?  Please visit the <a href="http://top-thesaurus.org/" target="_blank">TOP Thesaurus</a>.
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-top-mapping',

      attached : function() {
        this.suggestions = [];
        document.querySelector('ecosis-attribute-mapping').setTopMapping(this);
      },

      update : function(list) {
        for( var i = list.length-1; i > 0; i-- ) {
          if( ecosis.ds.inverseAttributeMap[list[i]] ) {
            list.splice(i, 1);
          }
        }

        var str = list.join('');
        if( this.current === str ) return;

        this.current = str;

        ecosis.ckan.topSuggestOverview(list, function(resp){
          this.badList = [];
          for( var key in resp ) {
            if( resp[key].type !== 'match' && resp[key].type !== 'nomatch' ) {
              this.badList.push(key);
            }
          }

          if( this.badList.length === 0 ) {
            this.$.root.style.display = 'none';
            this.$.allGoodMessage.style.display = 'block';
            return;
          }

          this.$.allGoodMessage.style.display = 'none';
          this.$.root.style.display = 'block';

          this.render();
        }.bind(this));
      },

      render : function() {
        this.$.countLabel.innerHTML = this.badList.length;

        var html = '<option></option>';
        for( var i = 0; i < this.badList.length; i++ ) {
          html += '<option value="'+this.badList[i]+'">'+this.badList[i]+'</option>';
        }

        this.$.selector.innerHTML = html;
        this.suggest();
      },

      suggest : function() {
        this.selected = this.$.selector.value;

        if( this.selected === '' ) {
          this.suggestions = [];
          this.$.suggestLabel.style.display = 'none';
          return;
        }

        this.$.suggestLabel.style.display = 'block';

        ecosis.ckan.topSuggest(this.selected.replace(/(-|_)/g, ' '), function(resp){
          for( var i = 0; i < resp.result.length; i++ ) {
            var item = resp.result[i];
            item.subClassOfClean = item.subClassOf ? item.subClassOf.replace(/_/g, ' ') : '';

            item.relatedTermClean = '';
            if( item.relatedTerm ) {
              if( Array.isArray(item.relatedTerm) ) {
                for( var j = 0; j < item.relatedTerm.length; j++ ) {
                  item.relatedTerm[j] = item.relatedTerm[j].trim();
                }
                item.relatedTermClean = item.relatedTerm.join(', ');
              } else {
                item.relatedTerm = item.relatedTerm.trim();
              }

            }

            item.link = 'http://top-thesaurus.org/annotationInfo?viz=1&&trait='+item.label;
          }

          this.suggestions = resp.result;
        }.bind(this));
      },

      onSelect : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        document.querySelector('ecosis-attribute-mapping').addFromSuggest(this.selected, this.suggestions[index].preferredLabel);
        this.suggestions = [];

        index = this.badList.indexOf(this.selected);
        if( index > -1 ) {
          this.badList.splice(index, 1);
        }
        this.render();
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-dataset-order">
  <style>
    :host {
      display : block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div>
      <div>
          Is this a time series dataset or a dataset that has any other form of ordering?
          If so, select the attribute to order by as well as the type of sort that should
          be performed.  You can also provide a textual description of what this ordering is.
      </div>

      <div class="form-horizontal">
        <div class="form-group">
          <label for="orderByInput" class="col-md-2 control-label"><b>Order By:</b></label>
          <div class="col-md-10">
            <select id="orderByInput" class="form-control" on-change="onChange"></select>
          </div>
        </div>

        <div class="form-group" style="display:none" id="secondaryPanel">
          <label for="orderTypeInput" class="col-md-2 control-label">Order Type</label>
          <div class="col-md-10">

            <select id="orderTypeInput" class="form-control" on-change="onChange">
                <option value="string">Default (String)</option>
                <option value="datetime">Date</option>
                <option value="numeric">Numeric</option>
            </select>

            <div class="help-block" id="dateHelp" style="display:none">
                Use <a href="http://www.w3.org/TR/NOTE-datetime" target="_blank">ISO-8601</a>
                for which the format is: YYYY-MM-DDTHH:mm:ss.sssZ.
                <a href="http://xkcd.com/1179/" target="_blank">Why?</a>
            </div>


            <input type="text" id="descriptionInput" class="form-control" on-change="onChange" placeholder="Description">

          </div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataset-order',

    ready : function() {
      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {
      this.attributeArray = [];

      var attrs = {}, sheet;
      if( ecosis.ds.datasheets ) {
        for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
          sheet = ecosis.ds.datasheets[i];
          for( var j = 0; j < sheet.attributes.length; j++ ) {
            attrs[sheet.attributes[j]] = 1;
          }
        }
      }

      attrs = Object.keys(attrs);

      for( var i = 0; i < attrs.length; i++ ) {
          if( ecosis.ds.attributeMap[attrs[i]] ) continue;
          this.attributeArray.push(attrs[i]);
      }

      this.attributeArray.sort(function(a, b){
          if( a > b ) return 1;
          if( a < b ) return -1;
          return 0;
      });

      var options = '<option></option>';
      for( var i = 0; i < this.attributeArray.length; i++ ) {
        options += '<option value="'+this.attributeArray[i]+'">'+this.attributeArray[i]+'</option>';
      }

      this.$.orderByInput.innerHTML = options;

      var sort = ecosis.ds.package.getSort();
      if( Object.keys(sort) === 0 ) return;

      var sort_description = sort.description || '';
      var sort_type = sort.type || '';
      var sort_on = sort.on || '';

      this.$.orderByInput.value = sort_on;
      this.$.orderTypeInput.value = sort_type;
      this.$.descriptionInput.value = sort_description;

      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }
    },

    onChange : function() {
      var sort_on = this.$.orderByInput.value;
      var sort_type = this.$.orderTypeInput.value;

      var sort = {
        on : sort_on,
        type : sort_type,
        description : this.$.descriptionInput.value || ''
      }

      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }

      ecosis.ds.package.setSort(sort);
    }
  });
</script>
<dom-module id="ecosis-page-advanced">
  <style>
    :host {
      display: block;
      margin-top: 20px;
      padding: 0 5%;
    }
  </style>

  <template>

    <ul id="tabs" class="nav nav-tabs nav-justified">
      <li class="active">
        <a href="#alias" data-toggle="tab">Aliases</a>
      </li>
      <li>
        <a href="#traits" data-toggle="tab">Plant Traits</a>
      </li>
      <li>
        <a href="#template" data-toggle="tab">Template</a>
      </li>
      <li>
        <a href="#ordering" data-toggle="tab">Ordering</a>
      </li>
    </ul>

    <div id="tabContent" class="tab-content">
      <div class="tab-pane fade active in" id="alias">
        <h4 class="page-header">Dataset Attribute Alias Names</h4>
        <ecosis-attribute-mapping id="mapping"></ecosis-attribute-mapping>
      </div>

      <div class="tab-pane fade" id="traits">
        <ecosis-top-mapping></ecosis-top-mapping>
      </div>

      <div class="tab-pane fade" id="template">
        <h4 class="page-header">Dataset Template</h4>
        <div>Download a dataset template file for this dataset.  You can use this
          JSON formatted template file to help speed up the creation of new datasets like this one.
        </div>
        <div style="padding: 15px">
          <a class="btn btn-primary" id="datasetTemplate" target="_blank">Download Dataset Template</a>
        </div>
      </div>

      <div class="tab-pane fade" id="ordering">
        <h4 class="page-header">Dataset Ordering</h4>
        <ecosis-dataset-order style="margin-bottom: 50px" id="order"></ecosis-dataset-order>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-advanced',

    ready : function() {
      $(this.$.tabs).find('a').click(function (e) {
        e.preventDefault()
        $(this).tab('show')
      });
    },

    onShow : function() {
      this.$.mapping.onShow();
      this.$.order.onShow();
      this.$.datasetTemplate.setAttribute('href', ecosis.ckan.host+'/ecosis/package/getTemplate?id='+ecosis.ds.package_id);
    }
  })
</script>

<dom-module id="ecosis-page-push">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    #main {
      margin-bottom: 50px;
    }
  </style>

  <template>
    <h4 class="page-header">Publish to Search</h4>


		<div class="alert alert-danger" style="display:none" id="privateAlertPanel">
			You have marked this dataset as private. Your results cannot be published to PUBLIC search.
		</div>

		<div id="main">
			<div class="help-block">
				Please verify all information looks correct.  Once everything looks correct, click 'Publish'
        below and your changes will be represented at
        <a href="http://ecosis.org" target="_blank">ecosis.org</a>.
         Please note, a minimum of 3 EcoSIS metadata attributes are required to push your dataset.
			</div>

			<div class="well">
				<h4>Basic Information</h4>
				<table class="table">
					<tbody><tr><td>Title</td><td id="title"></td></tr>
					<tr><td>Name</td><td id="name"></td></tr>
					<tr><td>Description</td><td id="notes"></td></tr>
					<tr><td>Organization</td><td id="owner_org_name"></td></tr>
					<tr><td>Visibility</td><td>Public</td></tr>
          <tr><td>Search Status</td><td id="available"></td></tr>
				</tbody></table>
			</div>

			<div style="margin-bottom: 35px">
				<h4 class="page-header">Spectra Preview</h4>

        <ecosis-sheet-preview id="preview"></ecosis-sheet-preview>
			</div>

			<div class="well">
				<h4>EcoSIS Metadata Information</h4>
				<div id="ecosisInfo"></div>


        <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>
      </div>

      <div style="padding: 15px 0">
        <a class="btn btn-primary btn-lg" id="pushBtn" on-click="push"><i class="fa fa-check-circle-o"></i> Publish</a>
      </div>

      <div style="padding: 15px 0">
        <div class="checkbox">
          <label>
            <input type="checkbox" id="responseEmailInput" checked="checked"> Email me when the dataset is available in search.
            <div class="help-block">Datasets can take several minutes to show up in search.  We can send you and email when
              the dataset is ready.
            </div>
          </label>
        </div>
      </div>


      <div class="help-block" id="pushMessage" style="display:none">Queuing push to search...</div>
		</div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-push',

    ready : function() {
      this.requireEcosisAttrs = 3;
      this.warnEcosisAttrs = 8;

      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {

      if( ecosis.ds.package.isPrivate() ) {
        this.$.privateAlertPanel.style.display = 'block';
        this.$.main.style.display = 'none';
      } else {
        this.$.privateAlertPanel.style.display = 'none';
        this.$.main.style.display = 'block';

        this.updateLabels();
        this.updateCounts();
        this.$.preview.update({
          packageId: ecosis.ds.package_id,
          layout : 'column'
        }, true);
      }
    },

    updateLabels : function() {
      for( var key in ecosis.ds.package.data ) {
        if( key == 'owner_org' ) {
          for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
            if( ecosis.user.organizations[i].id == ecosis.ds.package.getOrganization() ) {
              this.$.owner_org_name.innerHTML = ecosis.user.organizations[i].display_name;
              break;
            }
          }

        } else if( this.$[key] ) {
          this.$[key].innerHTML = ecosis.ds.package.data[key];
        }
      }

      if( ecosis.ds.result && ecosis.ds.lastPushed ) {
        var resp = ecosis.ds.checkChanges();

        var last = '<br />Last Published: '+resp.lastPushed.toLocaleString();
        if( resp.unpublishedChanges ) {
          last += '<br />Last Updated: '+resp.lastUpdated.toLocaleString();
          last = '<span class="label label-warning">Updated since last publish</span> ' + last + '<br />' +
                '<div class="text text-warning">Please review your dataset, then click <b>Publish</b> below to make your changes available in search</div>';
        } else {
          last = '<span class="label label-success">Published to search</span> ' + last;
        }

        this.$.available.innerHTML = last;
      } else {
        this.$.available.innerHTML = '<span class="label label-warning">Not Published</span>' +
                            '<div class="text text-warning">This dataset is not available is search.  Click <b>Publish</b> below to publish the dataset to search when the dataset is ready.</div>';

      }
    },

    updateCounts : function() {
			this.updatePushStatus();
		},

		updatePushStatus : function() {
			var count = ecosis.ds.getScore().score;

			if( count < this.requireEcosisAttrs ) {
				this.$.pushBtn.style.display = 'none';
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-danger" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.requireEcosisAttrs + ' are required to publish to search.' +
					'</span>';
				return;
			}

			this.$.pushBtn.style.display = 'inline-block';
			if( count < this.warnEcosisAttrs ) {
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-warning" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.warnEcosisAttrs + ' are recommended.' +
					'</span>';
				return;
			}

			this.$.ecosisInfo.innerHTML =
				'<span class="label label-success" style="font-size:14px">' +
					'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
				'</span>';

		},

    push : function() {
      this.$.pushBtn.setAttribute('disabled', '');
      this.$.pushBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Queuing...';
      this.$.pushMessage.style.display = 'block';

      var includeEmail = $(this.$.responseEmailInput).is(':checked');

      ecosis.ckan.pushToSearch(ecosis.ds.package_id, includeEmail,
          function(resp){
            this.$.pushBtn.removeAttribute('disabled');
            this.$.pushBtn.innerHTML = '<i class="fa fa-check-circle-o"></i> Publish';
            this.$.pushMessage.style.display = 'none';

            if( resp.error ) {
              // ERROR 12
              resp.code = 12;
              resp.message += '. Error publishing dataset.';
              return ecosis.errorPopup.show(resp);
            }

            var msg = 'Success.  Your dataset is processing.';
            if( resp.emailing && resp.email ) {
              msg += '  You will be emailed at '+resp.email+' when the dataset is ready.';
            } else {
              msg += '  Please give some time for your dataset to show in search.  No email will be sent.';
            }

            alert(msg);
            window.location = ecosis.ckan.host + '/dataset/' + ecosis.ds.package_id;
          }.bind(this)
      );
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }
  })
</script>
</div></body></html>