<html><head><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
window.Polymer = {
Settings: function () {
var user = window.Polymer || {};
location.search.slice(1).split('&').forEach(function (o) {
o = o.split('=');
o[0] && (user[o[0]] = o[1] || true);
});
var wantShadow = user.dom === 'shadow';
var hasShadow = Boolean(Element.prototype.createShadowRoot);
var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
var useShadow = wantShadow && hasShadow;
var hasNativeImports = Boolean('import' in document.createElement('link'));
var useNativeImports = hasNativeImports;
var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
return {
wantShadow: wantShadow,
hasShadow: hasShadow,
nativeShadow: nativeShadow,
useShadow: useShadow,
useNativeShadow: useShadow && nativeShadow,
useNativeImports: useNativeImports,
useNativeCustomElements: useNativeCustomElements
};
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
var factory = desugar(prototype);
prototype = factory.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return factory;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
window.Polymer = Polymer;
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});
Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
this._callbacks.forEach(function (cb) {
cb();
});
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._desugarBehaviors();
this._doBehavior('beforeRegister');
this._registerFeatures();
this._doBehavior('registered');
},
createdCallback: function () {
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
attachedCallback: function () {
Polymer.RenderStatus.whenReady(function () {
this.isAttached = true;
this._doBehavior('attached');
}.bind(this));
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name) {
this._attributeChangedImpl(name);
this._doBehavior('attributeChanged', arguments);
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (prototype, api) {
if (prototype && api) {
Object.getOwnPropertyNames(api).forEach(function (n) {
this.copyOwnProperty(n, api, prototype);
}, this);
}
return prototype || api;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.extend(DomModule.prototype, {
constructor: DomModule,
createdCallback: function () {
this.register();
},
register: function (id) {
var id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDocumentUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDocumentUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument;
if (doc) {
CustomElements.upgradeAll(doc);
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
this._mixinBehavior(behaviors[i]);
}
return behaviors;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
behaviors.forEach(function (b) {
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}, this);
return flat;
},
_mixinBehavior: function (b) {
Object.getOwnPropertyNames(b).forEach(function (n) {
switch (n) {
case 'hostAttributes':
case 'registered':
case 'properties':
case 'observers':
case 'listeners':
case 'created':
case 'attached':
case 'detached':
case 'attributeChanged':
case 'configure':
case 'ready':
break;
default:
if (!this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
break;
}
}, this);
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_doBehavior: function (name, args) {
this.behaviors.forEach(function (b) {
this._invokeBehavior(b, name, args);
}, this);
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
this.behaviors.forEach(function (b) {
this._marshalBehavior(b);
}, this);
this._marshalBehavior(this);
}
});
Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
this.behaviors.some(function (b) {
return info = this._getPropertyInfo(property, b.properties);
}, this);
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
}
});
Polymer.CaseMap = {
_caseMap: {},
dashToCamelCase: function (dash) {
var mapped = Polymer.CaseMap._caseMap[dash];
if (mapped) {
return mapped;
}
if (dash.indexOf('-') < 0) {
return Polymer.CaseMap._caseMap[dash] = dash;
}
return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
return m[1].toUpperCase();
});
},
camelToDashCase: function (camel) {
var mapped = Polymer.CaseMap._caseMap[camel];
if (mapped) {
return mapped;
}
return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
return g[0] + '-' + g[1].toLowerCase();
});
}
};
Polymer.Base._addFeature({
_prepAttributes: function () {
this._aggregatedAttributes = {};
},
_addHostAttributes: function (attributes) {
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
this._applyAttributes(this, this._aggregatedAttributes);
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
this.serializeValueToAttribute(attr$[n], n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
for (var i = 0, l = this.attributes.length; i < l; i++) {
this._setAttributeToProperty(model, this.attributes[i].name);
}
},
_setAttributeToProperty: function (model, attrName) {
if (!this._serializing) {
var propName = Polymer.CaseMap.dashToCamelCase(attrName);
var info = this.getPropertyInfo(propName);
if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
var val = this.getAttribute(attrName);
model[propName] = this.deserialize(val, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (name) {
this._serializing = true;
this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value !== null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value;
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return debouncer && debouncer.finish;
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.version = '1.1.5';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
}
});</script>



<script>Polymer.Base._addFeature({
_prepTemplate: function () {
this._template = this._template || Polymer.DomModule.import(this.is, 'template');
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && HTMLTemplateElement.bootstrap) {
HTMLTemplateElement.decorate(this._template);
HTMLTemplateElement.bootstrap(this._template.content);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_pushHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._beginHost();
},
_beginHost: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_popHost: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
this._setupRoot();
this._readyClients();
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
this._finishDistribute();
this._clientsReadied = true;
this._clients = null;
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.EventApi = function () {
var Settings = Polymer.Settings;
var EventApi = function (event) {
this.event = event;
};
if (Settings.useShadow) {
EventApi.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
return this.event.path;
}
};
} else {
EventApi.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var o = this.rootTarget;
while (o) {
path.push(o);
o = Polymer.dom(o).parentNode || o.host;
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new EventApi(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
c$ = composed ? node._composedChildren : c$;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
var nativeAppendChild = Element.prototype.appendChild;
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
var DomApi = function (node) {
this.node = node;
if (this.patch) {
this.patch();
}
};
if (window.wrap && Settings.useShadow && !Settings.useNativeShadow) {
DomApi = function (node) {
this.node = wrap(node);
if (this.patch) {
this.patch();
}
};
}
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this._addNode(node);
},
insertBefore: function (node, ref_node) {
return this._addNode(node, ref_node);
},
_addNode: function (node, ref_node) {
this._removeNodeFromHost(node, true);
var addedInsertionPoint;
var root = this.getOwnerRoot();
if (root) {
addedInsertionPoint = this._maybeAddInsertionPoint(node, this.node);
}
if (this._nodeHasLogicalChildren(this.node)) {
if (ref_node) {
var children = this.childNodes;
var index = children.indexOf(ref_node);
if (index < 0) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
}
this._addLogicalInfo(node, this.node, index);
}
this._addNodeToHost(node);
if (!this._maybeDistribute(node, this.node) && !this._tryRemoveUndistributedNode(node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node, ref_node);
if (ref_node) {
nativeInsertBefore.call(container, node, ref_node);
} else {
nativeAppendChild.call(container, node);
}
}
if (addedInsertionPoint) {
this._updateInsertionPoints(root.host);
}
return node;
},
removeChild: function (node) {
if (factory(node).parentNode !== this.node) {
console.warn('The node to be removed is not a child of this node', node);
}
this._removeNodeFromHost(node);
if (!this._maybeDistribute(node, this.node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (container === node.parentNode) {
removeFromComposedParent(container, node);
nativeRemoveChild.call(container, node);
}
}
return node;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
if (node._ownerShadyRoot === undefined) {
var root;
if (node._isShadyRoot) {
root = node;
} else {
var parent = Polymer.dom(node).parentNode;
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
node._ownerShadyRoot = root;
}
return node._ownerShadyRoot;
},
_maybeDistribute: function (node, parent) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this._ownerShadyRootForNode(parent);
if (root) {
var host = root.host;
this._lazyDistribute(host);
}
}
var parentNeedsDist = this._parentNeedsDistribution(parent);
if (parentNeedsDist) {
this._lazyDistribute(parent);
}
return parentNeedsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = factory(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = factory(n).parentNode;
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
saveLightChildrenIfNeeded(parent);
saveLightChildrenIfNeeded(node);
added = true;
}
return added;
},
_tryRemoveUndistributedNode: function (node) {
if (this.node.shadyRoot) {
var parent = getComposedParent(node);
if (parent) {
nativeRemoveChild.call(parent, node);
}
return true;
}
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
saveLightChildrenIfNeeded(c);
saveLightChildrenIfNeeded(factory(c).parentNode);
}
},
_nodeHasLogicalChildren: function (node) {
return Boolean(node._lightChildren !== undefined);
},
_parentNeedsDistribution: function (parent) {
return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
},
_removeNodeFromHost: function (node, ensureComposedRemoval) {
var hostNeedsDist;
var root;
var parent = node._lightParent;
if (parent) {
factory(node)._distributeParent();
root = this._ownerShadyRootForNode(node);
if (root) {
root.host._elementRemove(node);
hostNeedsDist = this._removeDistributedChildren(root, node);
}
this._removeLogicalInfo(node, node._lightParent);
}
this._removeOwnerShadyRoot(node);
if (root && hostNeedsDist) {
this._updateInsertionPoints(root.host);
this._lazyDistribute(root.host);
} else if (ensureComposedRemoval) {
removeFromComposedParent(getComposedParent(node), node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = factory(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = node.parentNode;
if (parent) {
removeFromComposedParent(parent, node);
nativeRemoveChild.call(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = factory(node).parentNode;
}
},
_addNodeToHost: function (node) {
var root = this.getOwnerRoot();
if (root) {
root.host._elementAdd(node);
}
},
_addLogicalInfo: function (node, container, index) {
var children = factory(container).childNodes;
index = index === undefined ? children.length : index;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
children.splice(index++, 0, n);
n._lightParent = container;
}
} else {
children.splice(index, 0, node);
node._lightParent = container;
}
},
_removeLogicalInfo: function (node, container) {
var children = factory(container).childNodes;
var index = children.indexOf(node);
if (index < 0 || container !== node._lightParent) {
throw Error('The node to be removed is not a child of this node');
}
children.splice(index, 1);
node._lightParent = null;
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = factory(node).childNodes;
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = factory(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = factory(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
return this.querySelectorAll(selector)[0];
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return matchesSelector.call(n, selector);
}, this.node);
},
_query: function (matcher, node) {
node = node || this.node;
var list = [];
this._queryElements(factory(node).childNodes, matcher, list);
return list;
},
_queryElements: function (elements, matcher, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
this._queryElement(c, matcher, list);
}
}
},
_queryElement: function (node, matcher, list) {
if (matcher(node)) {
list.push(node);
}
this._queryElements(factory(node).childNodes, matcher, list);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
queryDistributedElements: function (selector) {
var c$ = this.childNodes;
var list = [];
this._distributedFilter(selector, c$, list);
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
this._distributedFilter(selector, factory(c).getDistributedNodes(), list);
}
}
return list;
},
_distributedFilter: function (selector, list, results) {
results = results || [];
for (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {
if (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {
results.push(d);
}
}
return results;
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._distributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._distributeParent();
},
_distributeParent: function () {
if (this._parentNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = factory(externalNode).childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
}
};
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
if (!Settings.useShadow) {
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
var c$ = getLightChildren(this.node);
return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
configurable: true
},
parentNode: {
get: function () {
return this.node._lightParent || getComposedParent(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return this.childNodes[0];
},
configurable: true
},
lastChild: {
get: function () {
var c$ = this.childNodes;
return c$[c$.length - 1];
},
configurable: true
},
nextSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
firstElementChild: {
get: function () {
return this.children[0];
},
configurable: true
},
lastElementChild: {
get: function () {
var c$ = this.children;
return c$[c$.length - 1];
},
configurable: true
},
nextElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = Array.prototype.slice.call(d.childNodes);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.prototype._getComposedInnerHTML = function () {
return getInnerHTML(this.node, true);
};
} else {
var forwardMethods = [
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild'
];
forwardMethods.forEach(function (name) {
DomApi.prototype[name] = function () {
return this.node[name].apply(this.node, arguments);
};
});
DomApi.prototype.querySelectorAll = function (selector) {
return Array.prototype.slice.call(this.node.querySelectorAll(selector));
};
DomApi.prototype.getOwnerRoot = function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
};
DomApi.prototype.importNode = function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
};
DomApi.prototype.getDestinationInsertionPoints = function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype.getDistributedNodes = function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype._distributeParent = function () {
};
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
return Array.prototype.slice.call(this.node.childNodes);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.slice.call(this.node.children);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardProperties = [
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
];
forwardProperties.forEach(function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
});
}
var CONTENT = 'content';
var factory = function (node, patch) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi(node, patch);
}
return node.__domApi;
};
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return factory(obj, patch);
}
};
Polymer.Base.extend(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_finishDebouncer: null,
flush: function () {
for (var i = 0; i < this._debouncers.length; i++) {
this._debouncers[i].complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._flushPolyfills();
if (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
this._flushGuard++;
this.flush();
} else {
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
this._flushGuard = 0;
}
},
_flushPolyfills: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});
function getLightChildren(node) {
var children = node._lightChildren;
return children ? children : node.childNodes;
}
function getComposedChildren(node) {
if (!node._composedChildren) {
node._composedChildren = Array.prototype.slice.call(node.childNodes);
}
return node._composedChildren;
}
function addToComposedParent(parent, node, ref_node) {
var children = getComposedChildren(parent);
var i = ref_node ? children.indexOf(ref_node) : -1;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var fragChildren = getComposedChildren(node);
for (var j = 0; j < fragChildren.length; j++) {
addNodeToComposedChildren(fragChildren[j], parent, children, i + j);
}
node._composedChildren = null;
} else {
addNodeToComposedChildren(node, parent, children, i);
}
}
function getComposedParent(node) {
return node.__patched ? node._composedParent : node.parentNode;
}
function addNodeToComposedChildren(node, parent, children, i) {
node._composedParent = parent;
children.splice(i >= 0 ? i : children.length, 0, node);
}
function removeFromComposedParent(parent, node) {
node._composedParent = null;
if (parent) {
var children = getComposedChildren(parent);
var i = children.indexOf(node);
if (i >= 0) {
children.splice(i, 1);
}
}
}
function saveLightChildrenIfNeeded(node) {
if (!node._lightChildren) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
child._lightParent = child._lightParent || node;
}
node._lightChildren = c$;
}
}
function hasInsertionPoint(root) {
return Boolean(root && root._insertionPoints.length);
}
var p = Element.prototype;
var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return {
getLightChildren: getLightChildren,
getComposedParent: getComposedParent,
getComposedChildren: getComposedChildren,
removeFromComposedParent: removeFromComposedParent,
saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
matchesSelector: matchesSelector,
hasInsertionPoint: hasInsertionPoint,
ctor: DomApi,
factory: factory
};
}();
(function () {
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_poolContent: function () {
if (this._useContent) {
saveLightChildrenIfNeeded(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLightChildren(this._lightChildren);
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
saveLightChildrenIfNeeded(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
saveLightChildrenIfNeeded(c);
saveLightChildrenIfNeeded(c.parentNode);
}
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
var dom = Polymer.dom(this);
if (updateInsertionPoints) {
dom._updateInsertionPoints(this);
}
var host = getTopDistributingHost(this);
dom._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
} else {
if (!this.shadyRoot._hasDistributed) {
this.textContent = '';
this._composedChildren = null;
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = getLightChildren(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = p._lightParent || p.parentNode;
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = getLightChildren(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = getComposedChildren(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (getComposedParent(n) === container) {
remove(n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (var j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
ensureComposedParent(container, children);
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
var getLightChildren = Polymer.DomApi.getLightChildren;
var matchesSelector = Polymer.DomApi.matchesSelector;
var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
var getComposedChildren = Polymer.DomApi.getComposedChildren;
var getComposedParent = Polymer.DomApi.getComposedParent;
var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = content._lightParent;
if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
function insertBefore(parentNode, newChild, refChild) {
var newChildParent = getComposedParent(newChild);
if (newChildParent !== parentNode) {
removeFromComposedParent(newChildParent, newChild);
}
remove(newChild);
nativeInsertBefore.call(parentNode, newChild, refChild || null);
newChild._composedParent = parentNode;
}
function remove(node) {
var parentNode = getComposedParent(node);
if (parentNode) {
node._composedParent = null;
nativeRemoveChild.call(parentNode, node);
}
}
function ensureComposedParent(parent, children) {
for (var i = 0, n; i < children.length; i++) {
children[i]._composedParent = parent;
}
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = Polymer.dom(host).children;
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName === 'content') {
return host.domHost;
}
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLightChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>



<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list);
return list;
},
_parseNodeAnnotations: function (node, list) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
},
_testEscape: function (value) {
var escape = value.slice(0, 2);
if (escape === '{{' || escape === '[[') {
return escape;
}
},
_parseTextNodeAnnotation: function (node, list) {
var v = node.textContent;
var escape = this._testEscape(v);
if (escape) {
node.textContent = ' ';
var annote = {
bindings: [{
kind: 'text',
mode: escape[0],
value: v.slice(2, -2).trim()
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, callback) {
if (root.firstChild) {
for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = node.nextSibling;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
root.removeChild(n);
n = n.nextSibling;
}
}
var childAnnotation = this._parseNodeAnnotations(node, list, callback);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
for (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {
var n = a.name, v = a.value;
if (n === 'id' && !this._testEscape(v)) {
annotation.id = v;
} else if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else {
var b = this._parseNodeAttributeAnnotation(node, n, v);
if (b) {
annotation.bindings.push(b);
}
}
}
},
_parseNodeAttributeAnnotation: function (node, n, v) {
var escape = this._testEscape(v);
if (escape) {
var customEvent;
var name = n;
var mode = escape[0];
v = v.slice(2, -2).trim();
var not = false;
if (v[0] == '!') {
v = v.substring(1);
not = true;
}
var kind = 'property';
if (n[n.length - 1] == '$') {
name = n.slice(0, -1);
kind = 'attribute';
}
var notifyEvent, colon;
if (mode == '{' && (colon = v.indexOf('::')) > 0) {
notifyEvent = v.substring(colon + 2);
v = v.substring(0, colon);
customEvent = true;
}
if (node.localName == 'input' && n == 'value') {
node.setAttribute(n, '');
}
node.removeAttribute(n);
if (kind === 'property') {
name = Polymer.CaseMap.dashToCamelCase(name);
}
return {
kind: kind,
mode: mode,
name: name,
value: v,
negate: not,
event: notifyEvent,
customEvent: customEvent
};
}
},
_localSubTree: function (node, host) {
return node === host ? node.childNodes : node._lightChildren || node.childNodes;
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
}
};
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && url[0] === '#') {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
Polymer.Annotations.prepElement = this._prepElement.bind(this);
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
}
this._processAnnotations(this._notes);
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
b.signature = this._parseMethod(b.value);
if (!b.signature) {
b.model = this._modelForPath(b.value);
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
mode: '{',
name: '_parent_' + prop,
model: prop,
value: prop
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
notes.forEach(function (n) {
n.bindings.forEach(function (b) {
if (b.signature) {
var args = b.signature.args;
for (var k = 0; k < args.length; k++) {
pp[args[k].model] = true;
}
} else {
pp[b.model] = true;
}
});
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
});
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
this._configureTemplateContent();
},
_configureTemplateContent: function () {
this._notes.forEach(function (note, i) {
if (note.templateContent) {
this._nodes[i]._content = note.templateContent;
}
}, this);
},
_marshalIdNodes: function () {
this.$ = {};
this._notes.forEach(function (a) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}, this);
},
_marshalAnnotatedNodes: function () {
if (this._nodes) {
this._nodes = this._nodes.map(function (a) {
return this._findAnnotatedNode(this.root, a);
}, this);
}
},
_marshalAnnotatedListeners: function () {
this._notes.forEach(function (a) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
a.events.forEach(function (e) {
this.listen(node, e.name, e.value);
}, this);
}
}, this);
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, key;
for (key in listeners) {
if (key.indexOf('.') < 0) {
node = this;
name = key;
} else {
name = key.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[key]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (IS_TOUCH_ONLY) {
return;
}
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = ev.currentTarget;
var gobj = node[GESTURE_KEY];
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1) {
if (r.reset) {
r.reset();
}
}
}
}
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var se = detail.sourceEvent;
if (se && se.preventDefault) {
se.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: function () {
},
upfn: function () {
}
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
fire: function (type, target, event) {
var self = this;
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
prevent: Gestures.prevent.bind(Gestures)
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: function () {
},
upfn: function () {
},
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
Gestures.prevent('tap');
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
Gestures.prevent('tap');
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new (window.MutationObserver || JsMutationObserver)(Polymer.Async._atEndOfMicrotask.bind(Polymer.Async)).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
this.boundComplete = this.complete.bind(this);
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
var detail = detail === null || detail === undefined ? Polymer.nob : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var event = new CustomEvent(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable,
detail: detail
});
node.dispatchEvent(event);
return event;
},
async: function (callback, waitTime) {
return Polymer.Async.run(callback.bind(this), waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this.get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
if (onload) {
l.onload = onload.bind(this);
}
if (onerror) {
l.onerror = onerror.bind(this);
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
Polymer.Bind = {
prepareModel: function (model) {
model._propertyEffects = {};
model._bindListeners = [];
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (property) {
var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
Polymer.Base.fire(eventName, { value: this[property] }, {
bubbles: false,
node: this
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
effects.forEach(function (fx) {
var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
if (fn) {
fn.call(this, property, value, fx.effect, old, fromAbove);
}
}, this);
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
fx.push({
kind: kind,
effect: effect
});
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'computedAnnotation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event) {
var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, bogusTest) {
return function (e, target) {
if (!bogusTest(e, target)) {
if (e.detail && e.detail.path) {
this.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
} else {
var value = target[property];
if (!isStructured) {
this[path] = target[property];
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
inst._bindListeners.forEach(function (info) {
var node = inst._nodes[info.index];
node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
});
}
};
Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this.get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(calc, effect);
}
},
_reflectEffect: function (source) {
this.reflectPropertyToAttribute(source);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var fn = this[effect.method];
if (fn) {
this.__setProperty(effect.property, fn.apply(this, args));
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(computedvalue, effect);
}
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base.get(name, model);
} else {
v = model[name];
}
if (args.length > 1 && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
Polymer.Bind.addPropertyEffect(this, property, kind, effect);
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify');
}
if (prop.reflectToAttribute) {
this._addPropertyEffect(p, 'reflect');
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
property: name
});
}, this);
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
observers.forEach(function (observer) {
this._addComplexObserverEffect(observer);
}, this);
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg
});
}, this);
},
_addAnnotationEffects: function (notes) {
this._nodes = [];
notes.forEach(function (note) {
var index = this._nodes.push(note) - 1;
note.bindings.forEach(function (binding) {
this._addAnnotationEffect(binding, index);
}, this);
}, this);
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);
}
if (note.signature) {
this._addAnnotatedComputationEffect(note, index);
} else {
note.index = index;
this._addPropertyEffect(note.model, 'annotation', note);
}
},
_addAnnotatedComputationEffect: function (note, index) {
var sig = note.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, sig, null);
} else {
sig.args.forEach(function (arg) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);
}
}, this);
}
},
__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
kind: note.kind,
property: note.name,
negate: note.negate,
method: sig.method,
args: sig.args,
trigger: trigger
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+)\((.*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = {
name: arg,
model: this._modelForPath(arg)
};
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
Polymer.Bind.setupBindListeners(this);
},
_applyEffectValue: function (value, info) {
var node = this._nodes[info.index];
var property = info.property || info.name || 'textContent';
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
return node[property] = value;
}
},
_executeStaticEffects: function () {
if (this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
this._handlers = [];
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
this._config[name] = value;
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
this.behaviors.forEach(function (b) {
this._configureProperties(b.properties, config);
}, this);
this._configureProperties(this.properties, config);
this._mixinConfigure(config, this._aboveConfig);
this._config = config;
this._distributeConfig(this._config);
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_mixinConfigure: function (a, b) {
for (var prop in b) {
if (!this.getPropertyInfo(prop).readOnly) {
a[prop] = b[prop];
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
if (node._configValue) {
var value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);
node._configValue(x.effect.name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!this._clientsReadied) {
this._queueHandler([
fn,
e,
e.target
]);
} else {
return fn.call(this, e, e.target);
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2]);
}
this._handlers = [];
}
});
(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPath(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
prop = prop[part];
if (array && parseInt(part) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array && parseInt(last) == last) {
var coll = Polymer.Collection.get(array);
var old = prop[last];
var key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
prop[last] = value;
if (!root) {
this.notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var last = parts.pop();
while (parts.length) {
prop = prop[parts.shift()];
if (!prop) {
return;
}
}
return prop[last];
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects[model];
if (fx$) {
fx$.forEach(function (fx) {
var fxFn = this['_' + fx.kind + 'PathEffect'];
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}, this);
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node.notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node.notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
this.notifyPath(this._fixPath(b, a, path), value);
} else if (path.indexOf(b + '.') == 0) {
this.notifyPath(this._fixPath(a, b, path), value);
}
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPath: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, { bubbles: false });
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
_notifySplice: function (array, path, index, added, removed) {
var splices = [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}];
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
this.set(path + '.splices', change);
if (added != removed.length) {
this.notifyPath(path + '.length', array.length);
}
change.keySplices = null;
change.indexSplices = null;
},
push: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var array = this.get(path);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start, deleteCount) {
var array = this.get(path);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var array = this.get(path);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
notifyPath: Polymer.Base.notifyPath,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_modelForPath: Polymer.Base._modelForPath,
_pathMatchesEffect: Polymer.Base._pathMatchesEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths
});
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});
Polymer.CssParse = function () {
var api = {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, s = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !this._hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) >= 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*var[^;]*(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
return api;
}();
Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachStyleRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, callback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachStyleRule(this.rulesForStyle(s), callback);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
clearStyleRules: function (style) {
style.__cssRules = null;
},
forEachStyleRule: function (node, callback) {
if (!node) {
return;
}
var s = node.parsedSelector;
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
callback(node);
} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachStyleRule(r, callback);
}
}
},
applyCss: function (cssText, moniker, target, afterNode) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
target = target || document.head;
if (!afterNode) {
var n$ = target.querySelectorAll('style[scope]');
afterNode = n$[n$.length - 1];
}
target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
return style;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this._cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
_cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Array.prototype.slice.call(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
cssText += this._cssFromElement(e);
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
rule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!nativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'body';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?:\:host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachStyleRule(rules, function (rule) {
var map = self._mapRule(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRule: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || (target.extends = []);
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow && Boolean(this._template);
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
if (cssText && this._template) {
var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
if (!nativeShadow) {
this._scopeStyle = style;
}
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
node.className = self._scopeElementClass(node, node.className);
var n$ = node.querySelectorAll('*');
Array.prototype.forEach.call(n$, function (n) {
n.className = self._scopeElementClass(n, n.className);
});
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
mxns.forEach(function (m) {
if (m.addedNodes) {
for (var i = 0; i < m.addedNodes.length; i++) {
scopify(m.addedNodes[i]);
}
}
});
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {};
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
});
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
var customCssText = '';
var cssText = rule.parsedCssText;
cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
var parts = cssText.split(';');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
customCssText += p + ';\n';
}
}
return customCssText;
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
var def = m[2];
if (def && def.match(this.rx.IS_VAR)) {
props[def] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var pp = p.split(':');
if (pp[1]) {
pp[1] = pp[1].trim();
pp[1] = this.valueForProperty(pp[1], props) || pp[1];
}
p = pp.join(':');
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (rule.cssText && !nativeShadow) {
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.className = v;
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
rx: {
VAR_ASSIGN: /(?:^|[;\n]\s*)(--[\w-]*?):\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\n])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/i,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gi,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var StyleCache = Polymer.StyleCache;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
},
customStyle: {},
_setupStyleProperties: function () {
this.customStyle = {};
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = Polymer.dom(node);
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (this.isAttached) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepConstructor();
this._prepTemplate();
this._prepStyles();
this._prepStyleProperties();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._setupConfigure();
this._setupStyleProperties();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalAnnotationReferences();
this._setupDebouncers();
this._marshalInstanceEffects();
this._marshalHostAttributes();
this._marshalBehaviors();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
this._listenListeners(b.listeners);
}
});
(function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
Polymer({
is: 'custom-style',
extends: 'style',
properties: { include: String },
ready: function () {
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement || this;
styleDefaults.addStyle(e);
if (e.textContent || this.include) {
this._apply();
} else {
var observer = new MutationObserver(function () {
observer.disconnect();
this._apply();
}.bind(this));
observer.observe(e, { childList: true });
}
}
}
},
_apply: function () {
var e = this.__appliedElement || this;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (e.textContent) {
styleUtil.forEachStyleRule(styleUtil.rulesForStyle(e), function (rule) {
styleTransformer.documentRule(rule);
});
this._applyCustomProperties(e);
}
},
_applyCustomProperties: function (element) {
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());
Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepBindings();
archetype._notifyPath = this._notifyPathImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function (debouncerExpired) {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (var prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop)
},
{ kind: 'notify' }
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = this._forwardParentProp.bind(this);
}
this._extendTemplate(template, proto);
template._pathEffector = this._pathEffectorImpl.bind(this);
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
Object.getOwnPropertyNames(proto).forEach(function (n) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
});
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized.notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
this._forwardParentPath(subPath, value);
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._pushHost(host);
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._popHost();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};
Polymer({
is: 'dom-template',
extends: 'template',
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return key;
},
removeKey: function (key) {
this._removeFromMap(this.store[key]);
delete this.store[key];
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
if (item && typeof item == 'object') {
return this.omap.get(item);
} else {
return this.pmap[item];
}
},
getKeys: function () {
return Object.keys(this.store);
},
setItem: function (key, item) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
},
getItem: function (key) {
return this.store[key];
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key, i;
splices.forEach(function (s) {
s.addedKeys = [];
for (i = 0; i < s.removed.length; i++) {
key = this.getKey(s.removed[i]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (i = 0; i < s.addedCount; i++) {
var item = this.userArray[s.index + i];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}, this);
var removed = [];
var added = [];
for (var key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
},
detached: function () {
for (var i = 0; i < this._instances.length; i++) {
this._detachRow(i);
}
},
attached: function () {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < this._instances.length; i++) {
Polymer.dom(parentNode).insertBefore(this._instances[i].root, this);
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function () {
var dataHost = this._getRootDataHost();
var sort = this.sort;
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function () {
var dataHost = this._getRootDataHost();
var filter = this.filter;
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
var c = this.collection;
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = 0; i < this._instances.length; i++) {
var inst = this._instances[i];
keyToIdx[inst.__key__] = i;
inst.__setProperty(this.indexAs, i, true);
}
this.fire('dom-change');
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
if (this._filterFn) {
keys = keys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
if (this._sortFn) {
keys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
}
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__setProperty('__key__', key, true);
inst.__setProperty(this.as, c.getItem(key), true);
} else {
this._instances.push(this._insertRow(i, key));
}
}
for (; i < this._instances.length; i++) {
this._detachRow(i);
}
this._instances.splice(keys.length, this._instances.length - keys.length);
},
_keySort: function (a, b) {
return this.collection.getKey(a) - this.collection.getKey(b);
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var instances = this._instances;
var keyMap = {};
var pool = [];
var sortFn = this._sortFn || this._keySort.bind(this);
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var key = s.removed[i];
keyMap[key] = keyMap[key] ? null : -1;
}
for (var i = 0; i < s.added.length; i++) {
var key = s.added[i];
keyMap[key] = keyMap[key] ? null : 1;
}
}, this);
var removedIdxs = [];
var addedKeys = [];
for (var key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (var i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
pool.push(this._detachRow(idx));
instances.splice(idx, 1);
}
}
}
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
addedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
var start = 0;
for (var i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i], pool);
}
}
},
_insertRowUserSort: function (start, key, pool) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
var sortFn = this._sortFn || this._keySort.bind(this);
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._instances.splice(idx, 0, this._insertRow(idx, key, pool));
return idx;
},
_applySplicesArrayOrder: function (splices) {
var pool = [];
var c = this.collection;
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var inst = this._detachRow(s.index + i);
if (!inst.isPlaceholder) {
pool.push(inst);
}
}
this._instances.splice(s.index, s.removed.length);
for (var i = 0; i < s.addedKeys.length; i++) {
var inst = {
isPlaceholder: true,
key: s.addedKeys[i]
};
this._instances.splice(s.index + i, 0, inst);
}
}, this);
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder) {
this._instances[i] = this._insertRow(i, inst.key, pool, true);
}
}
},
_detachRow: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
}
return inst;
},
_insertRow: function (idx, key, pool, replace) {
var inst;
if (inst = pool && pool.pop()) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._generateRow(idx, key);
}
var beforeRow = this._instances[replace ? idx + 1 : idx];
var beforeNode = beforeRow ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
return inst;
},
_generateRow: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
var inst = this.stamp(model);
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
this._instances.forEach(function (inst) {
inst.__setProperty(prop, value, true);
}, this);
},
_forwardParentPath: function (path, value) {
this._instances.forEach(function (inst) {
inst.notifyPath(path, value, true);
}, this);
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst.notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
this._teardownInstance();
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
parent.insertBefore(root, this);
}
},
_teardownInstance: function () {
if (this._instance) {
var c = this._instance._children;
if (c) {
var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
c.forEach(function (n) {
parent.removeChild(n);
});
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance.notifyPath(path, value, true);
}
}
});
Polymer({
is: 'dom-bind',
extends: 'template',
created: function () {
Polymer.RenderStatus.whenReady(this._markImportsReady.bind(this));
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
this._setupConfigure = this._setupConfigure.bind(this, config);
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
Polymer.Base._initFeatures.call(this);
this._children = Array.prototype.slice.call(this.root.childNodes);
}
this._insertChildren();
this.fire('dom-change');
}
});</script>

<!-- The Polymer v0.8 rc doesn't have this :( -->
<style>
  /*******************************
            Flex Layout
  *******************************/
  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }
  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }
  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }
  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }
  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }
  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }
  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }
  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }
  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }
  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }
  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }
  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }
  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }
  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }
  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }
  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }
  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }
  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }
  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }
  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }
  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }
  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }
  /* alignment in cross axis */
  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }
  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }
  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }
  /* alignment in main axis */
  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }
  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }
  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }
  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }
  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }
  /* self alignment */
  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }
  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }
  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }
  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }
  /*******************************
            Other Layout
  *******************************/
  .block {
    display: block;
  }
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
  .invisible {
    visibility: hidden !important;
  }
  .relative {
    position: relative;
  }
  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  body.fullbleed {
    margin: 0;
    height: 100vh;
  }
  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }
  /* fixed position */
  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }
  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }
  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }
  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }
  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }
</style>






<script>
  Polymer({
    is : 'ecosis-theme-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Theme;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      var c = 0;
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Keywords' ) continue;

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( c % 2 == 0 ) col1 += input;
        else col2 += input;
        c++;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Keywords' ) continue;

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }


  })
</script>

<script>
  Polymer({
    is : 'ecosis-measurement-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Measurement;
    },

    attached : function() {
      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {
        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }

  })
</script>

<script>
  Polymer({
    is : 'ecosis-processing-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions['Processing Information'];
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }
  })
</script>

<script>
  Polymer({
    is : 'ecosis-instrument-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Instrument;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }

  })
</script>

<script>
  Polymer({
    is : 'ecosis-citation-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Citation;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {
        // inserted at top of basic info form, skip here
        if( this.schema[i].name == 'Website' ) continue;

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Website' ) continue;

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');

        var name = this.schema[i].fnName;
        var value = ecosis.ds.package['get'+name]();

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.package['get'+name+'Other']();
        }

        ele.setValue(value, other);
      }
    }
  })
</script>














<script>
  Polymer({
    is : 'ecosis-metadata-docs',

    ready : function() {
      this.style.display = 'none';
      this.className = 'animated zoomIn';

      this.render();
    },

    toggle : function() {
      if( this.style.display == 'block' ) {
        this.style.display = 'none';
      } else {
        this.style.display = 'block';
      }
    },

    render : function() {
      var html = '';
      for( var cat in ecosis.ds.metadataDefinitions ) {
        var items = ecosis.ds.metadataDefinitions[cat];
        html += '<h4>'+cat+'</h4>';

        html += this.renderTable(items);
      }

      html += '<div class="help-block">If you need help adding EcoSIS metadata attributes, '+
              'please try out the <a href="https://github.com/CSTARS/ecosis-data-tool/releases" '+
              'target="_blank">EcoSIS Data Tool.</a></div>';

      this.innerHTML = html;
    },

    renderTable : function(items) {
      var table = '<div class="well"><table class="table">';

      for( var i = 0; i < items.length; i++ ) {
        var item = items[i];
        table +=
          '<tr>'+
            '<td>'+(item.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+' <b>'+item.name+'</b>' + 
            (item.description ? '<div class="help-block">'+item.description+'</div>' : '')+'</td>'+
            '<td style="text-transform: capitalize">'+item.input+'</td>'+
            '<td class="vocab" style="font-style: italic; color: #888">'+(item.vocabulary ? item.vocabulary.join(', ') : '')+'</td>'+
          '</tr>';
      }

      return table + '</table></div>';
    }
  })
</script>


















</head><body><div hidden="">

<dom-module id="ecosis-schema-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-schema-input',

    properties : {
      metadata : {
        type : String
      }
    },

    attached : function() {
      this.style.display = "block";

      this.schema = ecosis.ds.metadataLookup[this.metadata];
      this.flatName = this.schema.name.replace(/ /g, '');

      if( this.schema.input == 'controlled' || this.schema.input == 'controlled-single' ) {
        if( this.isYesNo(this.schema) ) {
          this.innerHTML = '<ecosis-radio-input metadata="'+this.metadata+'"></ecosis-radio-input>';
        } else {
          this.innerHTML = '<ecosis-controlled-input metadata="'+this.metadata+'"></ecosis-controlled-input>';
        }
      } else {
        var html =
          '<div class="form-group">'+
            '<label for="'+this.schema.flat+'Input" class="col-md-3 control-label">'  +
              (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '') + this.schema.name+': </label>'+
            '<div class="col-md-7">'+
              '<input type="'+this.schema.input+'" class="form-control" />';

        if( this.schema.description || this.schema.input === 'split-text' ) {
          var help = this.schema.description || '';
          if( help.length > 0 ) {
            if( !help.match(/\.$/) ) {
              help += '.  ';
            } else {
              help += '  ';
            }
          }
          if( this.schema.input === 'split-text' ) {
            help += 'Comma separate for multiple values.';
          }

          html += '<div class="help-block">'+help+'</div>';
        }

        html += '</div></div>';

        this.innerHTML = html;

        this.querySelector('input').addEventListener('change', this.trigger.bind(this));
      }
    },

    isYesNo : function(schema) {
      if( !schema.vocabulary ) return false;
      if( schema.vocabulary.length != 2 ) return false;

      var c = 0;
      schema.vocabulary.forEach(function(vocab){
        if( vocab.toLowerCase() === 'yes' || vocab.toLowerCase() === 'no' ) {
          c++;
        }
      });
      if( c === 2 ) return true;
      return false;
    },

    setValue : function(value, otherValue) {
      if( this.schema.input == 'controlled' || this.schema.input == 'controlled-single' ) {
        if( this.isYesNo(this.schema) ) {
          this.querySelector('ecosis-radio-input').setValue(value);
        } else {
          this.querySelector('ecosis-controlled-input').setValue(value, otherValue);
        }
      } else {
        if( Array.isArray(value) ) {
          value = value.join(', ');
        }

        this.querySelector('input').value = value;
      }
    },

    trigger : function(e) {
      ecosis.ds.package['set'+this.flatName](e.currentTarget.value);
    }
  })
</script>

<dom-module id="ecosis-controlled-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>
    <div class="horizontal-form">
      <div class="form-group">
        <label id="label" for="input" class="col-md-3 control-label"></label>
        <div class="col-md-7">
          <select class="form-control" id="input" on-change="onSelectChange"></select>

          <div id="selected"></div>

          <div class="help-block" id="help" style="display:none"></div>

          <div id="otherRoot" style="display:none"></div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-controlled-input',

    properties : {
      metadata : {
        type : String
      }
    },

    ready : function() {
      this.selected = [];
      this.schema = ecosis.ds.metadataLookup[this.metadata];

      this.$.label.innerHTML = (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+this.schema.name;

      this.render();

      if( this.schema.description ) {
        this.$.help.style.display = 'block';
        this.$.help.innerHTML = this.schema.description;
      }

      if( this.schema.allowOther ) {
        var html = '<input type="text" class="form-control" id="other" placeholder="Please provide other value" />';
        this.$.otherRoot.innerHTML = html;

        this.$.other = this.$.otherRoot.querySelector('input');
        this.$.other.addEventListener('change', this.onChange.bind(this));
      }
    },

    render : function() {
      var options = '<option></option>';
      for( var i = 0; i < this.schema.vocabulary.length; i++ ) {
        var vocab = this.schema.vocabulary[i];
        if( this.selected.indexOf(vocab) > -1 ) continue;
        options += '<option value="'+this.schema.vocabulary[i]+'">'+this.schema.vocabulary[i]+'</option>'
      }
      this.$.input.innerHTML = options;

      var btns = '';
      for( var i = 0; i < this.selected.length; i++ ) {
        btns += '<a class="btn btn-primary btn-xs" style="margin:2px" value="'+this.selected[i]+
                '"><i class="fa fa-times"></i> '+this.selected[i]+'</a>';
      }
      this.$.selected.innerHTML = btns;

      $(this.$.selected).find('a').on('click', this.onRemove.bind(this));

      if( this.selected.indexOf('Other') == -1 ) {
        this.$.otherRoot.style.display = 'none';
      } else {
        this.$.otherRoot.style.display = 'block';
      }
    },

    onRemove : function(e) {
      var value = e.currentTarget.getAttribute('value');
      var index = this.selected.indexOf(value);
      if( index > -1 ) this.selected.splice(index, 1);

      if( value == 'Other' ) {
        this.$.otherRoot.style.display = 'none';
        if( this.schema.allowOther ) {
          this.$.other.value = '';
        }
      }

      ecosis.ds.package['set'+this.schema.fnName](this.getValue());

      this.render();
    },

    getValue : function() {
      var value = this.selected.join(',');
      if( this.schema.allowOther ) {
        if( this.$.other.value.length > 0 && value.length > 0 ) {
          value += ',';
        }
        value += this.$.other.value;
      }
      return value;
    },

    onSelectChange : function() {
      if( this.$.input.value == '' ) return;

      if( this.schema.input === 'controlled-single' ) {
        this.selected = [this.$.input.value];
      } else {
        this.selected.push(this.$.input.value);
      }

      this.onChange();
    },

    onChange : function() {
      ecosis.ds.package['set'+this.schema.fnName](this.getValue());
      this.render();
    },

    setValue: function(value, otherValue) {
      if( typeof value === 'string' ) {
        value = [value];
      }

      this.selected = value;
      for( var i = 0; i < this.selected.length; i++ ) {
        this.selected[i] = this.selected[i].trim();
      }
      for( var i = this.selected.length-1; i >= 0; i-- ) {
        if( this.selected[i] == '' ) {
          this.selected.splice(i, 1);
        }
      }

      if( this.schema.allowOther && otherValue ) {
        this.$.otherRoot.style.display = (value.length > 0) ? 'block' : 'none';
        if( Array.isArray(otherValue) ) {
          otherValue = otherValue.join(', ');
        }
        this.$.other.value = otherValue;
      }

      this.render();
    }
  })
</script>

<dom-module id="ecosis-radio-input">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div class="horizontal-form">
      <div class="form-group">
        <label id="label" for="input" class="col-md-3 control-label"></label>
        <div class="col-md-7" style="padding-top:10px">
          <label>
            <input type="radio" id="yes" value="Yes" on-change="onChange"> Yes
          </label>&nbsp;&nbsp;
          <label>
            <input type="radio" id="no" value="No" on-change="onChange"> No
          </label>

          <div class="help-block" id="help" style="display:none"></div>
        </div>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-radio-input',

      properties : {
        metadata : {
          type : String
        }
      },

      attached : function() {
        this.schema = ecosis.ds.metadataLookup[this.metadata];
        this.$.yes.setAttribute('name', this.schema.flat+'-radio');
        this.$.no.setAttribute('name', this.schema.flat+'-radio');
        this.$.label.innerHTML = this.schema.name;
      },

      onChange : function(e) {
        this.selected = [e.currentTarget.getAttribute('value')];
        ecosis.ds.package['set'+this.schema.fnName](e.currentTarget.getAttribute('value'));
      },

      setValue: function(value) {
        if( value.toLowerCase() === 'yes' ) {
          this.$.yes.checked = true;
        } else {
          this.$.no.checked = true;
        }
      }
    });
  </script>
</dom-module>






<dom-module id="ecosis-location-input">
  <style>
    :host {
      display : block;
    }
  </style>
  <template>
    <div class="well">

      <div class="horizontal-form">
        <div class="form-group">
          <label id="label" for="input" class="col-md-3 control-label">Location Name</label>
          <div class="col-md-7">
            <input type="text" class="form-control" id="input" on-change="onNameChange">
            <div class="help-block" id="help">You can comma separate</div>
          </div>
        </div>
      </div>

      <h5>Bounding Box</h5>
      <div id="map" style="height: 400px"></div>
      <div class="help-block">Draw bounding box for dataset.  If you provide latitude and
      longitude or geojson field(s) in your spectra, a bounding box for your dataset will
      be automatically calculated for search.</div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-location-input',

    attached : function() {
      this.drawing = false;

      // HACK, clicking the goecode menu fires a click on the map as well.
      // Can't seem to find where to intercept event.  Ignoring with flag for now...
      this.geocodeMenuClicked = false;

      this.map = L.map(this.$.map, {
          center: [0, 0],
          zoom: 2
      });

      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(this.map);
      L.Control.geocoder()
        .on('markgeocode', this.onGeocodeSelect.bind(this))
        .addTo(this.map);

      this.map.on('click', this.onClick.bind(this));
      this.map.on('mousemove', this.onMouseMove.bind(this));

      ecosis.ds.on('load', this.onLoad.bind(this));
    },

    onLoad : function() {
      var names = ecosis.ds.package.getLocationName();
      if( Array.isArray(names) ) {
        names = names.join(', ');
      }
      this.$.input.value = names;

      var geojson = ecosis.ds.package.getGeoJson();
      if( Object.keys(geojson).length === 0 ) return;

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": geojson
      };

      try {
        this.polygon = L.geoJson(geojsonFeature);
        this.polygon.addTo(this.map);
        this.polygon.on('click', this.onFeatureClick.bind(this));
      } catch(e) {}
    },

    onNameChange : function() {
      ecosis.ds.package.setLocationName(this.$.input.value);
    },

    onShow : function() {
      this.drawing = false;

      setTimeout(function(){
        this.map.invalidateSize();
        if( this.polygon ) {
          this.map.fitBounds(this.polygon.getBounds());
        }
      }.bind(this), 50);
    },

    onGeocodeSelect : function() {
      this.geocodeMenuClicked = true;
      setTimeout(function(){
        this.geocodeMenuClicked = false;
      }.bind(this), 100);
    },

    onClick : function(e) {
      if( this.geocodeMenuClicked ) {
        return;
      }

      if( this.drawing ) {
        this.drawing = false;
        this.setPolygon(e.latlng);
        return;
      }

      this.drawing = true;
      this.p1 = e.latlng;
    },

    onFeatureClick : function(e) {
      if( this.drawing ) {
        return this.onClick(e);
      }

      // else clear
      if( this.polygon ) {
        this.map.removeLayer(this.polygon);
      }

      ecosis.ds.package.setGeoJson(null);
    },

    onMouseMove : function(e) {
      if( !this.drawing ) return;

      if( this.polygon ) {
        this.map.removeLayer(this.polygon);
      }
      var p2 = e.latlng;

      var coordinates = [[
          [this.p1.lng, this.p1.lat],
          [this.p1.lng, p2.lat],
          [p2.lng, p2.lat],
          [p2.lng, this.p1.lat],
          [this.p1.lng, this.p1.lat]
      ]];

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type" : "Polygon",
            "coordinates" : coordinates
          }
      };

      this.polygon = L.geoJson(geojsonFeature);
      this.polygon.on('click', this.onFeatureClick.bind(this));
      this.polygon.addTo(this.map);
    },

    setPolygon : function(p2) {
      var geojson = {
        "type" : "Polygon",
        "coordinates" : [[
            [this.p1.lng, this.p1.lat],
            [this.p1.lng, p2.lat],
            [p2.lng, p2.lat],
            [p2.lng, this.p1.lat],
            [this.p1.lng, this.p1.lat]
        ]]
      }

      ecosis.ds.package.setGeoJson(geojson);
    }

  })
</script>

<dom-module id="ecosis-title-input">
  <style>
    :host {
      display: block;
    }
    span.label {
      font-size: 12px;
    }
    #titleLabel {
      font-weight: bold;
    }
  </style>

  <template>
    <div id="editMode" style="display:none" class="form-horizontal">
      <div class="form-group">
        <label class="col-md-2 control-label">Title</label>
        <div class="col-md-9" style="padding-top:7px">
          <div><span id="titleLabel"></span></div>
          <div style="font-size:12px;color:#888;font-style:italic">
            URL: <span id="urlLabel"></span>
          </div>
        </div>
      </div>
    </div>

    <div id="inputMode" class="form-horizontal">
      <div class="form-group">
        <label for="titleInput" class="col-md-2 control-label">Title</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="titleInput" placeholder="Unique Dataset Title" on-blur="onBlur" on-keyup="onTitleInputChange">

          <span id="verifyingTitleLabel" class="label label-info" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Verifying name...
          </span>

          <span class="label label-danger" style="display:none" id="invalid"></span>

          <span class="label label-success" style="display:none" id="valid">
            URL: <span id="urlLabelInput"></span>
          </span>

          <div id="message" class="help-block">
            Please <span class="text text-warning">do not use '_' or '-'</span> in your title use spaces instead.  We want
            your title to be as human readable as possible!
          </div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-title-input',

    ready : function() {
      this.currentName = null;
      this.verify = new ecosis.app.UiBuffer(this._verify, 500, this);

      ecosis.ds.on('load', this.onDataReady.bind(this));
      this.validName = false;
    },

    onDataReady : function() {
      if( ecosis.ds.editMode ) {
        this.$.titleInput.value = ecosis.ds.package.getTitle();
        this.$.urlLabel.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.package.getName();
        return;
      }

      this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/';
    },

    onTitleInputChange : function() {
      this.verify();
    },

    onBlur : function() {
      this.verify();
    },

    _verify : function() {
      if( ecosis.ds.editMode && ecosis.ds.package.getName() && this.currentName === null ) {
        this.currentName = ecosis.ds.package.getName();
      }

      this.$.verifyingTitleLabel.style.display = 'inline-block';
      this.$.invalid.style.display = 'none';
      this.$.valid.style.display = 'none';
      this.validName = false;

      // TODO: verify this has been removed
      // if we are in edit mode and the current, cleaned, name is equal to the 'updated' name
      // then there is nothing to check, they are just updating the title.  This will throw
      // a false positive if we check for name in use (cause it is, by this dataset);
      //if( ecosis.ds.editMode && ecosis.ds.package.getName() === this.currentName ) {
      //  return;
      //}

      ecosis.ds.package.setTitle(this.$.titleInput.value, function(err, resp){
        this.$.verifyingTitleLabel.style.display = 'none';
        if( err ) {
          this.$.invalid.style.display = 'inline-block';
          this.$.invalid.innerHTML = err.message;
          this.fire('update');
          return;
        }

        //this.$.nameLabel.innerHTML = ecosis.ds.package.getName();
        this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.package.getName();
        this.$.valid.style.display = 'inline-block';
        this.validName = true;

        this.fire('update');
      }.bind(this));
    }

  });
</script>

<dom-module id="ecosis-keyword-input">
  <style>
    :host {
      display : block;
    }
    span.label {
      font-size: 12px;
      position: absolute;
      right: 15px;
      top: 15px;
    }
    a.btn {
      margin: 5px;
    }
  </style>
  <template>

    <div class="form-horizontal">
      <div class="form-group">
        <label for="keywordInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Keywords</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="keywordInput" on-keyup="onInputChange" placeholder="Search Keywords">
          <div class="help-block">
            Search for EcoSIS keywords or create new keywords.  Comma separate to add more than one keyword at a time.  Use
            the 'enter' key to create new keyword(s).
          </div>
          <span id="searchingPanel" class="label label-primary" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Searching...
          </span>

          <div id="resultRoot"></div>
          <div id="currentKeywordsRoot"></div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-keyword-input',

    ready : function() {
        this.tokens = [];
        this.focus = false;
        this.searchTimer = -1;
    },

    // fires when text is typed input field
    onInputChange : function(e) {
        if( e.which == 13 ) this.createToken();
        else this.search();
    },

    search : function(){
        if( this.searchTimer != -1 ) clearTimeout(this.searchTimer);
        if( this.$.keywordInput.value == '' ) {
          this.setSearching(false);
          this.$.resultRoot.innerHTML = '';
          return;
        }

        this.setSearching(true);

        this.searchTimer = setTimeout(function(){
          ecosis.ckan.tagSearch(this.$.keywordInput.value, 10, function(resp){
            this.setSearching(false);

            this.results = resp.results;
            this.renderResults();
          }.bind(this));
        }.bind(this), 500);
    },

    createToken : function() {
      var parts = this.$.keywordInput.value.split(',');
      for( var i = 0; i < parts.length; i++ ) {
        var value = this.clean(parts[i]);

        if( value.length == 0 ) continue;

        var t = {
            label : value,
            value : value
        }

        this.addToken(t, true);
      }

      this.$.keywordInput.value = '';
      this.$.resultRoot.innerHTML = '';
    },

    addResult : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        var name = this.results[index].name;

        this.addToken({label:name, value:name}, true);

        this.$.keywordInput.value = '';
        this.$.resultRoot.innerHTML = '';
        this.renderTokens();
    },

    addToken : function(token, fireEvent) {
        if( !token.value || token.value == '' ) return;

        for( var i = 0; i < this.tokens.length; i++ ) {
            if( this.tokens[i].value == token.value ) return;
        }

        token.label = token.value;
        this.tokens.push(token);

        ecosis.ds.package.addKeyword(token.value);

        this.renderTokens();
    },

    renderResults : function() {
      var btns = '';
      for( var i = 0; i < this.results.length; i++ ) {
        btns += '<a class="btn btn-default btn-sm ecosis-keyword-input" style="text-transform:initial" index="'+i+'" ><i class="fa fa-plus"></i> '+this.results[i].name+'</a>';
      }
      this.$.resultRoot.innerHTML = btns.length > 0 ? '<div class="well">Suggestions:<br />'+btns+'</div>' : '';

      $(this.$.resultRoot).find('a').on('click', this.addResult.bind(this));
    },

    renderTokens : function() {
      var btns = '';
      for( var i = 0; i < this.tokens.length; i++ ) {
        btns += '<a class="btn btn-primary btn-sm ecosis-keyword-input" style="text-transform:initial" index="'+i+'"><i class="fa fa-times"></i> '+this.tokens[i].label+'</a>';
      }
      this.$.currentKeywordsRoot.innerHTML = btns;

      $(this.$.currentKeywordsRoot).find('a').on('click', this.onTokenClick.bind(this));
    },

    getTokens : function() {
        return this.tokens;
    },

    setTokens : function(tokens) {
        this.tokens.splice(0,this.tokens.length);
        for( var i = 0; i < tokens.length; i++ ) {
            this.addToken({label: tokens[i].name, value : tokens[i].name});
        }

        this.renderTokens();
    },

    onTokenClick : function(e) {
        var index = parseInt(e.currentTarget.getAttribute("index"));
        var token = this.tokens.splice(index,1)[0];

        ecosis.ds.package.removeKeyword(token.value);

        // don't set focus to input
        e.stopPropagation();

        this.renderTokens();
    },

    setSearching : function(searching) {
      this.$.searchingPanel.style.display = searching ? 'inline-block' : 'none';
    },

    clean : function(txt) {
      return txt.replace(/[^A-Za-z0-9-_\s]/g, '').trim();
    }
  });
</script>

<dom-module id="ecosis-linked-data-input">
  <template>
    <style>
      :host {
        display: block;
      }
      [hide="true"] {
        display: none;
      }
      .form-inline .form-group {
        padding: 0 30px;
      }
    </style>

    <div class="help-block">
      Links to additional site related information and data.  Here you link your spectral
      data to external sites and datasets.  Example, flux data.
    </div>

    <template is="dom-repeat" items="{{list}}">
      <div class="form-inline">
        <div class="form-group">
          <label for="">Label</label>
          <input type="text" class="form-control" placeholder="Ex: Fluxnet" value="{{item.label::input}}" on-input="checkFilled" on-blur="fireUpdate">
        </div>
        <div class="form-group">
          <label for="">URL</label>
          <input type="text" class="form-control" style="min-width: 300px" placeholder="Ex: http://fluxnet.ornl.gov/site/646" value="{{item.url::input}}" on-input="checkFilled" on-blur="fireUpdate">
        </div>
        <a class="btn btn-default" index$="{{index}}" on-click="remove" hide$="{{item.last}}"><i class="fa fa-trash"></i></a>
      </div>
    </template>

  </template>
  <script>
    Polymer({
      is: 'ecosis-linked-data-input',

      properties : {
        list : {
          type : Array,
          value : function() {
            return [{
              label : '',
              url : '',
              last : 'true'
            }];
          }
        }
      },

      setData : function(data) {
        var hasData = false;
        if( data && data.length > 0 ) {
          hasData = true;
        }

        if( !hasData ) {
          data = [{
            label : '',
            url : '',
            last : 'true'
          }];
        }

        this.list = data;
        this.checkFilled();
      },

      getData : function() {
        var arr = [];

        for( var i = 0; i < this.list.length; i++ ) {
          if( this.list[i].label.length > 0 && this.list[i].url.length > 0 ) {
            arr.push({
              label : this.list[i].label,
              url : this.list[i].url
            });
          }
        }

        return arr;
      },

      remove : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        this.splice('list', index, 1);
        this.fireUpdate();
      },

      checkFilled : function() {
        if( !this.list ) return;
        if( this.list.length === 0 ) return;

        var item = this.list[this.list.length-1];
        if( item.label.length > 0 && item.url.length > 0 ) {
          this.push('list',{
            label : '',
            url : '',
            last : 'true'
          });
        }

        for( var i = 0; i < this.list.length-1; i++ ) {
          if( this.list[i].last == 'true') {
            this.set('list.'+i+'.last', 'false');
          }
        }
      },

      fireUpdate : function() {
        ecosis.ds.package.setLinkedData(this.getData());
      }

    });
  </script>
</dom-module>

<dom-module id="ecosis-header">
  <style>
    :host {
      display: block;
    }
    #root.static {
      background-color: rgb(70, 70, 70);
    }
    #root.static a {
      color: white !important;
    }
    #root.static .navbar-brand {
      color: white !important;
    }
    #root.static li.active a {
      color: #222 !important;
    }
    #root.static li.open a {
      color: #222 !important;
    }
    #staticMessage {
      position: fixed;
      z-index: 25;
      top: 62px;
      text-align: center;
      padding: 4px 0 2px 0;
      background-color: rgba(255,255,255,.5);
      width: 100%;
      border-bottom: 1px solid #ccc;
    }
  </style>
  <template>
    <nav class="navbar navbar-default navbar-fixed-top" id="root">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#ecosis-header-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">EcoSIS Importer<span id="score2" class="visible-xs-inline"></span></span>
        </div>

        <div class="collapse navbar-collapse" id="ecosis-header-collapse">
          <ul class="nav navbar-nav">

            <li class="active"><a id="basicInfo"><i class="fa fa-info-circle"></i> Basic Information</a></li>

            <li class="dropdown" id="resourcesDropdown" style="display:none">
              <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                <i class="fa fa-files-o"></i> Resources <span class="caret"></span>
              </a>
              <ul class="dropdown-menu" role="menu">
                <li><a id="addResources"><i class="fa fa-plus"></i> Add Resources</a></li>
                <li><a id="currentResources"><i class="fa fa-list"></i> Current Resources</a></li>
              </ul>
            </li>

            <li><a id="advanced" style="display:none"><i class="fa fa-cog"></i> Advanced</a></li>
            <li><a id="push" style="display:none"><i class="fa fa-check-circle-o"></i> Publish</a></li>
            <li id="score" class="hidden-xs" style="padding-top:18px"></li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li><a href="http://tutorial.ecosis.org" target="_blank"><i class="fa fa-question-circle"></i> Help</a></li>
            <li><a id="exit" href="/dataset/"><i class="fa fa-sign-in"></i> Exit</a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="staticMessage" style="display:none">
      <i class="fa fa-warning"></i> A EcoSIS DOI as been applied to the dataset.  It is no longer editable.
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-header',

    properties : {
      hack : {
        type : String,
        value : ''
      }
    },

    ready : function() {
      // such BS polymer!
      this.$.basicInfo.setAttribute('href', '#basic-info');
      this.$.addResources.setAttribute('href', '#add-resources');
      this.$.currentResources.setAttribute('href', '#current-resources');
      this.$.advanced.setAttribute('href', '#advanced');
      this.$.push.setAttribute('href', '#push');

      $(window).on('hashchange', this.updateActiveTab.bind(this));
      this.updateActiveTab();

      if( ecosis.ds.editMode ) {
        ecosis.ds.on('load', function(pkg){
          if( ecosis.ds.editMode ) this.setBackBtn();
          this.checkDoiStatus();
        }.bind(this));
      } else {
        this.$.exit.setAttribute('href', '/dataset/');
      }

      var fn = new ecosis.app.UiBuffer(this.onScoreUpdated, 100, this);
      ecosis.ds.on('update', fn);
      ecosis.ds.on('load', fn);
    },

    attached : function() {
      if( ecosis.ds.editMode ) {
        this.$.resourcesDropdown.style.display = 'block';
        this.$.advanced.style.display = 'block';
        this.$.push.style.display = 'block';
      }
    },
    
    checkDoiStatus : function() {
      var status = ecosis.ds.package.getDoi().status;
      if( status && status.value ) {
        if( status.value.toLowerCase() === 'applied' ) {
          this.$.root.classList.add('static');
          this.$.staticMessage.style.display = 'block';
        }
      }
    },

    setBackBtn : function() {
      this.$.exit.setAttribute('href', '/dataset/'+ecosis.ds.package.getName());
    },

    updateActiveTab : function() {
      $('li').removeClass('active');

      var loc = window.location.hash.replace(/#/,'');
      var ele = $(this).find('a[href="#'+loc+'"]');

      if( ele.length > 0 && (loc == 'add-resources' || loc == 'current-resources') ) {
        $(this.$.resourcesDropdown).addClass('active');
      } else if ( ele.length > 0 ) {
        ele.parent().addClass('active');
      } else {
        $(this.$.basicInfo).parent().addClass('active');
      }
    },

    onScoreUpdated : function() {
      var result = ecosis.ds.getScore();

      if( result.score === this.lastScore ) {
        return;
      }
      this.lastScore = result.score;

      var label = 'success';
      if( result.score < 3 ) label = 'danger';
      else if( result.score < 8 ) label = 'warning';

      this.$.score.innerHTML = '<span style="display:inline-block" class="label label-'+label+' animated zoomIn">'+result.score+'/'+result.total+'</span>';
      this.$.score2.innerHTML = '<span class="label label-'+label+'">'+result.score+'/'+result.total+'</span>';
    }

  });
</script>

<dom-module id="ecosis-dataformat-help">
  <style>
      table.preview {
          width: 100%;
          border-spacing: 0px;
          border-collapse: separate;
          border-top: 1px solid #ddd;
          border-left: 1px solid #ddd;
          background-color: white;
      }
      table.preview td {
          padding: 10px;
          border-right: 1px solid #ddd;
          border-bottom: 1px solid #ddd;
      }
      table.preview td.attr {
          font-weight: bold;
      }
      .file {
          background-color: #dff0d8;
      }
      .column {
          background-color: #fcf8e3;
      }
      .data {
          background-color: #d9edf7;
      }
      .note {
          padding: 10px 0;
          color: #777;
          font-size: 13px;
      }
      .note-label {
          padding: 3px;
          border-radius: 3px;
          font-weight: bold;
      }
      table.preview td.highlight {
          border-left: 1px solid red;
          border-right: 1px solid red;
      }
      table.preview td.highlight-row {
          border-top: 1px solid red;
          border-bottom: 1px solid red;
      }
      :host {
        display: block;
      }
  </style>
  <template>

    <div class="well">
        EcoSIS accepts data in several tabular formats.  These tabular files can have measurements laid out by column or by row.
    </div>

    <div id="column">
        <h4>Column Orientation</h4>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">id</td>
                <td class="column">id1</td>
                <td class="column highlight" style="border-top:1px solid red">id2</td>
                <td class="column">id3</td>
            </tr>
            <tr>
                <td class="column attr">USDA Code</td>
                <td class="column">ORYZA</td>
                <td class="column highlight">ORYZA</td>
                <td class="column">ACRU</td>
            </tr>
            <tr>
                <td class="column attr">LAI (m2/m2)</td>
                <td class="column">1.812</td>
                <td class="column highlight">.441</td>
                <td class="column">1.501</td>
            </tr>
            <tr>
                <td class="column attr">NDVI</td>
                <td class="column">.53</td>
                <td class="column highlight">.5</td>
                <td class="column">.48</td>
            </tr>
            <tr>
                <td class="data attr">400</td>
                <td class="data">.34</td>
                <td class="data highlight">.345</td>
                <td class="data">.454</td>
            </tr>
            <tr>
                <td class="data attr">410</td>
                <td class="data">.400</td>
                <td class="data highlight" style="border-bottom:1px solid red">.430</td>
                <td class="data">.568</td>
            </tr>
        </tbody></table>
    </div>

    <div id="row">
        <h4>Row Orientation</h4>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">datetime</td>
                <td class="column attr">id</td>
                <td class="column attr">Metadata Attribute</td>
                <td class="column attr">USDA Code</td>
                <td class="column attr">LAI (m2/m2)</td>
                <td class="data attr">400</td>
                <td class="data attr">410</td>
            </tr>
            <tr>
                <td class="column attr highlight-row" style="border-left: 1px solid red">2008-07-24</td>
                <td class="column highlight-row">id1</td>
                <td class="column highlight-row">metadata value 1</td>
                <td class="column highlight-row">ORYZA</td>
                <td class="column highlight-row">1.190</td>
                <td class="data highlight-row">.53</td>
                <td class="data highlight-row" style="border-right: 1px solid red">.487</td>
            </tr>
            <tr>
                <td class="column attr">2008-07-25</td>
                <td class="column">id2</td>
                <td class="column">metadata value 2</td>
                <td class="column">ACRU</td>
                <td class="column">0.606</td>
                <td class="data">.50</td>
                <td class="data">.400</td>
            </tr>
        </tbody></table>
    </div>

    <div class="note">
        <h5>Wavelengths</h5>
        Any <span class="data note-label">numeric</span> field name will be considered
        <span class="data note-label">wavelength measurement</span>.  All other fields will be considered
        <span class="column note-label">metadata</span>.  Metadata fields can supply units.
    </div>

    <div class="note">
        <h5>Global Metadata</h5>
        <span class="file note-label">Global File Metadata</span> is applied to everything in the file
        and is completely <b>optional</b>.  You can also upload a seperate metadata file which can be
        joined to your data later on in the import process.
    </div>

    <div class="note">
      <h5>Units</h5>
      Units can be specified by placing them in parentheses <b>(m2/m2)</b> after the field name.
    </div>

    <div style="margin-top:15px">
        Still lost?  <a href="http://tutorial.ecosis.org/walkthrough/#/7" target="_blank">Click
          here</a> to checkout the tutorial on data formats.
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataformat-help',

    setType : function(type) {
      if( type == 'column' ) {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'none';
      } else if( type == 'row' ) {
        this.$.column.style.display = 'none';
        this.$.row.style.display = 'block';
      } else {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'block';
      }
    }
  });
</script>

<dom-module id="ecosis-datasheet-select-panel">
  <style>
    :host {
      display: block;
    }
    .alert-default {
      background-color: #888;
      color : white;
    }
    .alert-primary {
      background-color: #2196f3;
      color: white;
    }
  </style>

  <template>
    <div id="well" class="">
      <div class="layout horizontal center">
        <div>
          <a class="btn btn-default" on-click="back" id="back">
            <i class="fa fa-arrow-left" style="color:#888"></i>
          </a>
        </div>
        <div style="padding:0 15px">Sheet:</div>
        <div class="flex" style="text-align:center; padding: 0 25px 0 0">
            <select id="select" class="form-control" on-change="onSelect"></select>
        </div>
        <div>
          <a class="btn btn-default" on-click="forward" id="forward">
            <i class="fa fa-arrow-right" style="color:#888"></i>
          </a>
        </div>
    </div>
  </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-select-panel',

    update : function(resource) {
      this.resource = resource;
      this.selected = 0;

      var options = '';
      for( var i = 0; i < resource.datasheets.length; i++ ) {
        var ds = resource.datasheets[i];
        var name = ds.sheetId.split('-')[1]
        options += '<option value="'+i+'">'+name+'</option>';
      }
      this.$.select.innerHTML = options;
      this.updateClass();
    },

    onSelect : function() {
      this.selected = parseInt(this.$.select.value);
      this.updateClass();
      this.fire('select', this.selected);
    },

    back : function() {
      this.selected--;
      if( this.selected < 0 ) {
        this.selected = 0;
        return;
      }
      this.$.select.value = this.selected+'';
      this.updateClass();
      this.fire('select', this.selected);
    },

    forward : function() {
      this.selected++;
      if( this.selected >= this.resource.datasheets.length ) {
        this.selected = this.resource.datasheets.length-1;
        return;
      }
      this.$.select.value = this.selected+'';
      this.updateClass();
      this.fire('select', this.selected);
    },

    updateClass : function() {
      var css = 'style-scope ecosis-datasheet-select-panel alert ';

      if( !this.resource ) return;
      if( !this.resource.datasheets ) return;
      if( this.resource.datasheets.length <= this.selected ) return;

      var sheet = this.resource.datasheets[this.selected];
      if( sheet.ignored ) {
        css += 'alert-default';
      } else if ( sheet.metadata ) {
        css += 'alert-primary';
      } else {
        css += 'alert-success'
      }

      this.$.well.className = css;
    },

    setDisabled : function(disable) {
      if( disable ) {
        this.$.forward.setAttribute('disabled', '');
        this.$.back.setAttribute('disabled', '');
        this.$.select.setAttribute('disabled', '');
      } else {
        this.$.forward.removeAttribute('disabled');
        this.$.back.removeAttribute('disabled');
        this.$.select.removeAttribute('disabled');
      }
    }
  });
</script>

<dom-module id="ecosis-metadata-join-panel">
  <template>
    <div id="hasMatches">
      <select id="joinId" class="form-control" on-change="onJoinIdChange"></select>
      <div id="msg"></div>
    </div>
    <div id="noMatches" class="text text-warning">
      The field names (keys) in this sheet do not match any other data sheet.  To join
      this metadata you must use common keys in both your metadata sheet and your
      data sheet.  This key is often known as a primary key in SQL/relational land.<br><br>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-metadata-join-panel',

    ready : function() {
      this.updateTimer = -1;
    },

    update : function(datasheet, resource) {
      if( datasheet ) this.datasheet = datasheet;
      if( resource ) this.resourceId = resource.id;

      var options = '<option></option>';
      var knownAttrs = ecosis.ds.getDatasheetAttributes();
      var c = 0;

      for( var i = 0; i < this.datasheet.attributes.length; i++ ) {
        var attr = this.datasheet.attributes[i];
        if( knownAttrs.indexOf(attr) > -1 ) {
          options += '<option value="'+attr+'" '+
              (this.datasheet.joinOn == attr ? 'selected' : '') +
              '>'+attr+'</option>';
          c++;
        }
      }
      this.$.joinId.innerHTML = options;

      if( c == 0 ) {
        this.$.noMatches.style.display = 'block';

        // show all
        for( var i = 0; i < this.datasheet.attributes.length; i++ ) {
          var attr = this.datasheet.attributes[i];
          options += '<option value="'+attr+'" '+
              (this.datasheet.joinOn == attr ? 'selected' : '') +
              '>'+attr+'</option>';
        }
        this.$.joinId.innerHTML = options;

      } else {
        this.$.noMatches.style.display = 'none';
      }

      var matchCount = 0;
      for( var key in this.datasheet.matches ) {
        matchCount += this.datasheet.matches[key]
      }
      //this.$.matchCountLabel.innerHTML = matchCount;
    },

    onJoinIdChange : function() {
      this.datasheet.joinOn = this.$.joinId.value;
      this.updateServer();
    },


    updateServer : function() {
      this.fire('joinon-selected', this.datasheet.joinOn);
    },

    setUpdating : function(updating) {
      if( updating ) {
        this.$.filenameMatch.setAttribute('disabled', '');
        this.$.looseMatch.setAttribute('disabled', '');
        this.$.joinId.setAttribute('disabled', '');

        this.$.matchCountPanel.style.display = 'none';
        this.$.updatingPanel.style.display = 'block';

        this.fire('metadata-update', {updating: true});
      } else {
        this.$.filenameMatch.removeAttribute('disabled');
        this.$.looseMatch.removeAttribute('disabled');
        this.$.joinId.removeAttribute('disabled');

        this.$.matchCountPanel.style.display = 'inline-block';
        this.$.updatingPanel.style.display = 'none';

        this.fire('metadata-update', {updating: false});
      }
    },

  })
</script>
<dom-module id="ecosis-datasheet-panel">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>

    <div id="main" class="animated fadeIn">
      <h6 id="titleLabel" style="display:none"></h6>

      <ecosis-sheet-preview id="preview" style="margin-bottom: 25px"></ecosis-sheet-preview>

      <span class="alert alert-danger" style="display:none" id="parseError">
          Error parsing file
      </span>

      <span class="alert alert-warning" style="display:none" id="repeatsWarning"></span>

      <h4 class="page-header"><i class="fa fa-cogs"></i> Sheet Settings</h4>

      <!-- Is Metadata -->
      <div id="metadataSelectPanel">
        <div class="form-horizontal">
          <div class="form-group">

            <label for="inputIsMetadata" class="col-md-2 control-label">Joinable Metadata</label>
            <div class="col-md-10">
              <div class="checkbox">
                <label>
                  <input id="inputIsMetadata" type="checkbox" on-change="onMetadataUpdate"> This sheet contains metadata to be joined on given data.
                </label>
              </div>
            </div>

          </div>
          <div class="form-group" id="joinMetadataOuter">
            <label for="inputIsMetadata" class="col-md-2 control-label">Field To Join On <span style="color:#aaa">/ Primary Key</span></label>
            <div class="col-md-10">
                <ecosis-metadata-join-panel id="joinMetadata" on-joinon-selected="save">
                </ecosis-metadata-join-panel>
            </div>
          </div>
        </div>
      </div>

      <!-- Ignore -->
      <div class="form-horizontal">
        <div class="form-group">

          <label for="inputIgnore" class="col-md-2 control-label">Ignore</label>
          <div class="col-md-10">
            <div class="checkbox">
              <label>
                <input id="inputIgnore" type="checkbox" on-change="onIgnoreUpdate"> This sheet should not be parsed.
              </label>
            </div>
          </div>

        </div>
      </div>

      <!-- Datasheet Orientation -->
      <div class="form-horizontal" id="orientationPanel">
        <div class="form-group">

          <label class="col-md-2 control-label">Orientation</label>
          <div class="col-md-10">
            <div class="radio">
              <label>
                <input type="radio" id="columnInput" value="column" checked="" on-click="onOrientationChange">
                My observations are by column.
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" id="rowInput" value="row" on-click="onOrientationChange">
                My observations are by row.
              </label>
            </div>

            <a on-click="toggleHelp" style="cursor:pointer">Format Help.</a>
            <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>
          </div>

        </div>
      </div>

      <!-- Datasheet Seperator -->
      <div class="form-horizontal" id="seperatorPanel" style="display:none">
        <div class="form-group">

            <label class="col-md-2 control-label">File Seperator</label>
            <div class="col-md-10">
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="commaInput" value="," checked="" on-click="onSeperatorChange">
                  Comma
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="tabInput" value="tab" on-click="onSeperatorChange">
                  Tab
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="semicolonInput" value=";" on-click="onSeperatorChange">
                  Semicolon
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" class="orientation-radio" id="otherInput" value="other" on-click="onSeperatorChange">
                  Other
                  <input type="text" id="otherSeperatorInput" on-blur="onSeperatorChange">
                </label>
              </div>
            </div>

            <a on-click="toggleHelp" style="cursor:pointer">Format Help.</a>
            <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>
          </div>
        </div>

      <div id="updatingPanel" class="alert alert-warning" style="display:none">
        <h6 style="color:white"><i class="fa fa-spinner fa-spin"></i> Updating...</h6>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-panel',

    ready : function() {
      this.sheet = null;
    },

    update : function(resource, datasheet) {
      this.resource = resource;
      this.sheet = datasheet;
    },

    save : function() {
      this.setSaving(true);

      var options = {
        layout : this.sheet.layout,
        metadata : this.sheet.metadata,
        ignore : this.sheet.ignore,
        joinOn : this.sheet.joinOn
      }

      if( this.sheet.seperator ) {
        options.seperator = this.sheet.seperator;
      }

      ecosis.ckan.processResource(
          ecosis.ds.package_id,
          this.sheet.resourceId,
          this.sheet.sheetId,
          options,
          function(resp){


            if( Array.isArray(resp) ) {
              resp = resp[0];
            }

            this.setSaving(false);

            if( resp.error ) {
              // ERROR 16
              resp.code = 16;
              resp.message += '.  Error updating datasheet.';
              return ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
            }

            this.sheet = resp;
            ecosis.ds.setSheet(resp);

            ecosis.ds.fireUpdate();

            this.$.preview.update(this.sheet);

            this.updateMetadataUi();
            this.updateIgnoreUi();

            this.fire('sheet-update', {
              id : resp.resourceId,
              sheetId : resp.sheetId
            });
          }.bind(this)
      );
    },

    edit : function(callback) {
      // set title
      if( this.resource.datasheets.length == 1 ) {
        var title = this.sheet.name;
        if( this.sheet.sheetId ) title += ' ('+this.sheet.sheetId+')';
        this.$.titleLabel.innerHTML = title;
      } else { // title is shown by dropdown
        this.$.titleLabel.innerHTML = '';
      }

      this.$.preview.update(this.sheet);

      // show parse error
      if( this.sheet.error ) this.$.parseError.style.display = 'block';
      else this.$.parseError.style.display = 'none';

      // should we show the metadata selection
      if( this.sheet.ignore ) this.$.metadataSelectPanel.style.display = 'none';
      else this.$.metadataSelectPanel.style.display = 'block';


      // set the correct layout
      if( this.sheet.layout == 'column' ) {
        $(this.$.columnInput).prop('checked', true);
        $(this.$.rowInput).prop('checked', false);
      } else {
        $(this.$.columnInput).prop('checked', false);
        $(this.$.rowInput).prop('checked', true);
      }

      this.updateMetadataUi();
      this.updateIgnoreUi();
      this.updateSeperatorUi();

      // see if there are repeats
      if( this.sheet.repeatAttributes && !this.sheet.ignore) {
        var html = '<b>Warning.</b> You have repeat '+(this.layout === 'column' ? 'row' : 'column') +' attribute headers:';

        html += '<ul>';
        this.sheet.repeats.forEach(function(repeat){
          html += '<li>'+repeat+'</li>';
        });
        html += '</ul>';

        html += 'Possible solutions.  You may not have the sheet orientation set correctly.  Or you may have multiple attributes '+
                'defined with ().  Remember, units are specified by () and anything between parentheses will be removed from the '+
                'name and considered units for the attribute.';

        this.$.repeatsWarning.innerHTML = html;
        this.$.repeatsWarning.style.display = 'block';
      } else {
        this.$.repeatsWarning.style.display = 'none';
      }

      if( callback ) callback();
    },

    updateMetadataUi : function() {
      if( this.sheet.metadata) {
        this.$.joinMetadata.update(this.sheet, this.resource);
        this.$.joinMetadataOuter.style.display = 'block';
        $(this.$.inputIsMetadata).prop('checked', true);
      } else {
        this.$.joinMetadataOuter.style.display = 'none';
        $(this.$.inputIsMetadata).prop('checked', false);
      }
    },

    updateIgnoreUi : function() {
      var panels = ['orientationPanel', 'metadataSelectPanel'];

      if( this.sheet.ignore ) {
        panels.forEach(function(id){
          this.$[id].style.display = 'none';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', true);
        this.$.preview.style.display = 'none';
      } else {
        panels.forEach(function(id){
          this.$[id].style.display = 'block';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', false);
        this.$.preview.style.display = 'block';
      }
    },

    updateSeperatorUi : function() {
      if( !this.sheet.isCSV ) {
        this.$.seperatorPanel.style.display = 'none';
        return;
      }

      this.$.seperatorPanel.style.display = 'block';
      $(this).find('.orientation-radio').prop('checked', false);
      this.$.otherSeperatorInput.value = '';

      if( !this.sheet.seperator ) {
        this.$.commaInput.checked = true;
        return;
      }

      var options = [',', 'tab', ';'];
      if( options.indexOf(this.sheet.seperator) > -1 ) {
        $(this).find('[value="'+this.sheet.seperator+'"]').prop('checked', true);
        return;
      }

      this.$.otherInput.checked = true;
      this.$.otherSeperatorInput.value = this.sheet.seperator;
    },

    onOrientationChange : function(e) {
      this.sheet.layout = e.currentTarget.value;
      if( this.sheet.layout == 'column' ) {
        $(this.$.rowInput).prop('checked', false);
      } else {
        $(this.$.columnInput).prop('checked', false);
      }

      this.save();
    },

    onSeperatorChange : function(e) {
      var ele = e.currentTarget;

      if( ele.getAttribute('type') == 'radio' ) {
        $(this).find('.orientation-radio').prop('checked', false);
        $(ele).prop('checked', true);
      }

      var val = e.currentTarget.value;
      if( val === 'other' ) {
        val = this.$.otherSeperatorInput.value;
      }

      if( !val ) return;

      this.sheet.seperator = val;
      this.save();
    },

    toggleHelp : function() {
      $(this.$.formatHelp).toggle();
    },

    loadFullDatasheet : function(callback) {

      for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
        var sheet = ecosis.ds.datasheets[i];
        if( this.sheetId ) {
          if( sheet.resourceId == this.resourceid && sheet.sheetId == this.sheetId ) {
            this.sheet = sheet;
            break;
          }
        } else if( sheet.resourceId == this.resourceid ) {
          this.sheet = sheet;
        }
      }

      this.edit();

      if( callback ) callback();
    },

    setLoading : function(loading) {
      if( loading ) {
        this.$.main.style.display = 'none';
        this.$.loading.style.display = 'block';
      } else {
        this.$.main.style.display = 'block';
        this.$.loading.style.display = 'none';
      }
    },

    onMetadataPanelUpdate : function(e) {
      if( e.detail.updating ) {
        this.$.inputIsMetadata.setAttribute('disabled', '');
        this.$.inputIgnore.setAttribute('disabled', '');
      } else {
        this.$.inputIsMetadata.removeAttribute('disabled');
        this.$.inputIgnore.removeAttribute('disabled');
      }
    },

    onMetadataUpdate : function() {
      if( $(this.$.inputIsMetadata).is(':checked') ) {
        this.sheet.metadata = true;
        this.fire('type-change', {type: 'metadata'});
      } else {
        this.sheet.metadata = false;
        this.fire('type-change', {type: 'data'});
      }

      this.save();
    },

    onIgnoreUpdate : function() {
      if( $(this.$.inputIgnore).is(':checked') ) {
        this.sheet.ignore = true;
      } else {
        this.sheet.ignore = false;
      }

      this.save();
    },

    setSaving : function(saving) {
      this.$.updatingPanel.style.display = saving ? 'block' : 'none';

      if( saving ) {
        $(this).find('input').attr('disabled', '');
      } else {
        $(this).find('input').removeAttr('disabled');
      }
    }
  });
</script>
<dom-module id="ecosis-resource-panel">
  <style>
    :host {
      display: block;
    }
    a.btn-link {
      padding-top: 0;
    }
    span.label-danger {
      box-shadow: 0 0 5px white;
      border: 1px solid white;
    }
    input[type="checkbox"]:after {
      border: 2px solid white !important;
    }
    .alert-primary {
      background-color: #2196f3;
    }
    .alert-default {
      background-color: #888;
    }
  </style>

  <template>
    <template id="singleResource" is="dom-template">
      <div class="alert alert-default" id="root">
          <div class="layout horizontal">
            <div class="flex">
              <input type="checkbox" id="select" on-click="fireSelectEvent">
              <span id="titleLabel"></span>
              <a class="btn btn-link" style="color:white" on-click="delete" id="trashBtn"><i class="fa fa-trash"></i></a>
              <span class="label label-danger" id="deletePanel" style="display:none">
                <i class="fa fa-spinner fa-spin"></i> Deleting Resource...
              </span>
            </div>
            <div>
              <a class="btn btn-link" style="color:white" id="downloadBtn" target="_blank"><i class="fa fa-download"></i></a>

              <a class="btn btn-link" style="color:white" id="editLink" on-click="toggleEdit">
                <i class="fa fa-pencil" id="editLinkIcon"></i>
              </a>
            </div>
          </div>
      </div>
    </template>

    <template id="zipResource" is="dom-template">
      <div class="panel panel-warning" id="root">
        <div class="panel-heading">
          <div class="layout horizontal">
            <div class="flex">
              <input type="checkbox" id="select" on-click="fireSelectEvent">

              <span id="titleLabel"></span>

              <a class="btn btn-link" style="color:white" on-click="delete" id="trashBtn"><i class="fa fa-trash"></i></a>

              <span class="label label-danger" id="deletePanel" style="display:none">
                <i class="fa fa-spinner fa-spin"></i> Deleting Resource...
              </span>
            </div>
            <div>
              <a class="btn btn-link" style="color:white" id="downloadBtn" target="_blank"><i class="fa fa-download"></i></a>
            </div>
          </div>
        </div>
        <div class="panel-body">
          <ecosis-isotope id="zipResources" selector=".zip-item"></ecosis-isotope>
        </div>
      </div>
    </template>

    <div id="templateRoot"></div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-resource-panel',

    properties : {
      resourceid : {
        type : String
      }
    },

    ready : function() {
      this.datatypes = ['xls','xlsx','csv','tsv','spectra'];
      this.edit = false;
      this.resource = null;
    },

    attached : function() {
      if( !this.resourceid ) return;

      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        if( this.resourceid == resource.id ) {
          this.resource = resource;
          break;
        }
      }

      this.update();
    },

    updateNameLabel : function() {
      var parseInfo = '';
      if( this.resource.datasheets && this.resource.datasheets.length == 1 ) {
        var sheet = this.resource.datasheets[0];
        if( !sheet.ignore && sheet.name) {
          if( sheet.name.match(/(spectra|csv|tsv)$/i) ){
            parseInfo = ' ('+(this.resource.datasheets[0].layout || 'row')+'/'+(this.resource.datasheets[0].seperator || 'comma')+')';
          }
        }
      }

      this.querySelector('#titleLabel').innerHTML = this.resource.name+parseInfo;
    },

    update : function() {
      this.setAttribute('data-name', this.resource.name);

      if( this.resource.isZip ) {
        this.ele = this.$.zipResource.stamp();
      } else {
        this.ele = this.$.singleResource.stamp();
      }
      this.$.templateRoot.innerHTML = '';
      this.$.templateRoot.appendChild(this.ele.root);


      this.setClass();

      if( !this.resource.datasheets ) {
        this.querySelector('#trashBtn').style.color = '#333';
      }

      if( this.resource.fromZip ) {
        this.querySelector('#select').style.display = 'none';
      }

      // hide edit button if invalid file type
      if( this.resource.datasheets && this.resource.datasheets.length > 0 && this.resource.datasheets[0].invalidFileType ) {
        var link = this.querySelector('#editLink');
        if( link ) link.style.display = 'none';
      } else {
        var link = this.querySelector('#editLink');
        if( link ) link.style.display = 'inline-block';
      }

      this.updateNameLabel();

      if( this.resource.childResources ) {
        this.isotope = this.querySelector('#zipResources');
        this.isotope.clear();

        for( var i = 0; i < this.resource.childResources.length; i++ ) {
          var ele = document.createElement('ecosis-resource-panel');
          ele.style.width = '100%';
          ele.className = 'zip-item';
          ele.resource = this.resource.childResources[i]; // manually set
          this.isotope.append(ele);
          ele.update();
        }

        this.isotope.init();
      }

      var url = ecosis.ckan.host+'/dataset/'+this.resource.package_id+'/resource/'+this.resource.id+'/download/'+this.resource.name;

      this.querySelector('#downloadBtn').setAttribute('href', url);
    },

    sort : function(sortBy) {
      if( !this.isotope ) return;
      this.isotope.sort(sortBy);
    },

    filter : function(filter) {
      if( !this.isotope ) return;
      this.isotope.filter(filter);
    },

    setClass : function() {
      var type = this.getResourceType();

      // update icons as well;
      if( this.resource.fromZip ) {
        this.querySelector('#trashBtn').style.display = 'none';
        this.querySelector('#downloadBtn').style.display = 'none';
      } else {
        this.querySelector('#trashBtn').style.display = 'inline-block';
        this.querySelector('#downloadBtn').style.display = 'inline-block';
      }

      // update css class
      if( this.resource.isZip ) {
        this.setAttribute('data-type', 'zip');
        return;
      }

      var className = this.getPanelClass(type);
      this.querySelector('#root').className = 'style-scope ecosis-resource-panel alert alert-'+className;
      this.setAttribute('data-type', className);
    },

    getPanelClass : function(type) {
      if( type == 'data' ) return 'success';
      if( type == 'metadata' ) return 'primary';
      if( type == 'multi' ) return 'info';
      return 'default';
    },

    getResourceType : function() {
      if( this.resource.datasheets && this.resource.datasheets.length == 1 ) {
        if( this.resource.datasheets[0].ignore ) {
          return 'ignored';
        } else if( this.resource.datasheets[0].metadata ) {
          return 'metadata';
        } else {
          return 'data';
        }
      } else if( this.resource.datasheets && this.resource.datasheets.length > 1 ) {
        return 'multi';
      }

      return 'ignored';
    },

    toggleEdit : function() {
      var resourcePopup = document.querySelector('#resourcePopup');

      resourcePopup.edit(this.resource, {
        onDatasheetUpdate : function() {
          this.setClass();
          this.updateNameLabel();
        }.bind(this)
      });

      this.edit = !this.edit;

      this.fire('editing', this.resourceid);
    },

    fireSelectEvent : function() {
      this.fire('resource-select');
    },

    select : function(select) {
      if( select ) $(this).find('#select').prop('checked', true);
      else $(this).find('#select').prop('checked', false);
    },

    isSelected : function() {
      return $(this).find('#select').is(':checked');
    },

    delete : function() {
      if( !confirm("Are you sure you want to remove: "+this.resource.name+"?") ) return;
      this.forceDelete();
    },

    forceDelete : function() {
      this.querySelector('#deletePanel').style.display = 'inline-block';

      ecosis.ckan.removeResource(this.resource.id,
        function(resp){
          this.querySelector('#deletePanel').style.display = 'block';

          if( resp.error ) {
            // ERROR 17
            resp.code = 17;
            resp.message += '. Server error deleting resource.';
            return ecosis.errorPopup.show(resp);
          }

          for( var i = ecosis.ds.resources.length-1; i >= 0; i-- ) {
            var r = ecosis.ds.resources[i];

            if( r.id == this.resourceid ) {
              ecosis.ds.resources.splice(i, 1);
            } else if ( r.zip && r.zip.resourceId == this.resourceid  ) {
              ecosis.ds.resources.splice(i, 1);
            }
          }
          ecosis.ds.fireUpdate();

          ecosis.ds.deleteResourceTime = new Date();
          ecosis.ds.checkChanges();

          var ele = this;
          $(this).hide('slow', function(){
            $(this).detach();
            ele.fire('update', ele.resourceid);
          });


        }.bind(this)
      );
    }
  });
</script>


<dom-module id="ecosis-sheet-preview">
  <style>
    :host {
      display: block
    }
    .info {
      margin-top: 10px !important;
    }
  </style>

  <template>
    <span class="pull-right label label-warning" id="loading" style="display:none"><i class="fa fa-spin fa-circle-o-notch"></i> Loading...</span>
    <h4 class="info page-header" id="info"></h4>

    <div id="nodata" style="display:none" class="text text-warning">
      No data in this sheet.
    </div>

    <div id="data">
      <div class="layout horizontal center">
          <a class="btn btn-default" id="leftArrow" on-click="moveLeft"><i class="fa fa-arrow-left"></i></a>

          <div class="flex" id="columnPreview" style="overflow:hidden">
            <div class="row">
              <div class="col-sm-6">
                <div id="columnTableRoot" style="height: 300px; overflow:auto; margin-left: 10px"></div>
              </div>
              <div class="col-sm-6" id="columnChartRoot" style="height: 300px"></div>
            </div>
          </div>

          <div class="flex" id="rowPreview" style="overflow:hidden">
            <div id="rowTableRoot" style="overflow:auto; margin-bottom: 35px"></div>
            <div id="rowChartRoot" style="height: 200px; margin: 25px 0 15px 0"></div>
          </div>

          <a class="btn btn-default" id="rightArrow" on-click="moveRight"><i class="fa fa-arrow-right"></i></a>
      </div>

      <div id="sliderRoot" style="margin-top: 15px"></div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : "ecosis-sheet-preview",

    ready : function() {
      this.index = 0;
    },

    load : function(index) {
      if( index !== undefined ) this.index = index;

      if( this.index >= this.info.total ) {
        this.index = this.info.total-1;
      }
      if ( this.index < 0 ) {
        this.index = 0;
      }

      this.slider.slider('setValue', this.index+1);

      if( this.info.total == 0 ) {
        this.$.nodata.style.display = 'block';
        this.$.data.style.display = 'none';
        return;
      } else {
        this.$.nodata.style.display = 'none';
        this.$.data.style.display = 'block';
      }

      // this.$.info.innerHTML = '<i class="fa fa-spin fa-circle-o-notch"></i> Loading index: '+this.index;
      this.loading(true);

      if( this.sheet.metadata ) {
        ecosis.ckan.getMetadataChunk(
          this.sheet.packageId,
          this.sheet.resourceId,
          this.sheet.sheetId,
          this.index,
          this.renderMetadataResp.bind(this)
        );
      } else {
        ecosis.ckan.getSpectra(
          this.sheet.packageId,
          this.sheet.resourceId,
          this.sheet.sheetId,
          this.index,
          this.renderSpectraResp.bind(this)
        );
      }
    },

    renderMetadataResp : function(resp) {
      this.loading(false);
      if( resp.error ) {
        // ERROR 18
        resp.code = 18;
        return ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
      }


      this.renderTable(resp.metadata);
      var layout = this.sheet.layout || 'row';

      if( resp.joinKey && resp.metadata[resp.joinKey] ) {
        var joined = 'None';
        if( resp.joinedResources.length > 0 ) {
          joined = '';
          for( var i = 0; i < resp.joinedResources.length; i++ ) {
            joined += resp.joinedResources[i].name + (resp.joinedResources[i].sheetId ? ' - '+resp.joinedResources[i].sheetId.split('-')[1]+'' : '')+
              ' on '+(resp.joinedResources[i].layout || 'row')+' '+resp.joinedResources[i].index;
            if( i < resp.joinedResources.length-1 ) joined += ', ';
          }
        }

        this.$[layout+'ChartRoot'].innerHTML =
          '<h4 style="text-align:center">Joined On:</h4> '+
          '<h5 style="text-align:center">'+resp.joinKey+' = <span style="color:#888">'+resp.metadata[resp.joinKey]+'</span></h5>'+
          '<h4 style="text-align:center">Matches:</h4>'+
          '<h6 style="text-align:center; color:#888">'+joined+'</h6>';
      } else {
        this.$[layout+'ChartRoot'].innerHTML = '<div style="text-align:center" class="text text-warning"><i class="fa fa-warning"></i> No join key provided, please select one below</div>'
      }

      this.$.info.innerHTML =
        '<i class="fa fa-binoculars"></i> <span style="text-transform:capitalize">'+this.sheet.layout+'</span> Preview <small><b>'+(this.index+1)+'</b> of <b>'+this.info.total+'</b></small> '+
        '<small class="pull-right">Join Count: '+this.info.joinCount+'</small>';
    },

    renderSpectraResp : function(resp) {
      this.loading(false);
      if( resp.error ) {
        // ERROR 19
        resp.code = 19;
        ecosis.errorPopup.show(resp, document.querySelector('ecosis-resource-popup').popup);
      }

      this.renderTable(resp, ['ecosis', 'datapoints']);
      var layout = this.sheet.layout || 'row';

      if( !(this.$[layout+'ChartRoot'].firstChild && this.$[layout+'ChartRoot'].firstChild.nodeName.toLowerCase() == 'ecosis-chart') ) {
        this.$[layout+'ChartRoot'].innerHTML = '<ecosis-chart></ecosis-chart>';
      }

      this.$.info.innerHTML = '<i class="fa fa-binoculars"></i> <span style="text-transform:capitalize">'+this.sheet.layout+'</span> Preview <small> <b>'+(this.index+1)+'</b> of <b>'+this.info.total+'</b></small>';

      var data = [];
      for( var key in resp.datapoints ) {
          data.push([
              parseFloat(key),
              parseFloat(resp.datapoints[key])
          ])
      }

      data.sort(function(a, b){
          if( a[0] > b[0] ) return 1;
          if( a[0] < b[0] ) return -1;
          return 0;
      });

      data.splice(0, 0, ['Wavelength', '']);

      // HACK:  FF seems to be slow upgrading the <ecosis-chart /> element :(
      setTimeout(function(){
        this.$[layout+'ChartRoot'].firstChild.setHeight(layout === 'row' ? 200 : 300);
        this.$[layout+'ChartRoot'].firstChild.options = {
          animation:{
            duration: 700,
            easing: 'out',
          }
        }
        this.$[layout+'ChartRoot'].firstChild.setData(data);
      }.bind(this), 200)

    },

    initSlider : function() {
      this.$.sliderRoot.innerHTML = '<input id="slider" style="width:100%" data-slider-id="ex1Slider" type="text"'+
        ' data-slider-min="1" data-slider-max="'+this.info.total+'" data-slider-step="1" data-slider-value="'+this.index+'"/>';

      this.$.slider = this.querySelector('#slider');
      this.slider = $(this.$.sliderRoot.firstChild).slider({});
      $(this.$.slider).parent().width('100%');

      var updateTimer = -1;

      this.slider.on('slideStop', function(e){
        if( updateTimer != -1 ) clearTimeout(updateTimer);
        updateTimer = setTimeout(function(){
          updateTimer = -1;
          this.load(e.value-1);
        }.bind(this), 100);
      }.bind(this));
    },

    getUnitsLabel : function(attr) {
      var units;
      if( this.sheet.units ) {
        if( this.sheet.units[attr] ) {
          units = this.sheet.units[attr];
        }
      }

      if( !units && this.units ) {
        if( this.units[attr] ) {
          units = this.units[attr];
        }
      }

      if( !units ) return '';

      return ' <span style="color:#aaa;font-size: 80%;font-weight:normal">('+units+')</span>';
    },

    setAllUnits : function(metadata) {
      this.units = null;
      if( !ecosis.ds.datasheets ) return;

      this.units = {};
      for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
        if( ecosis.ds.datasheets[i].units ) {
          var u = ecosis.ds.datasheets[i].units;
          for( var key in u ) {
            this.units[key] = u[key];
          }
        }
      }
    },

    renderTable : function(metadata, ignorelist) {
      if( ignorelist === undefined ) ignorelist = [];

      var layout = this.sheet.layout || 'row';
      var table = '<h5>Metadata</h5><table class="table">';

      if( this.sheet.layout === 'column' ) {
        var c = 0;
        for( var key in metadata ) {
          if( ignorelist.indexOf(key) > -1 ) continue;

          var units = this.getUnitsLabel(key);
          table += '<tr><td><span style="font-weight:bold">'+key+units+'</span></td><td>'+metadata[key]+this.getProcessInfo(key, metadata)+'</td></tr>';

          c++;
          if( c == 100 ) {
            table += '<tr><td>...</td><td>...</td></tr>';
            break;
          }
        }
      } else {
        var c = 0;
        var header = '<tr>';
        var data = '<tr>';
        for( var key in metadata ) {
          if( ignorelist.indexOf(key) > -1 ) continue;

          var units = this.getUnitsLabel(key);
          header += '<th style="white-space:nowrap">'+key+units+'</th>';
          data += '<td style="white-space:nowrap; max-width: 250px; overflow:auto">'+metadata[key]+this.getProcessInfo(key, metadata)+'</td>';

          c++;
          if( c == 100 ) {
            header += '<td>...</td>';
            data += '<td>...</td>';
            break;
          }
        }
        table += header+'</tr>'+data+'</tr>';
      }


      this.$[layout+'TableRoot'].innerHTML = table+'</table>';

      $(this.$[layout+'TableRoot']).find('[data-toggle="tooltip"]').tooltip()
    },

    getProcessInfo : function(key, metadata) {
      if( !metadata.ecosis ) return '';
      if( !metadata.ecosis.processInfo ) return '';

      var matches = [];
      for( var i = 0; i < metadata.ecosis.processInfo.length; i++ ) {
        if( metadata.ecosis.processInfo[i].key == key ) {
          matches.push(metadata.ecosis.processInfo[i]);
        }
      }

      if( matches.length == 0 ) return '';

      var resp = '';
      for( var i = 0; i < matches.length; i++ ) {
          resp += this.getProcessMessage(matches[i]);
      }
      return resp;
    },

    getProcessMessage : function(info) {
      var header = '<div style="font-size:11px;color:#999;font-style:italic">';
      var footer = '</div>';

      header = '<a style="cursor:pointer" data-toggle="tooltip" data-placement="bottom" data-original-title="';
      footer = '">*</a>';

      if( info.type == 'join' ) {
        try {
          var name = ecosis.ds.resourceLookup[info.resourceId].name;
          return header+'Joined from '+name+(info.sheetId ? ' ('+info.sheetId.split('-')[1]+')' : '')+footer;
        } catch(e) {}
      } else if ( info.type == 'usda lookup') {
        return header+'Appended from USDA Symbol'+footer;
      } else if ( info.type == 'mapped') {
        return header+'Mapped from '+info.from+footer;
      }

      return '';
    },

    update : function(sheet, autoUpdateUnits) {
      if( sheet ) {
        this.sheet = sheet;
      }

      this.setAllUnits();

      if( this.sheet.ignore ) return;

      if( this.sheet.layout === 'column' ) {
        this.$.columnPreview.style.display = 'block';
        this.$.rowPreview.style.display = 'none';
        this.$.leftArrow.querySelector('i').className = 'fa fa-arrow-left';
        this.$.rightArrow.querySelector('i').className = 'fa fa-arrow-right';
      } else {
        this.$.columnPreview.style.display = 'none';
        this.$.rowPreview.style.display = 'block';
        this.$.leftArrow.querySelector('i').className = 'fa fa-arrow-up';
        this.$.rightArrow.querySelector('i').className = 'fa fa-arrow-down';
      }

      if( this.sheet.metadata ) {
        this.updateMetadata();
      } else {
        this.updateSpectra();
      }
    },

    updateMetadata : function() {
      ecosis.ckan.getMetadataInfo(this.sheet.packageId, this.sheet.resourceId, this.sheet.sheetId, function(resp){
        this.loading(false);
        this.info = resp;
        this.initSlider();
        this.load();
      }.bind(this));
    },

    updateSpectra : function() {
      ecosis.ckan.getSpectraCount(this.sheet.packageId, this.sheet.resourceId, this.sheet.sheetId, function(resp){
        this.loading(false);
        this.info = resp;
        this.initSlider();
        this.load();
      }.bind(this));
    },

    loading : function(loading) {
      if( loading ) this.$.loading.style.display = 'inline-block';
      else this.$.loading.style.display = 'none';
    },

    moveLeft : function() {
      this.index--;
      this.load();
    },

    moveRight : function() {
      this.index++;
      this.load();
    }

  })
</script>

<dom-module id="ecosis-resource-popup">
  <template>
    <div class="modal fade" id="popup">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>
            <h4 class="modal-title" id="title"></h4>
          </div>
          <div class="modal-body" style="padding: 25px">
            <ecosis-datasheet-select-panel style="display:none" id="datasheetSelector" on-select="onDatasheetSelected">
            </ecosis-datasheet-select-panel>

            <ecosis-datasheet-panel id="datasheetUI" on-sheet-update="onDatasheetUpdate">
            </ecosis-datasheet-panel>
          </div>
          <div class="modal-footer">
            <div class="singleMode">
              <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            </div>
            <div class="wizardMode">
              <div class="layout horizontal">
                <div>
                  <button type="button" id="prev" class="btn btn-default" on-click="prev">Previous</button>
                </div>
                <div class="flex" style="text-align:center">
                  <button type="button" class="btn btn-primary" data-dismiss="modal">Finished</button>
                </div>
                <div>
                  <button type="button" id="next" class="btn btn-default" on-click="next">Next</button>
                </div>
              </div>
            </div>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-resource-popup',

    ready : function() {
      this.popup = $(this.$.popup);
      this.popup.remove();
      $('body').append(this.popup);

      this.popup.modal({
        show: false,
        backdrop : 'static'
      });
    },

    next : function() {
      this.index++;
      if( this.index > this.resources.length-1 ) {
        this.index = this.resources.length - 1;
        return;
      }
      this.updateNav();
      this.show(this.resources[this.index]);
    },

    prev : function() {
      this.index--;
      if( this.index < 0 ) {
        this.index = 0;
        return;
      }
      this.updateNav();
      this.show(this.resources[this.index]);
    },

    updateNav : function() {
      if( this.index == 0 ) this.$.prev.setAttribute('disabled','disabled');
      else this.$.prev.removeAttribute('disabled');

      if( this.index >= this.resources.length-1 ) this.$.next.setAttribute('disabled','disabled');
      else this.$.next.removeAttribute('disabled');
    },

    setMode : function(mode) {
      if( mode === 'single' ) {
        $(this.$.popup).find('.singleMode').show();
        $(this.$.popup).find('.wizardMode').hide();
      } else {
        $(this.$.popup).find('.singleMode').hide();
        $(this.$.popup).find('.wizardMode').show();
      }
    },

    uploadWizard : function(resources, handlers ) {
      this.setMode('wizard');
      this.resources = resources;
      this.index = 0;
      this.updateNav();
      this.handlers = handlers;
      this.show(resources[0]);
    },

    edit : function(resource, handlers) {
      this.setMode('single');
      this.handlers = handlers;
      this.show(resource);
    },

    show : function(resource) {
      this.resource = resource;

      this.$.title.innerHTML = this.resource.name;

      if( !this.resource.datasheets ) {
        this.$.datasheetSelector.style.display = 'none';
      } else if( this.resource.datasheets.length <= 1 ) {
        this.$.datasheetSelector.style.display = 'none';
      } else {
        this.$.datasheetSelector.style.display = 'block';
        this.$.datasheetSelector.update(this.resource);
      }

      this.selectDatasheet(0);

      this.popup.modal('show');
    },

    onDatasheetUpdate : function() {
      this.$.datasheetSelector.updateClass();
      if( this.handlers ) this.handlers.onDatasheetUpdate();
    },

    selectDatasheet : function(index, edit) {
      // required for datasheet display
      if( this.resource.name.match(/\.csv$/i) || this.resource.name.match(/\.spectra$/i) ) {
        this.resource.datasheets[index].isCSV = true;
      } else {
        this.resource.datasheets[index].isCSV = false;
      }

      // set the resource and sheet we are going to render
      this.$.datasheetUI.update(this.resource, this.resource.datasheets[index]);
      this.$.datasheetUI.edit();
    },

    onDatasheetSelected : function(e) {
      this.selectDatasheet(e.detail, true);
    }
  })
</script>

<dom-module id="ecosis-error-popup">
  <template>
    <div class="modal fade" id="popup" style="z-index: 10000">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close singleMode" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>
            <h4 class="modal-title text text-danger">Oooh no, badness :(</h4>
          </div>

          <div class="modal-body" style="padding: 0 25px">
            <h5 class="text text-danger">Error: <span id="message"></span></h5>

            <div id="report" style="margin: 50px 15px 20px 15px">
              Please help us fix bugs by reporting them
              <a href="https://github.com/CSTARS/ckanext-ecosis/issues/new" target="_blank">here on GitHub</a>!
              <br><b>Copy and paste</b> message below into GitHub Issue:
            </div>
            <div class="well">
              <div> - <b>Package ID:</b> <span id="project"></span></div>
              <div> - <b>Message:</b> <span id="message2"></span></div>
              <div> - <b>Code:</b> <span id="code"></span></div>
              <div> - <b>User Agent:</b> <span id="useragent"></span></div>
              <div id="gitInfo"></div>
              <div>[Any Additional Info Here]</div>
            </div>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->

  </template>

  <script>
    Polymer({
      is : "ecosis-error-popup",

      ready : function() {
        this.popup = $(this.$.popup);
        this.popup.remove();
        $('body').append(this.popup);

        this.popup.on('hidden.bs.modal', function(){
          if( this.priorPopup ) this.priorPopup.modal('show');
        }.bind(this));

        this.popup.modal({
          show: false,
          backdrop : 'static'
        });
      },

      show : function(e, popup) {
        this.priorPopup = popup;
        if( popup ) {
          popup.modal('hide');
          setTimeout(function(){
            this._show(e);
          }.bind(this), 350);
        } else {
          this._show(e);
        }
      },

      _show : function(e) {
        var msg = '';
        if( e.details && e.details.message ) {
          msg = e.details.message;
        }

        this.$.message.innerHTML = msg || e.message || '';
        this.$.message2.innerHTML = e.message || '';
        this.$.project.innerHTML = ecosis.ds.package_id;
        this.$.code.innerHTML = e.code || -1;
        this.$.useragent.innerHTML = navigator.userAgent;

        var html = '';
        if( ecosis.git ) {
          for( var key in ecosis.git ) {
            html += '<div> - <b>'+key+':</b> '+ecosis.git[key]+'</div>';
          }
          html += '<br />';
        }
        this.$.gitInfo.innerHTML = html;

        this.popup.modal('show');
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-upload-splash">
  <template>
    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-body" style="padding: 25px">

            <div class="alert alert-success"><h5 style="color:white">Upload Complete!</h5></div>

            <div style="text-align:center" id="hasResources">
              <h3><i class="fa fa-cogs"></i> Configure Resources</h3>

              <div style="margin: 10px 0 30px 0">
                You will now have a chance to configure your uploaded resources.
              </div>
            </div>

            <div style="text-align:center">
              <a class="btn btn-default btn-lg" on-click="hide">Continue</a><a>
            </a></div><a>


          </a></div><a>
        </a></div><!-- /.modal-content --><a>
      </a></div><!-- /.modal-dialog --><a>
    </a></div><!-- /.modal --><a>

  </a></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-upload-splash',

    ready : function() {
      this.popup = $(this.$.popup);
      this.popup.remove();
      $('body').append(this.popup);

      this.popup.modal({
        show: false,
        backdrop : 'static'
      });

      this.popup.on('hidden.bs.modal', function(){
        if( this.resources.length == 0 ) return;
        this.wizard.uploadWizard(this.resources, this.handlers);
      }.bind(this));

      this.wizard = document.querySelector('ecosis-resource-popup');
    },

    show : function(resources, handlers) {
      this.resources = resources;
      this.handlers = handlers;

      if( resources.length == 0 ) {
        this.$.hasResources.style.display = 'none';
      } else {
        this.$.hasResources.style.display = 'block';
      }

      this.popup.modal('show');
    },

    hide : function() {
      this.popup.modal('hide');
    }
  });
</script>

<dom-module id="ecosis-chart">
  <style>
    :host {
        display: block;
    }
  </style>

  <template>
    <div id="root" style="height:400px"></div>

    <div id="noData" style="color:#888">
      No spectral data to chart.
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-chart',

    properties : {
      animate : {
          type : Boolean,
          value : false
      },
      type : {
        type : String
      }
    },

    ready : function() {
      this.dt = null;
      this.chart = null;
      this.height = 400;

      this.updateTimer = -1;

      this.onLoadHandlerSet = false;

      this.options = null;
      this.cols = null;

      $(window).on('resize', function(){
          this.redraw();
      }.bind(this));
    },

    setHeight : function(height) {
      this.height = height;
      this.$.root.style.height = height+'px';
    },

    setOnloadHandler : function() {
        if( this.onLoadHandlerSet ) return;

        // put in global scope by cwn-datastore
        chartLoadHandlers.push(function(){
            this.update();
        }.bind(this));
    },

    setData : function(data) {
      this.data = data;
      this.update();
    },

    update : function() {
        if( !window.google.visualization ) return this.setOnloadHandler();
        if( !window.google.visualization.LineChart ) return this.setOnloadHandler();

        if( this.isEmpty() ) {
          this.$.root.style.display = 'none';
          this.$.noData.style.display = 'block';
          return;
        }
        this.$.root.style.display = 'block';
        this.$.noData.style.display = 'none';

        if( !this.chart ) {
            if( this.type ) {
                this.chart = new google.visualization[this.type](this.$.root);
            } else {
                this.chart = new google.visualization.LineChart(this.$.root);
            }
        }

        if( this.updateTimer == -1 ) clearTimeout(this.updateTimer);
        this.updateTimer = setTimeout(function() {
            this.updateTimer = -1;
            this._update();
        }.bind(this), 500);
    },

    _update : function() {
        if( this.cols ) {
            this.dt = new google.visualization.DataTable();
            for( var i = 0; i < this.cols.length; i++ ) {
                this.dt.addColumn(this.cols[i]);
            }
            this.dt.addRows(this.data);
        } else {
            this.dt = google.visualization.arrayToDataTable(this.data);
        }

        this.redraw();
    },

    isEmpty : function() {
        if( !this.data ) {
            return true;
        }
        if( this.data.length < 2 ) {
            return true;
        }
        if( this.data[0].length == 0 ) {
            return true;
        }

        return false;
    },

    redraw : function() {
        if( !this.chart || !this.dt ) return;

        var options = {
            legend : {
                position : 'none'
            }
        };

        if( this.options ) {
            for( var key in this.options ) {
                options[key] = this.options[key];
            }
        }

        this.chart.draw(this.dt, options);
    }
  });
</script>

<dom-module id="ecosis-isotope">
  <template>
    <style>
      :host {
        display : block
      }
    </style>

    <div id="grid">
      <content></content>
    </div>
  </template>


  <script>
    Polymer({
      is : 'ecosis-isotope',

      properties : {
        selector : {
          type : String,
          value : ''
        }
      },

      clear : function() {
        this.$.grid.innerHTML = '';
      },

      append : function(child) {
        this.$.grid.appendChild(child);
      },

      init : function() {
        if( this.grid ) this.grid.isotope('destroy');

        this.grid = $(this.$.grid).isotope({
          // options
          itemSelector: this.selector,
          layoutMode: 'vertical',
          getSortData: {
            name: '[data-name]', // value of attribute
            type: '[data-type]'
          },
          sortAscending: true,
          sortBy : 'name'
        });

        setTimeout(function(){
          this.grid.isotope('updateSortData').isotope();
        }.bind(this), 500)
      },

      html : function(html) {
        this.$.grid.innerHTML = html;
        this.init();
      },

      sort : function(sortBy) {
        this.grid.isotope({sortBy : sortBy});
      },

      filter : function(filter) {
        this.grid.isotope({filter : filter});
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-doi">
  <template>
    <style>
      :host {
        display: block;
      }
      #panel {
        margin-bottom: 40px;
      }
      .alert.alert-warning {
        margin-top: 15px
      }
    </style>

    <h4 class="page-header">
      <a class="btn-toggle" on-click="toggleCat"><i class="fa fa-arrow-right"></i></a> Dataset DOI
    </h4>
    
    <div id="panel" style="display:none">

      <div id="needsData" class="subpanel">
        <div>To request a EcoSIS DOI you must enter the following metadata:</div>
        <table class="table" id="needsDataTable"></table>
        
        <div class="alert alert-warning">Warning: Once a DOI is applied, you can no longer make
          changes to the dataset.
        </div>
      </div>

      <div id="request" class="subpanel">
        <a class="btn btn-default btn-request" on-click="requestDoi">Request Dataset Doi</a>
        
        <div class="alert alert-warning">Warning: Once a DOI is applied, you will no longer be able to
          make changes to the dataset.  Make sure ALL data AND metadata is filled out, valid and complete
          before proceeding.
        </div>
      </div>


      <div id="requesting" class="subpanel">
        Your doi has been approved and a request is being made for the DOI.
      </div>

      <div id="pendingApproval" class="subpanel">
        Your dataset is pending review by a EcoSIS administrator.  The dataset author
        and maintainer will be notified when the dataset is approved or if more information
        is required.
        <br>
        <a class="btn btn-warning btn-request" on-click="cancelRequest">Cancel Doi Request</a>
        <div class="alert alert-warning">Warning: Once a DOI is applied, you will no longer be able to
          make changes to the dataset.  Make sure ALL data AND metadata is filled out, valid and complete
          before proceeding.
        </div>
      </div>

      <div id="pendingRevision" class="subpanel">
        Your dataset has been reviewed by a EcoSIS administrator and further updates
        are required for a DOI.

        If you are ready to re-submit your dataset, please click below.<br>
        <a class="btn btn-default btn-request" on-click="requestDoi">Resubmit Doi Request</a>
        <a class="btn btn-warning btn-request" on-click="cancelRequest">Cancel Doi Request</a>
        
        <div class="alert alert-warning">Warning: Once a DOI is applied, you will no longer be able to
          make changes to the dataset.  Make sure ALL data AND metadata is filled out, valid and complete
          before proceeding.
        </div>
      </div>

      <div id="accepted" class="subpanel">
        Your dataset has been approved for a DOI.  The DOI is being generated and
        should be assigned shortly.
      </div>

      <div id="applied" class="subpanel">
        <div><b>Dataset DOI:</b> <span id="appliedLabel"></span></div>
        <div id="devMsg" style="display:none">This is NOT a real DOI.  Only datasets in 
        production system (<a href="http://data.ecosis.org">data.ecosis.org</a>) will be given actual DOI numbers.</div>
      </div>
    
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-doi',

      setData : function(pkg) {
        this.pkg = pkg;
        this.pkg.on('save-end', this.render.bind(this));
        this.render();
      },
      
      requestDoi : function(e) {
         if( $(e.currentTarget).hasClass('disabled') ) {
           return;
         }
        
         if( this.pkg.requestDoi() ) {
           $(this)
            .find('.btn-request')
            .addClass('disabled')
            .attr('disabled', 'disabled');
         } else {
           $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');
         }
      },
      
      cancelRequest : function(e) {
         if( $(e.currentTarget).hasClass('disabled') ) {
           return;
         }
        
         if( this.pkg.cancelDoiRequest() ) {
           $(this)
            .find('.btn-request')
            .addClass('disabled')
            .attr('disabled', 'disabled');
         } else {
           $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');
         }
      },
      
      // re-render
      onGitInfoLoad : function() {
        this.render();
      },

      render : function() {
        if( !this.pkg ) return;
        
        var doi = this.pkg.getDoi();
        $(this).find('.subpanel').hide();
        
        if( ecosis.git && ecosis.git.branch !== 'master' ) {
          this.$.devMsg.style.display = 'block';
        }

        // cleanup request btns
        $(this)
            .find('.btn-request')
            .removeClass('disabled')
            .removeAttr('disabled');

        if( !doi.status.value ) {
          this.verify();
          return;
        }

        if( doi.status.value === 'Pending Approval' ) {
          this.$.pendingApproval.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Pending Revision' ) {
          this.$.pendingRevision.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Requesting' ) {
          this.$.requesting.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Accepted' ) {
          this.$.accepted.style.display = 'block';
          return;
        }

        if( doi.status.value === 'Applied' ) {
          this.$.applied.style.display = 'block';
          this.$.appliedLabel.innerHTML = doi.value;
          return;
        }
      },

      verify : function() {
        var html = '';

        var extras = ['Theme','Ecosystem Type','Acquisition Method'];
        var valid = {
          description : false,
          keywords : false,
          organization : false,
          public : false,
          author : false,
          'author email': false,
          maintainer : false,
          'maintainer email': false
        };

        extras.forEach(function(e){
          if( this.pkg.getExtra(e) !== '' ) {
            valid[e] = true;
          } else {
            valid[e] = false;
          }
        }.bind(this));

        if( this.pkg.getDescription() !== '' ) {
          valid.description = true;
        }
        if( this.pkg.getKeywords().length > 0 ) {
          valid.keywords = true;
        }
        if( this.pkg.getOrganization() !== '' ) {
          valid.organization = true;
        }
        if( !this.pkg.isPrivate() ) {
          valid.public = true;
        }
        if( this.pkg.getAuthor() !== '' ) {
          valid.author = true;
        }
        if( this.pkg.getAuthorEmail() !== '' ) {
          valid['author email'] = true;
        }
        if( this.pkg.getMaintainer() !== '' ) {
          valid.maintainer = true;
        }
        if( this.pkg.getMaintainerEmail() !== '' ) {
          valid['maintainer email'] = true;
        }

        var canRequest = true;
        var c = 0;
        for( var key in valid ) {
          if( valid[key] === false ) {
            canRequest = false;
            html += this.addRow(key, false);
          } else {
            html += this.addRow(key, true);
          }

          c++;
          if( c % 2 === 0 ) {
            html += '</tr><tr>';
          }

        }

        if( canRequest ) {
          this.$.request.style.display = 'block';
        } else {
          this.$.needsData.style.display = 'block';
          this.$.needsDataTable.innerHTML = '<tr>'+html+'</tr>';
        }
      },

      addRow : function(key, value) {
        return '<td>'+
            '<i class="fa text fa-'+(value ? 'check text-success' : 'times text-danger')+'"></i>'+
          '</td><td style="text-transform:capitalize">'+
            key+
          '</td>';
      },
      
      toggleCat : function(e) {
        if( this.$.panel.style.display == 'none' ) {
          e.currentTarget.querySelector('i').className = 'fa fa-arrow-down';
          this.$.panel.classList.add('animated','fadeIn');
          this.$.panel.style.display = 'block';
          if( this.$.panel.onShow ) this.$[id].onShow();
        } else {
          e.currentTarget.querySelector('i').className = 'fa fa-arrow-right';
          this.$.panel.style.display = 'none';
        }
      },


    });
  </script>
</dom-module>

<dom-module id="ecosis-page-basic-info">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    .save-label {
        position: fixed;
        top: 65px;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    a {
      cursor: pointer;
    }
  </style>
  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>



    <div class="well" style="font-size: 14px; color: #888">
      <h5>Welcome <span id="usernameLabel"></span></h5>
      Fill out the basic information for your dataset.  Then you can add resource files such as metadata or spectra.<br>
      <b>First time adding data?</b>  Checkout the <a href="http://tutorial.ecosis.org/" target="_blank">screencast and tutorial.</a>
      <br><br>
      <div>
        <i class="fa fa-star" style="color:#2196f3"></i> = Recommented Input.  If you can't fill out everything, please try
        and at least fill out any starred field.
      </div>
    </div>

    <div id="createFromTemplate" style="display:none; text-align:right">
      <div>
        <a class="btn btn-link" on-click="toggleCreateFromTemplate"><i class="fa fa-magic"></i> Create From Template</a>
        <div class="help-block">Use template file from prior dataset to get started.</div>
      </div>
      <div id="createFromTemplatePanel" style="display:none">
        Select File: <input type="file" on-change="createFromTemplateInput" style="display:inline-block" id="createFromTemplateInput">
      </div>
      <div id="createTemplateSuccess" style="display:none"><span class="label label-success">Success!</span></div>
    </div>

    <h4 class="page-header">Basic Information <small cat="basic"></small></h4>
    <ecosis-title-input id="titleInput" on-update="updateCreateBtnState"></ecosis-title-input>

    <div class="form-horizontal">

      <!-- Description -->
      <div class="form-group">
        <label for="textArea" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Description</label>
        <div class="col-md-9">
          <textarea class="form-control" rows="3" id="descriptionInput" on-change="onDescriptionInputChange"></textarea>
        </div>
      </div>

      <ecosis-keyword-input id="keywordInput"></ecosis-keyword-input>

      <div class="form-group">
        <label for="licenseInput" class="col-md-2 control-label">License: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="licenseInput" on-change="onLicenseInputChange">
            <option>Loading...</option>
          </select>
        </div>
      </div>

      <div class="form-group">
        <label for="organizationInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Organization: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="organizationInput" on-change="onOrganizationInputChange">
            <option>Loading...</option>
          </select>

          <div class="help-block">
            To add datasets to an <a href="/organization" target="_blank">organization</a>, <a href="/dashboard/organizations" target="_blank">you</a>
            must be a member of the organization with a role of 'editor' or 'admin'.
          </div>
        </div>
      </div>

      <div class="form-group">
        <label for="visibilityInput" class="col-md-2 control-label">Visibility: </label>
        <div class="col-md-9">
          <select class="form-control" id="visibilityInput" disabled="" on-change="onVisibilityInputChange">
            <option value="false">Public</option>
            <option value="true">Private</option>
          </select>

          <div class="help-block" id="visibilityWarnLabel">
            You must select an organization if you wish to set the dataset to private, otherwise the dataset must be public.
          </div>
        </div>
      </div>

      <!-- Version -->
      <div class="form-group">
        <label for="versionInput" class="col-md-2 control-label">Version</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="versionInput" on-change="onVersionInputChange">
        </div>
      </div>

      <!-- Website -->
      <div class="form-group">
        <label for="websiteInput" class="col-md-2 control-label">Website</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="websiteInput" on-change="onWebsiteInputChange">
        </div>
      </div>

      <h4 class="page-header">
          <a class="btn-toggle" on-click="toggleCat" cat="themeInput">
          <i class="fa fa-arrow-right"></i></a> Theme <small cat="theme"></small>
      </h4>
      <ecosis-theme-input id="themeInput" style="display:none"></ecosis-theme-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="measureInput">
          <i class="fa fa-arrow-right"></i></a> Measurement <small cat="measurement"></small>
      </h4>
      <ecosis-measurement-input id="measureInput" style="display:none"></ecosis-measurement-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="processingInput">
        <i class="fa fa-arrow-right"></i></a> Processing Information <small cat="processing information"></small>
      </h4>
      <ecosis-processing-input id="processingInput" style="display:none"></ecosis-processing-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="instrumentInput">
          <i class="fa fa-arrow-right"></i></a> Instrument <small cat="instrument"></small>
      </h4>
      <ecosis-instrument-input id="instrumentInput" style="display:none"></ecosis-instrument-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="locationInput">
        <i class="fa fa-arrow-right"></i></a> Location <small cat="location"></small>
      </h4>
      <ecosis-location-input id="locationInput" style="display:none"></ecosis-location-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="linkedDataInput">
        <i class="fa fa-arrow-right"></i></a> Linked Resources <small cat="linked"></small>
      </h4>
      <ecosis-linked-data-input id="linkedDataInput" style="display:none"></ecosis-linked-data-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="citationInput">
          <i class="fa fa-arrow-right"></i></a> Citation <small cat="citation"></small>
      </h4>
      <ecosis-citation-input id="citationInput" style="display:none"></ecosis-citation-input>

      <ecosis-doi id="doi" style="display:none"></ecosis-doi>

    </div>

    <!-- Create Dataset -->
    <a id="createDatasetBtn" class="btn btn-primary" style="display:none">Create Dataset</a>


    <div id="editModeFooter" style="display:none">
      Now <a href="#add-resources">add resources</a> to your dataset. <br>
    </div>

    <div class="layout horizontal" style="margin-top: 15px">
      <div class="flex">
        <a class="btn btn-primary" style="display:none" id="goToBtn" href="#add-resources"><i class="fa fa-plus"></i> Add Resources</a>
        <a class="btn btn-primary" style="display:none" id="goToListBtn" href="#current-resources"><i class="fa fa-list"></i> Current Resources</a>


        <a class="btn btn-primary" style="display:none" on-click="create" id="createBtn"><i class="fa fa-plus"></i> Create Dataset</a>

        <div id="helpCreatePanel" class="text text-warning" style="display:none">
          You must provide a valid dataset title to create.
        </div>
      </div>
      <div>
        <a class="btn btn-default" style="display:none" on-click="delete" id="deleteBtn"><i class="fa fa-trash"></i> Delete Dataset</a>
      </div>
    </div>

    <div class="well" style="margin-top: 30px">
      <div class="bugs" style="margin-top:20px">
        <i class="fa fa-bug"></i>  Found a bug?  Have an issue?  Let us know <a href="https://github.com/CSTARS/ckanext-ecosis/issues" target="_blank">here!</a>
      </div>

      <div class="gitInfo" id="gitInfo" style="display:none">
        <div><b>Branch:</b> <span id="gitBranchLabel"></span></div>
        <div><b>Version:</b> <span id="gitVersionLabel"></span></div>
        <div><b>Commit:</b> <span id="gitCommitLabel"></span></div>
      </div>
    </div>

    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-hidden="true"></button>
            <h4 class="modal-title">Welcome to the EcoSIS Data Importer!</h4>
          </div>
          <div class="modal-body" style="padding: 25px">
            <p>A quick note before you continue.</p>


            <p style="padding:30px 0" class="text text-success">
              Through EcoSIS you will be <b>publishing</b> your data to the world. In
              order to make datasets presentable and <b>searchable</b>, please give them clear
              <b>human-readable</b> titles and descriptions, and include as much
              dataset-level metadata as possible.  Include enough information so
              so a complete outsider can understand what the dataset is and is not.
            </p>

            <h5>tl;dr</h5>

            <ul>
              <li>Publish for others.</li>
              <li>Human-readable titles and descriptions.</li>
              <li>Fill out as much as you can.</li>
            </ul>

            <div class="help-block">
              Remember EcoSIS is what the <b>community</b> makes it to be.
            </div>

            <div style="text-align:center">
              <a class="btn btn-success btn-lg" data-dismiss="modal">Continue</a><a>
            </a></div><a>

          </a></div><a>
        </a></div><!-- /.modal-content --><a>
      </a></div><!-- /.modal-dialog --><a>
    </a></div><!-- /.modal --><a>

  </a></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-basic-info',

    ready : function() {
      this.updateTimer = -1;

      if( ecosis.user ) this.setUsername();
      else ecosis.on('user-load', this.setUsername.bind(this));

      if( ecosis.ds.editMode ) {
        this.setMode('edit');
        if( ecosis.ds.loaded ) this.onDataLoad();
        else ecosis.ds.on('load', this.onDataLoad.bind(this));
      } else {
        this.setMode('create');
        this.showCreatePopup();
      }

      this.updateScores();

      ecosis.ckan.getLicenseList(this.setLicenseList.bind(this));

      ecosis.ckan.gitInfo(function(resp){
        this.git = resp;

        if( !resp.error ) {
          ecosis.git = resp;
        }

        if( this.git.branch != 'master' ) {
          this.$.gitInfo.style.display = 'block';
          this.$.gitBranchLabel.innerHTML = this.git.branch;
          this.$.gitVersionLabel.innerHTML = this.git.version;
          this.$.gitCommitLabel.innerHTML = this.git.commit;
        }
        
        // HACK
        document.querySelector('ecosis-doi').onGitInfoLoad();
      }.bind(this));

      var fn = new ecosis.app.UiBuffer(this.updateScores, 100, this);
      ecosis.ds.on('load', fn);
      ecosis.ds.on('update', fn);
      ecosis.ds.package.on('save-start', this.saveStart.bind(this));
      ecosis.ds.package.on('save-end', this.saveEnd.bind(this));
    },

    showCreatePopup : function() {
      this.popup = $(this.$.popup).remove();
      $('body').append(this.popup);
      this.popup.modal({show:true});
    },

    setMode : function(mode) {
      this.mode = mode;
      if( mode == 'create' ) {
        this.$.createBtn.style.display = 'inline-block';
        this.$.createFromTemplate.style.display = 'block';
        this.updateCreateBtnState();
      } else {
        this.$.doi.style.display = 'block';
        this.$.goToBtn.style.display = 'inline-block';
        this.$.goToListBtn.style.display = 'inline-block';
        this.$.createFromTemplate.style.display = 'none';


        var status = ecosis.ds.package.getDoi().status;
        var hasDOI = false;
        if( status && status.value ) {
          if( status.value.toLowerCase() === 'applied' ) {
            hasDOI = true;
          }
        }

        this.$.deleteBtn.style.display = hasDOI ? 'none' : 'inline-block';
      }
    },

    onDataLoad : function() {
      var pkg = ecosis.ds.package;

      this.$.descriptionInput.value = pkg.getDescription();
      this.$.keywordInput.setTokens(pkg.getKeywords());
      this.$.licenseInput.value = pkg.getLicenseId();
      this.$.organizationInput.value = pkg.getOrganization();
      this.$.visibilityInput.value = pkg.isPrivate() ? 'true' : 'false';
      this.$.versionInput.value = pkg.getVersion();
      this.$.websiteInput.value = pkg.getWebsite();
      this.$.linkedDataInput.setData(pkg.getLinkedData());
      this.$.doi.setData(pkg);
      this.updateVisibilityControl();
    },

    updateVisibilityControl : function() {
      if( !ecosis.ds.package.getOrganization() ) {
        this.$.visibilityInput.setAttribute('disabled', '');
        this.$.visibilityInput.value = 'false';
        ecosis.ds.package.setPrivate(false);
        this.$.visibilityWarnLabel.style.display = 'block';
      } else {
        this.$.visibilityInput.removeAttribute('disabled');
        this.$.visibilityWarnLabel.style.display = 'none';
        this.$.visibilityInput.value = ecosis.ds.package.isPrivate() ? 'true' : 'false';
      }
    },

    updateCreateBtnState : function() {
      if( this.mode === 'edit' ) return;

      if( this.$.titleInput.validName ) {
        this.$.createBtn.removeAttribute('disabled');
        this.$.helpCreatePanel.style.display = 'none';
      } else {
        this.$.createBtn.setAttribute('disabled', 'disabled');
        this.$.helpCreatePanel.style.display = 'block';
      }
    },

    setLicenseList : function(resp) {
      if( resp.error ) return console.log('Error loading licenses :(');

      this.licenses = resp;
      var options = '<option></option>';
      for( var i = 0; i < resp.length; i++ ) {
        var item = resp[i];
        options += '<option value="'+item.id+'" '+(ecosis.ds.package.getLicenseId() == item.id ? 'selected' : '')+'>'+item.title+'</option>';
      }
      this.$.licenseInput.innerHTML = options;
    },

    setUsername : function() {
      if( !ecosis.user ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
        return;
      } else if( !ecosis.user.loggedIn ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
        return;
      }

      this.$.usernameLabel.innerHTML = ecosis.user.username;

      // set user orgs
      var options = '<option></option>';
      for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
        var org = ecosis.user.organizations[i];
        options += '<option value="'+org.id+'">'+org.display_name+'</option>';
      }
      this.$.organizationInput.innerHTML = options;
    },

    delete : function() {
      if( !confirm('Are you sure your want to remove this dataset?') ) return;
      if( !confirm('Are you REALLY sure your want to remove this dataset?!?') ) return;

      ecosis.ds.package.delete(function(resp) {
          if( resp.error ) {
            return ecosis.errorPopup.show(resp);
          }

          alert('dataset deleted.');
          window.location = '/dataset';
        }
      );
    },

    create : function() {
      if( this.$.createBtn.hasAttribute('disabled') ) return;

      this.$.createDatasetBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Creating...';
      this.$.createDatasetBtn.setAttribute('disabled', 'disabled');

      ecosis.ds.package.create(function(resp) {
        this.$.createDatasetBtn.innerHTML = '<i class="fa fa-plus"></i> Create Dataset';
        this.$.createDatasetBtn.removeAttribute('disabled');

        if( resp.error ) {
          return ecosis.errorPopup.show(resp);
        }

        // set the page
        window.location = '/import/?id='+resp.id+'#add-resources';
      }.bind(this));
    },

    updateScores : function() {
      var breakdown = ecosis.ds.getScore().breakdown;
      var $this = $(this);

      for( var key in breakdown ) {
        $this.find('small[cat="'+key+'"]').html(breakdown[key].score+'/'+breakdown[key].total);
      }
    },

    saveStart : function() {
      if( this.mode === 'create' ) return;
      this.$.saveLabel.style.display = 'block';
    },

    saveEnd : function(resp) {
      if( this.mode === 'create' ) return;
      this.$.saveLabel.style.display = 'none';

      if( resp.details && resp.details.doiApplied ) {
        return alert('You cannot update this dataset.  EcoSIS DOI has been applied');
      }

      if( resp.error ) {
        return ecosis.errorPopup.show(resp);
      }
      document.querySelector('ecosis-header').setBackBtn(resp.name);
    },

    /* change handlers */
    onOrganizationInputChange : function() {
      ecosis.ds.package.setOrganization(this.$.organizationInput.value);
      this.updateVisibilityControl();
    },

    onDescriptionInputChange : function() {
      ecosis.ds.package.setDescription(this.$.descriptionInput.value);
    },

    onLicenseInputChange : function() {
      var license_id = this.$.licenseInput.value;
      var license_title = '';

      for( var i = 0; i < this.licenses.length; i++ ) {
        if( this.licenses[i].id == ecosis.ds.package.getLicenseId() ) {
          license_title = this.licenses[i].title;
          break;
        }
      }

      ecosis.ds.package.setLicense(license_id, license_title);
    },

    onVisibilityInputChange : function() {
      ecosis.ds.package.setPrivate(this.$.visibilityInput.value == 'true' ? true : false);

      // push to search needs to know
      this.fire('visibility-change');
    },

    onVersionInputChange : function() {
      ecosis.ds.package.setVersion(this.$.versionInput.value);
    },

    onWebsiteInputChange : function() {
      ecosis.ds.package.setWebsite(this.$.websiteInput.value);
    },

    onLinkedDataChange : function() {
      ecosis.ds.package.setLinkedData(this.$.linkedDataInput.getData());
    },

    toggleCat : function(e) {
      var id = e.currentTarget.getAttribute('cat');

      if( this.$[id].style.display == 'none' ) {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-down';
        this.$[id].className = 'animated fadeIn';
        this.$[id].style.display = 'block';
        if( this.$[id].onShow ) this.$[id].onShow();
      } else {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-right';
        this.$[id].style.display = 'none';
      }
    },

    toggleCreateFromTemplate : function() {
      $(this.$.createFromTemplatePanel).toggle('slow');
    },

    createFromTemplateInput : function(e) {
      try {
        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        if( files.length == 0 ) return;

        var reader = new FileReader();
        var contents, parts;

        reader.onload = function(e) {
          try {
            var data = JSON.parse(e.target.result);
            ecosis.ds.loadFromTemplate(data);
            this.onDataLoad();
            this.$.createTemplateSuccess.style.display = 'block';
            this.toggleCreateFromTemplate();
            this.$.createFromTemplateInput.value = '';

            setTimeout(function(){
              this.$.createTemplateSuccess.style.display = 'none';
            }.bind(this), 5000);
          } catch(e) {
            this.$.createFromTemplateInput.value = '';
            alert('Error reading template file');
          }
        }.bind(this);
        reader.readAsText(files[0]);

      } catch(e) {
        this.$.createFromTemplateInput.value = '';
        alert('Error reading template file');
      }
    }

  })
</script>

<dom-module id="ecosis-page-current-resources">
  <style>
    :host {
      display : block;
      padding: 0 5%;
    }
    #legend {
      padding: 20px 0;
    }
    #filterPopup {
      display : none;
      position: absolute;
      right : 25px;
      margin: 10px 15px 15px 15px;
      padding: 15px;
      background-color: white;
      box-shadow: 0 0 5px #ccc;
      z-index: 100;
      font-size: 16px;
    }
  </style>

  <template>

    <h4 class="page-header">
      <span>Current Resources</span>

      <div class="pull-right" style="margin-top: -10px">
        <div class="btn-group">
          <a class="btn btn-default active" on-click="toggleSortName" id="sortName">Sort by Name</a>
          <a class="btn btn-default" on-click="toggleSortType" id="sortType">Sort by Type</a>
        </div>

        <div class="btn btn-default" on-click="toggleFilter">Filter</div>
        <div id="filterPopup">
          <button type="button" class="close" aria-label="Close" on-click="toggleFilter"><span aria-hidden="true"></span></button>
          <h5 class="page-header" style="margin-top:5px">Show</h5>


          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="success">
              <span class="text text-success">Data Sheet</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="primary">
              <span class="text text-primary">Metadata Sheet</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="zip">
              <span class="text text-warning">Zip Package</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="info">
              <span class="text text-info">Multi-Sheet File</span>
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" checked="" class="filter" on-click="filter" data-type="default">
              <span class="text text-default">Ignored</span>
            </label>
          </div>
        </div>
      </div>
    </h4>

    <div id="removeAll" style="margin-bottom: 20px">
      <a class="btn btn-link" on-click="selectAll">Select All</a>
      <a class="btn btn-link" on-click="unselectAll">Unselect All</a>

      <a class="btn btn-danger pull-right" id="deleteAll" on-click="deleteAll" style="display:none">Delete All Selected</a>
    </div>
    <ecosis-isotope id="resourceRoot" selector=".data-item"></ecosis-isotope>

    <div id="noResources" style="display:none">
      Your dataset does not contain any resource files.  Click <a id="addLink">here</a> to upload resources.
    </div>

    <div id="legend">
      <div style="float:right">
        Click the <i class="fa fa-pencil"></i> icon to inspect or edit a resource.
      </div>

      <h6 style="margin-bottom:0">Resource List Legend</h6>
      <span class="label label-success">Data Sheet</span>
      <span class="label label-primary">Metadata Sheet</span>
      <span class="label label-warning">Zip Package</span>
      <span class="label label-info">Multi-Sheet File</span>
      <span class="label label-default">Ignored</span>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-current-resources',

    ready : function() {
      if( ecosis.ds.loaded ) this.render();
      else ecosis.ds.on('load', this.render.bind(this));

      this.$.addLink.setAttribute('href', '#add-resources');
    },

    onShow : function() {
      this.render();
    },

    render : function() {
      if( ecosis.ds.resources.length == 0 ) {
        this.$.noResources.style.display = 'block';
        this.$.legend.style.display = 'none';
        this.$.removeAll.style.display = 'none';
        return;
      } else {
        this.$.noResources.style.display = 'none';
        this.$.legend.style.display = 'block';
        this.$.removeAll.style.display = 'block';
      }

      var html = '';


      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        if( resource.fromZip ) continue;

        html += '<ecosis-resource-panel resourceid="'+resource.id+'" style="width:100%" class="data-item"></ecosis-resource-panel>';
      }

      this.$.resourceRoot.html(html);

      // listen for all update events
      $(this.$.resourceRoot)
        .find('ecosis-resource-panel')
        .on('update', this.onResourceUpdate.bind(this))
        .on('resource-select', this.onResourceSelect.bind(this));


      this.$.resourceRoot.init();
    },

    toggleFilter : function() {
      $(this.$.filterPopup).toggle();
    },

    toggleSortName : function() {
      $(this.$.sortName).addClass('active');
      $(this.$.sortType).removeClass('active');
      this.sort('name');
    },

    toggleSortType : function() {
      $(this.$.sortName).removeClass('active');
      $(this.$.sortType).addClass('active');
      this.sort(['type','name']);
    },

    sort : function(sortValue) {
      this.$.resourceRoot.sort(sortValue);
      var zips = this.querySelectorAll('ecosis-resource-panel.data-item[data-type="zip"]');
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].sort(sortValue);
      }
    },

    filter : function() {
      var filters = this.querySelectorAll('.filter');
      var filter = [];
      for( var i = 0; i < filters.length; i++ ) {
        if( !$(filters[i]).prop('checked') ) continue;
        filter.push('[data-type="'+filters[i].getAttribute('data-type')+'"]');
      }

      filter = filter.join(', ');

      // empty filter breaks isotope
      if( filter == '' ) filter = '*';

      var zips = this.querySelectorAll('ecosis-resource-panel.data-item[data-type="zip"]');
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].filter(filter);
      }

      this.$.resourceRoot.filter(filter);

      // make sure everything is correct
      for( var i = 0; i < zips.length; i++ ) {
        zips[i].filter(filter);
      }

      this.$.resourceRoot.filter(filter);
    },

    // make sure all resource panel css classes are correct
    verifyPanelCss : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        eles[i].setClass();
      }
    },

    onResourceSelect : function() {
      this.updateSelectState();
    },

    deleteAll : function() {
      if( !confirm('Are you sure you want to delete all selected resources?') ) return;

      var eles = this.querySelectorAll('ecosis-resource-panel');
      var ids = [], usedEles = [];
      for( var i = 0; i < eles.length; i++ ) {
        if( !eles[i].isSelected() || eles[i].resource.fromZip ) continue;
        eles[i].querySelector('#deletePanel').style.display = 'inline-block';
        ids.push(eles[i].resource.id);
        usedEles.push(eles[i]);
      }

      ecosis.ckan.deleteResources(ids, function(resp){
        if( resp.error ) {
          // ERROR 11
          resp.code = 11;
          return ecosis.errorPopup.show(resp);
        }

        for( var i = 0; i < usedEles.length; i++ ) {
          $(usedEles[i]).remove();
        }

        for( var i = ecosis.ds.resources.length - 1; i >= 0; i-- ) {
          if( ids.indexOf(ecosis.ds.resources[i].id) > -1 ) {
            ecosis.ds.resources.splice(i, 1);
          }
        }

        ecosis.ds.fireUpdate();

        ecosis.ds.deleteResourceTime = new Date();
        ecosis.ds.checkChanges();

        if( ecosis.ds.resources.length == 0 ) {
          this.$.noResources.style.display = 'block';
          this.$.legend.style.display = 'none';
          this.$.removeAll.style.display = 'none';
        }

        this.$.deleteAll.style.display = 'none';
      }.bind(this));
    },

    selectAll : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        if( eles[i].style.display === 'none' ) continue;
        eles[i].select(true);
      }
      this.updateSelectState();
    },

    unselectAll : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) eles[i].select(false);
      this.updateSelectState();
    },

    updateSelectState : function() {
      var eles = this.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < eles.length; i++ ) {
        if( eles[i].isSelected() ) {
          this.$.deleteAll.style.display = 'block';
          return;
        }
      }
      this.$.deleteAll.style.display = 'none';
    },

    onResourceUpdate : function(e) {
      var id = e.originalEvent.detail;

      var panels = this.$.resourceRoot.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < panels.length; i++ ) {
        if( panels[i].edit && panels[i].resourceid != id ) {
          var panel = panels[i]
          // hide resource
          panel.toggleEdit();
          // clear cached 'full' datasheet
          if( panel.$.datasheetUI ) {
            panel.$.datasheetUI.datasheet = null;
          }
        }
      }

      if( ecosis.ds.resources.length == 0 ) {
        this.$.noResources.style.display = 'block';
        this.$.legend.style.display = 'none';
        this.$.removeAll.style.display = 'none';
      }

    }


  });
</script>

<dom-module id="ecosis-page-add-resource">
  <style>
    :host {
      display: block;
      padding: 0 5% 50px 5%;
    }
    #dropZone {
        border: 2px dashed #bbb;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        border-radius: 5px;
        padding: 25px;
        font-size: 20pt;
        color: #bbb;
        background-color: white;
        margin: 15px 0 0 0;
    }
  </style>

  <template>
    <h4 class="page-header">Add Resources</h4>

    <h5 style="margin-bottom: 0">Select files to be uploaded</h5>
    <div style="font-size:12px;color:#888; margin-bottom: 30px">
        <span>Add new files below by using the file selector or drag files over the drop zone.</span>
    </div>

    <div class="well well-sm">

      <div class="form-horizontal">
        <div class="form-group">
          <label class="col-md-3 control-label">
              Default Orientation<br>
              <a on-click="toggleHelp" style="cursor: pointer">What is this?</a>
          </label>

          <div class="col-md-7">
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="columnInput" value="column" checked="" on-click="onRadioChange">
                My observations are by column.
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="rowInput" value="row" on-click="onRadioChange">
                My observations are by row.
              </label>
            </div>
          </div>
        </div>
      </div>

      <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>

    </div>
    <!-- end well -->

    <div id="processing" style="display: none">
        <h4 class="alert alert-success">
          <div><i class="fa fa-spin fa-circle-o-notch"></i> Uploading &amp; Processing Files...</div>
          <div style="font-size:12px">This may take a couple minutes, depending on the size of your upload.</div>
        </h4>
        <div id="uploadStatusTable"></div>
    </div>

    <div class="fileinput" id="fileInputPanel">
        <div>
            <input type="file" style="margin:30px 0 0 15px" id="file" name="file" multiple="" on-change="handleFileSelect">
            <!--<input type="file" style="display:none" id="addFileTesting" name="addFileTesting" multiple="" /> -->
        </div>

        <div class="file-select-group">
            <div id="dropZone"><b>OR</b> drag and drop files here</div>
        </div>
    </div>

    <div id="completePanel" style="display:none; margin-top:20px;">
      <a id="completePanelLink" class="btn btn-primary animated fadeInDownBig"><i class="fa fa-list"></i> Open resource list</a>
    </div>

    <div style="margin-top: 40px">
      <a on-click="toggleInfoPanel" style="cursor:pointer">Supported file types and the Ecosis Metadata Editor</a>
    </div>
    <div id="infoPanel" style="display:none" class="animated fadeIn">
        <h6 class="page-header">Supported File Types</h6>
        <div class="well well-sm">
            <div>Currently the following tabular file types will be parsed.</div>
            <ul>
                <li>.xls</li>
                <li>.xlsx</li>
                <li>.csv</li>
                <li>.tsv (Tab Separated Value)</li>
                <li>.spectra (parsed as .tsv)</li>
                <li>.zip<span class="green">*</span></li>
            </ul>
            <div><span class="green">*</span>Zip files will be extracted on the server.
              Any files contained within the zip file that have supported extension will be parsed.</div>
            <div>Other file extensions are accepted but will not be parsed.</div>
        </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-add-resource',

    ready : function() {
      this.$.dropZone.addEventListener('dragover', this.handleDragOver.bind(this), false);
      this.$.dropZone.addEventListener('drop', this.handleFileSelect.bind(this), false);

      this.staggedFiles = [];
      this.newResourceIds = [];

      this.defaultType = 'column';
      this.$.formatHelp.setType('column');

      this.$.completePanelLink.setAttribute('href', '#current-resources');
    },

    onRadioChange : function() {
      if( $(this.$.columnInput).is(':checked') ) {
        this.$.formatHelp.setType('column');
        this.defaultType = 'column';
      } else {
        this.$.formatHelp.setType('row');
        this.defaultType = 'row';
      }
    },

    handleDragOver : function (evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    },

    handleFileSelect : function(evt) {
      evt.stopPropagation();
      evt.preventDefault();

      this.setProcessing(true);

      var files = evt.dataTransfer ? evt.dataTransfer.files : evt.target.files; // FileList object.

      this.staggedFiles = [];
      this.newResourceIds = [];

      for( var i = 0; i < files.length; i++ ) {
          this.staggedFiles.push({
              file : files[i],
              name : files[i].name,
              aborted : false,
              xhr : null,
              progress : 0,
              type : this.defaultType,
              speed : '0Mbps'
          });
      }

      this.renderUploadStatusTable();
      this.uploadFiles(this.defaultType, 0);
    },

    setProcessing : function(processing) {
      if( processing ) {
        this.$.fileInputPanel.style.display = 'none';
        this.$.processing.style.display = 'block';
      } else {
        this.$.fileInputPanel.style.display = 'block';
        this.$.processing.style.display = 'none';
      }
    },

    onUploadComplete : function() {
      if( this.newResourceIds.length == 0 ) {
        this.onProcessingComplete();
        return;
      }

      ecosis.ckan.processResource(
          ecosis.ds.package_id, this.newResourceIds, null, {layout: this.defaultType},
          function(resp) {
              if( resp.error ) {
                // ERROR 3
                resp.code = 3;
                return ecosis.errorPopup.show(resp);
              }

              // proly a smarter way to do things, but for now, reload entire workspace
              ecosis.ckan.getWorkspace(ecosis.ds.package_id, function(result){
                if( result.error ) {
                  // ERROR 4
                  result.code = 4;
                  return ecosis.errorPopup.show(result);
                }

                ecosis.ds.runAfterResourceAdd(result);
                this.onProcessingComplete();
                this.fire('resource-add');
                this.showUploadWizard();
              }.bind(this));
          }.bind(this)
      )
    },

    showUploadWizard : function() {
      var resources = [];
      for( var i = 0; i < this.newResourceIds.length; i++ ) {
        var resource = ecosis.ds.resourceLookup[this.newResourceIds[i]];
        if( !resource.datasheets ) continue;

        if( resource.childResources ) {
          for( var j = 0; j < resource.childResources.length; j++ ) {
            if( !resource.childResources[j].datasheets ) continue;
            if( resource.datasheets.length == 1 && resource.datasheets[0].invalidFileType ) continue;

            resources.push(resource.childResources[j]);
          }
        } else if ( resource.datasheets.length == 1 && resource.datasheets[0].invalidFileType ) {
          continue;
        } else {
          resources.push(resource);
        }
      }

      document.querySelector('ecosis-upload-splash').show(resources,{
        onDatasheetUpdate : function(){
          // make sure all panels have correct css after update
          document.querySelector('ecosis-page-current-resources').verifyPanelCss();
        }
      });
    },

    onProcessingComplete : function() {
      this.$.file.value = '';
      this.setProcessing(false);

      this.$.completePanel.style.display = 'block';
    },

    uploadFiles : function(type, index) {
        if( this.staggedFiles.length <= index ) {
            // now tell server to parse resources with given type
            this.onUploadComplete();
            return;
        }

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.aborted ) {
            index++;
            this._uploadFiles(type, index);
            return;
        }


        var file = this.staggedFiles[index].file;
        var reader = new FileReader();

        reader.onload = function(e) {
            staggedFile.xhr = ecosis.ckan.addResource(
                ecosis.ds.package_id,
                {
                    contents : e.target.result,
                    mimetype : file.type,
                    filename : file.name
                },
                function(resp) {
                    if( resp.error ) console.log('Error adding resource: '+file.name);

                    // save this, when we are done, we will set default parse type
                    this.newResourceIds.push(resp.id);

                    index++
                    this.uploadFiles(type, index);
                }.bind(this),
                function(progress, speed) {
                    this.staggedFiles[index].speed = speed;
                    this.staggedFiles[index].progress = progress;
                    this.updateStatusText(index);
                }.bind(this)
            );
        }.bind(this);
        reader.readAsArrayBuffer(file);
    },

    abort : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        e.currentTarget.style.display = 'none';

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.progress == 100 ) return;

        staggedFile.aborted = true;

        this.updateStatusText(index);

        if( staggedFile.xhr ) {
            staggedFile.xhr.abort();
            index++;
            this._uploadFiles(this.defaultType, index);
        }
    },

    toggleHelp : function() {
        $(this.$.formatHelp).toggle();
    },

    toggleInfoPanel : function() {
      if( this.$.infoPanel.style.display == 'none') {
        $(this.$.infoPanel).show();
        $(window).scrollTop(254);
      } else {
        $(this.$.infoPanel).hide();
      }
    },

    renderUploadStatusTable : function() {
      var table = '<table class="table" style="text-align: left">';

      for( var i = 0; i < this.staggedFiles.length; i++ ) {
        var file = this.staggedFiles[i];
        var status = this.getFileStatus(file);

        table +=
          '<tr>'+
            '<td><b>'+file.name+'</b></td>'+
            '<td style="color:#888" index="'+i+'">'+status.message+'</td>'+
            '<td>'+
              '<a class="btn btn-default" index="'+i+'" '+(status.code == 2 ? 'style="display:none"' : '')+'>Abort</a>'+
            '</td>'+
          '</tr>'
      }
      table += '</table>';

      this.$.uploadStatusTable.innerHTML = table;

      $(this.$.uploadStatusTable)
        .find('a')
        .on('click', this.abort.bind(this));
    },

    getFileStatus : function(file) {
      if( file.progress != 100 && !file.aborted ) {
        return {code: 1, message: 'Uploading: '+file.progress+'% @ '+file.speed};
      } else if ( file.progress == 100 && !file.aborted ) {
        return {code: 2, message : 'Upload Complete. Processing...'};
      } else if( file.aborted ) {
        return {code: -1, message: '<span class="label label-danger">Aborted</span>'};
      }

      return '';
    },

    updateStatusText : function(index) {
      var td = this.$.uploadStatusTable.querySelector('td[index="'+index+'"]');
      if( td ) {
        var status = this.getFileStatus(this.staggedFiles[index]);
        td.innerHTML = status.message;
        if( status.code == 2 ) {
          var btn = this.$.uploadStatusTable.querySelector('a[index="'+index+'"]');
          btn.style.display = 'none';
        }
      }
    }


  });
</script>

<dom-module id="ecosis-attribute-mapping">
  <style>
    :host {
      display: block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    table.table th {
      border : none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div style="padding: 15px">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h3 class="panel-title">Map your spectra metadata names to EcoSIS names</h3>
        </div>
        <div class="panel-body">
          <h5 class="page-header" style="margin-top:0">By File</h5>

          <div class="horizontal layout">
              <div class="flex">
                  <a class="btn btn-default" target="_blank" id="mapTemplate">Download Alias Template</a>
              </div>
              <div class="flex">
                  Upload Template: <input type="file" style="margin-top:5px" id="map" name="map" on-change="processMap">

                  <span class="label label-success" id="mapSuccessLabel" style="display:none">Success!</span>
              </div>
          </div>
          <div class="help-block">
            Use this to bulk upload and set the attribute name aliases.  This is aliases template file can be
            reused across your datasets.  NOTE:  This will overwrite all current aliases.
          </div>

          <h5 class="page-header">Individually</h5>
          <div class="help-block">
            Use this to add individual spectra metadata aliases.
          </div>

          <table class="table">
            <tbody><tr>
              <th>EcoSIS</th>
              <th></th>
              <th id="dsTitleLabel"></th>
              <th></th>
            </tr>
            <tr>
              <td>
                <select id="newEcosis" class="form-control"></select>
              </td>
              <td>
                <i class="fa fa-arrow-right"></i>
              </td>
              <td>
                <select id="newCustom" class="form-control"></select>
              </td>
              <td>
                <a class="btn btn-primary" on-click="add" style="margin: 5px"><i class="fa fa-plus"></i> Add</a>
              </td>
            </tr>
          </tbody></table>

          <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
  			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>

        </div>
      </div>

      <div class="panel panel-primary" id="currentPanel">
        <div class="panel-heading">
          <h3 class="panel-title">Current Aliases</h3>
        </div>
        <div class="panel-body" id="currentMapRoot"></div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-attribute-mapping',

    ready : function() {
      ecosis.ds.on('load', function(){
        this.$.dsTitleLabel.innerHTML = ecosis.ds.package.getTitle();
        this.updateSelectList();
        this.updateMap();
      }.bind(this));
    },

    onShow : function() {
      this.updateSelectList();
      this.updateMap();
      this.$.mapTemplate.setAttribute('href', ecosis.ckan.host+'/ecosis/package/getTemplate?mapOnly=true&id='+ecosis.ds.package_id);
    },

    setTopMapping : function(panel) {
      this.topPanel = panel;
    },

    processMap : function(e) {
      try {
        e.stopPropagation();
        e.preventDefault();

        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        if( files.length == 0 ) return;

        var reader = new FileReader();
        var contents, parts;

        reader.onload = function(e) {
          try {
            var data = JSON.parse(e.target.result);
            if( data.map ) {
              data.aliases = data.map;
            }

            var newAliases = {};
            for( var key in data.aliases ) {
              if( data.aliases[key] ) {
                newAliases[key] = data.aliases[key];
              }
            }

            ecosis.ds.package.setAliases(newAliases);
            ecosis.ds.updateAliasLookup();
            this.updateSelectList();
            this.updateMap();

            this.$.map.value = '';

            this.$.mapSuccessLabel.style.display = 'inline-block';
            setTimeout(function(){
              this.$.mapSuccessLabel.style.display = 'none';
            }.bind(this), 5000);
          } catch(e) {
            this.$.map.value = '';
            alert('Error loading attribute map');
          }
        }.bind(this);

        reader.readAsText(files[0]);
      } catch(e) {
        this.$.map.value = '';
        alert('Error loading attribute map');
      }
    },

    addFromSuggest : function(custom, trait) {
      var aliases = ecosis.ds.package.getAliases();
      aliases[trait] = custom;

      ecosis.ds.package.setAliases(aliases);
      ecosis.ds.updateAliasLookup();
      this.updateMap();
      this.updateSelectList();
    },

    updateMap : function() {
      var c = 0, item = {};
      var map = ecosis.ds.attributeMap;
      this.attrMapList = [];

      for( var key in map ) {
          if( map[key] && map[key].length > 0 ) {
              this.attrMapList.push({
                  ecosis : key,
                  custom : map[key]
              });
          } else {
              delete map[key]
          }
      }

      this.attrMapList.sort(function(a, b){
          if( a.ecosis > b.ecosis ) return 1;
          if( a.ecosis < b.ecosis ) return -1;
          return 0;
      });

      this.renderCurrentList();
    },

    updateSelectList : function() {
      this.selectList = [];
      this.customList = [];

      var html = '<optgroup><option></option></optgroup>';

      for( var key in ecosis.ds.metadataDefinitions ) {
          html += '<optgroup label="'+key+'">';

          var attrs = ecosis.ds.metadataDefinitions[key];

          for( var i = 0; i < attrs.length; i++ ) {
              if( !ecosis.ds.attributeMap[attrs[i].name] ) {
                  html += '<option value="'+attrs[i].name+'">'+attrs[i].name+'</option>'
              }
          }
          html += '</optgroup>';
      }

      this.$.newEcosis.innerHTML = html;


      var attrs = {}, sheet;
      if( ecosis.ds.datasheets ) {
        for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
          sheet = ecosis.ds.datasheets[i];
          for( var j = 0; j < sheet.attributes.length; j++ ) {
            attrs[sheet.attributes[j]] = 1;
          }
        }
      }

      attrs = Object.keys(attrs);

      for( var i = 0; i < attrs.length; i++ ) {
          if( ecosis.ds.attributeMap[attrs[i]] ) continue;
          this.customList.push(attrs[i]);
      }

      this.customList.sort(function(a, b){
          if( a.toLowerCase() > b.toLowerCase() ) return 1;
          if( a.toLowerCase() < b.toLowerCase() ) return -1;
          return 0;
      });

      html = '<option></option>';
      for( var i = 0; i < this.customList.length; i++ ) {
        html += '<option value="'+this.customList[i]+'">'+this.customList[i]+'</option>'
      }
      this.$.newCustom.innerHTML = html;

      if( this.topPanel ) {
        this.topPanel.update(this.customList);
      }
    },

    renderCurrentList : function() {
      if( Object.keys(ecosis.ds.attributeMap).length == 0 ) {
        this.$.currentMapRoot.innerHTML = 'No attributes currently mapped';
        return;
      }

      var table =
        '<table class="table">'+
          '<tr>'+
              '<th>EcoSIS</th>'+
              '<th>'+ecosis.ds.package.getTitle()+'</th>'+
              '<th>Remove</th>'+
          '</tr>';

      for( var i = 0; i < this.attrMapList.length; i++ ) {
        var item = this.attrMapList[i];
        table += '<tr>'+
              '<td>'+item.ecosis+'</td>'+
              '<td>'+item.custom+'</td>'+
              '<td><a class="btn btn-default" attribute="'+item.custom+'"><i class="fa fa-trash"></i></a></td>'+
          '</tr>';
      }
      table += '</table>';

      this.$.currentMapRoot.innerHTML = table;

      $(this.$.currentMapRoot)
        .find('a.btn')
        .on('click', this.remove.bind(this));

    },

    remove : function(e) {
      var custom = e.currentTarget.getAttribute('attribute');
      var ecosisAttr = ecosis.ds.inverseAttributeMap[custom];

      if( !confirm('Are you sure you want to remove the mapping: '+ecosisAttr+' = '+custom+'?') ) return;

      delete ecosis.ds.attributeMap[ecosisAttr];
      delete ecosis.ds.inverseAttributeMap[custom];

      this.save(ecosis.ds.attributeMap);
    },

    add : function() {
      var ecosisAttr = this.$.newEcosis.value;
      var custom = this.$.newCustom.value;

      if( ecosisAttr.length == 0 || custom.length == 0 ) return alert('Please select both attributes to map first');

      ecosis.ds.attributeMap[ecosisAttr] = custom;
      ecosis.ds.inverseAttributeMap[custom] = ecosisAttr;

      this.$.newEcosis.value = '';
      this.$.newCustom.value = '';

      this.save(ecosis.ds.attributeMap);
    },

    updateAttrMapList : function(newMap) {
      this.attrMapList = [];

      var c = 0, item = {};
      var map = newMap || this.map;

      if( newMap ) {
          ecosis.ds.attributeMap = newMap;
          ecosis.ds.inverseAttributeMap = {};

          for( var key in newMap ) {
              if( newMap[key] != '' ) ecosis.ds.inverseAttributeMap[newMap[key]] = key;
          }
      }

      this.save(newMap);
    },

    save : function(newMap) {
      this.$.saveLabel.style.display = 'block';

      var options = {
        map : newMap
      };

      ecosis.ds.package.setAliases(newMap);
      ecosis.ds.updateAliasLookup();

      this.updateMap();
      this.updateSelectList();
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }

  })
</script>

<dom-module id="ecosis-top-mapping">
  <template>
    <style>
      .card {
        margin: 15px 10px;
        padding: 10px;
        box-shadow: 0 0 5px #ccc;
      }
    </style>

    <div style="padding: 15px">
      <div class="panel panel-primary" id="root">
        <div class="panel-heading">
          <h3 class="panel-title">Standardize Your Plant Trait Names</h3>
        </div>
        <div class="panel-body">
          <div class="help-block">Use standard names when providing plant trait information.  Below,
            <span id="countLabel"></span> of your spectra metadata attribute names have suggested standard trait names.
            Now many of your spectra metadata attributes may not be traits, but for those that are, please
            try and set aliases to an appropriate, standardized name.
          </div>

          <div class="layout horizontal center">
            <div>
              <a class="btn btn-default" style="margin-right: 30px"><i class="fa fa-arrow-left"></i></a>
            </div>
            <div class="flex">
              <select class="form-control" id="selector" on-change="suggest"></select>
            </div>
            <div>
              <a class="btn btn-default" style="margin-left: 30px"><i class="fa fa-arrow-right"></i></a>
            </div>
          </div>

          <h5 id="suggestLabel" style="display:none; margin-top: 30px">Suggestions</h5>

          <template is="dom-repeat" items="{{suggestions}}">
            <div class="card">
              <h4 class="page-header" style="margin:0">
                <span>{{item.preferredLabel}}</span>
                <small>{{item.subClassOfClean}}</small>
                <a class="btn btn-primary pull-right" on-click="onSelect" index$="{{index}}">Select</a>
              </h4>

              <div style="margin-bottom: 20px">{{item.definition.value}}</div>
              <div class="help-block"><b>Reference</b>: <span>{{item.definition.reference.value}}</span></div>

              <div hidden$="{{!item.prefUnit.value}}"><b>Units:</b> <span>{{item.prefUnit.value}}</span></div>
              <div hidden$="{{!item.alternativeLabel}}"><b>Alt Label:</b> <span>{{item.alternativeLabel}}</span></div>
              <div hidden$="{{!item.relatedTermClean}}"><b>Related:</b> <span>{{item.relatedTermClean}}</span></div>
              <div hidden$="{{!item.abbrivation}}"><b>Abbrivation:</b> <span>{{item.abbrivation}}</span></div>
              <div><b>TOP Link:</b> <a href$="{{item.link}}" target="_blank">More Info</a></div>
            </div>
          </template>

          <div style="text-align: right; margin-top: 30px">
            Powered By: <a href="http://top-thesaurus.org/" target="_blank">TOP Thesaurus</a>
          </div>
        </div>
      </div>

      <div style="text-align:center" id="allGoodMessage" class="well">
        We have no suggestions at this time for your spectra metadata attribute names.
      </div>

      <div style="text-align:center">
        Looking for the complete list of standard plant trait names?  Please visit the <a href="http://top-thesaurus.org/" target="_blank">TOP Thesaurus</a>.
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'ecosis-top-mapping',

      attached : function() {
        this.suggestions = [];
        document.querySelector('ecosis-attribute-mapping').setTopMapping(this);
      },

      update : function(list) {
        for( var i = list.length-1; i > 0; i-- ) {
          if( ecosis.ds.inverseAttributeMap[list[i]] ) {
            list.splice(i, 1);
          }
        }

        var str = list.join('');
        if( this.current === str ) return;

        this.current = str;

        ecosis.ckan.topSuggestOverview(list, function(resp){
          this.badList = [];
          for( var key in resp ) {
            if( resp[key].type !== 'match' && resp[key].type !== 'nomatch' ) {
              this.badList.push(key);
            }
          }

          if( this.badList.length === 0 ) {
            this.$.root.style.display = 'none';
            this.$.allGoodMessage.style.display = 'block';
            return;
          }

          this.$.allGoodMessage.style.display = 'none';
          this.$.root.style.display = 'block';

          this.render();
        }.bind(this));
      },

      render : function() {
        this.$.countLabel.innerHTML = this.badList.length;

        var html = '<option></option>';
        for( var i = 0; i < this.badList.length; i++ ) {
          html += '<option value="'+this.badList[i]+'">'+this.badList[i]+'</option>';
        }

        this.$.selector.innerHTML = html;
        this.suggest();
      },

      suggest : function() {
        this.selected = this.$.selector.value;

        if( this.selected === '' ) {
          this.suggestions = [];
          this.$.suggestLabel.style.display = 'none';
          return;
        }

        this.$.suggestLabel.style.display = 'block';

        ecosis.ckan.topSuggest(this.selected.replace(/(-|_)/g, ' '), function(resp){
          for( var i = 0; i < resp.result.length; i++ ) {
            var item = resp.result[i];
            item.subClassOfClean = item.subClassOf ? item.subClassOf.replace(/_/g, ' ') : '';

            item.relatedTermClean = '';
            if( item.relatedTerm ) {
              if( Array.isArray(item.relatedTerm) ) {
                for( var j = 0; j < item.relatedTerm.length; j++ ) {
                  item.relatedTerm[j] = item.relatedTerm[j].trim();
                }
                item.relatedTermClean = item.relatedTerm.join(', ');
              } else {
                item.relatedTerm = item.relatedTerm.trim();
              }

            }

            item.link = 'http://top-thesaurus.org/annotationInfo?viz=1&&trait='+item.label;
          }

          this.suggestions = resp.result;
        }.bind(this));
      },

      onSelect : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        document.querySelector('ecosis-attribute-mapping').addFromSuggest(this.selected, this.suggestions[index].preferredLabel);
        this.suggestions = [];

        index = this.badList.indexOf(this.selected);
        if( index > -1 ) {
          this.badList.splice(index, 1);
        }
        this.render();
      }
    });
  </script>
</dom-module>

<dom-module id="ecosis-dataset-order">
  <style>
    :host {
      display : block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div>
      <div>
          Is this a time series dataset or a dataset that has any other form of ordering?
          If so, select the attribute to order by as well as the type of sort that should
          be performed.  You can also provide a textual description of what this ordering is.
      </div>

      <div class="form-horizontal">
        <div class="form-group">
          <label for="orderByInput" class="col-md-2 control-label"><b>Order By:</b></label>
          <div class="col-md-10">
            <select id="orderByInput" class="form-control" on-change="onChange"></select>
          </div>
        </div>

        <div class="form-group" style="display:none" id="secondaryPanel">
          <label for="orderTypeInput" class="col-md-2 control-label">Order Type</label>
          <div class="col-md-10">

            <select id="orderTypeInput" class="form-control" on-change="onChange">
                <option value="string">Default (String)</option>
                <option value="datetime">Date</option>
                <option value="numeric">Numeric</option>
            </select>

            <div class="help-block" id="dateHelp" style="display:none">
                Use <a href="http://www.w3.org/TR/NOTE-datetime" target="_blank">ISO-8601</a>
                for which the format is: YYYY-MM-DDTHH:mm:ss.sssZ.
                <a href="http://xkcd.com/1179/" target="_blank">Why?</a>
            </div>


            <input type="text" id="descriptionInput" class="form-control" on-change="onChange" placeholder="Description">

          </div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataset-order',

    ready : function() {
      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {
      this.attributeArray = [];

      var attrs = {}, sheet;
      if( ecosis.ds.datasheets ) {
        for( var i = 0; i < ecosis.ds.datasheets.length; i++ ) {
          sheet = ecosis.ds.datasheets[i];
          for( var j = 0; j < sheet.attributes.length; j++ ) {
            attrs[sheet.attributes[j]] = 1;
          }
        }
      }

      attrs = Object.keys(attrs);

      for( var i = 0; i < attrs.length; i++ ) {
          if( ecosis.ds.attributeMap[attrs[i]] ) continue;
          this.attributeArray.push(attrs[i]);
      }

      this.attributeArray.sort(function(a, b){
          if( a > b ) return 1;
          if( a < b ) return -1;
          return 0;
      });

      var options = '<option></option>';
      for( var i = 0; i < this.attributeArray.length; i++ ) {
        options += '<option value="'+this.attributeArray[i]+'">'+this.attributeArray[i]+'</option>';
      }

      this.$.orderByInput.innerHTML = options;

      var sort = ecosis.ds.package.getSort();
      if( Object.keys(sort) === 0 ) return;

      var sort_description = sort.description || '';
      var sort_type = sort.type || '';
      var sort_on = sort.on || '';

      this.$.orderByInput.value = sort_on;
      this.$.orderTypeInput.value = sort_type;
      this.$.descriptionInput.value = sort_description;

      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }
    },

    onChange : function() {
      var sort_on = this.$.orderByInput.value;
      var sort_type = this.$.orderTypeInput.value;

      var sort = {
        on : sort_on,
        type : sort_type,
        description : this.$.descriptionInput.value || ''
      }

      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }

      ecosis.ds.package.setSort(sort);
    }
  });
</script>
<dom-module id="ecosis-page-advanced">
  <style>
    :host {
      display: block;
      margin-top: 20px;
      padding: 0 5%;
    }
  </style>

  <template>

    <ul id="tabs" class="nav nav-tabs nav-justified">
      <li class="active">
        <a href="#alias" data-toggle="tab">Aliases</a>
      </li>
      <li>
        <a href="#traits" data-toggle="tab">Plant Traits</a>
      </li>
      <li>
        <a href="#template" data-toggle="tab">Template</a>
      </li>
      <li>
        <a href="#ordering" data-toggle="tab">Ordering</a>
      </li>
    </ul>

    <div id="tabContent" class="tab-content">
      <div class="tab-pane fade active in" id="alias">
        <h4 class="page-header">Dataset Attribute Alias Names</h4>
        <ecosis-attribute-mapping id="mapping"></ecosis-attribute-mapping>
      </div>

      <div class="tab-pane fade" id="traits">
        <ecosis-top-mapping></ecosis-top-mapping>
      </div>

      <div class="tab-pane fade" id="template">
        <h4 class="page-header">Dataset Template</h4>
        <div>Download a dataset template file for this dataset.  You can use this
          JSON formatted template file to help speed up the creation of new datasets like this one.
        </div>
        <div style="padding: 15px">
          <a class="btn btn-primary" id="datasetTemplate" target="_blank">Download Dataset Template</a>
        </div>
      </div>

      <div class="tab-pane fade" id="ordering">
        <h4 class="page-header">Dataset Ordering</h4>
        <ecosis-dataset-order style="margin-bottom: 50px" id="order"></ecosis-dataset-order>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-advanced',

    ready : function() {
      $(this.$.tabs).find('a').click(function (e) {
        e.preventDefault()
        $(this).tab('show')
      });
    },

    onShow : function() {
      this.$.mapping.onShow();
      this.$.order.onShow();
      this.$.datasetTemplate.setAttribute('href', ecosis.ckan.host+'/ecosis/package/getTemplate?id='+ecosis.ds.package_id);
    }
  })
</script>

<dom-module id="ecosis-page-push">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    #main {
      margin-bottom: 50px;
    }
  </style>

  <template>
    <h4 class="page-header">Publish to Search</h4>


		<div class="alert alert-danger" style="display:none" id="privateAlertPanel">
			You have marked this dataset as private. Your results cannot be published to PUBLIC search.
		</div>

		<div id="main">
			<div class="help-block">
				Please verify all information looks correct.  Once everything looks correct, click 'Publish'
        below and your changes will be represented at
        <a href="http://ecosis.org" target="_blank">ecosis.org</a>.
         Please note, a minimum of 3 EcoSIS metadata attributes are required to push your dataset.
			</div>

			<div class="well">
				<h4>Basic Information</h4>
				<table class="table">
					<tbody><tr><td>Title</td><td id="title"></td></tr>
					<tr><td>Name</td><td id="name"></td></tr>
					<tr><td>Description</td><td id="notes"></td></tr>
					<tr><td>Organization</td><td id="owner_org_name"></td></tr>
					<tr><td>Visibility</td><td>Public</td></tr>
          <tr><td>Search Status</td><td id="available"></td></tr>
				</tbody></table>
			</div>

			<div style="margin-bottom: 35px">
				<h4 class="page-header">Spectra Preview</h4>

        <ecosis-sheet-preview id="preview"></ecosis-sheet-preview>
			</div>

			<div class="well">
				<h4>EcoSIS Metadata Information</h4>
				<div id="ecosisInfo"></div>


        <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>
      </div>

      <div style="padding: 15px 0">
        <a class="btn btn-primary btn-lg" id="pushBtn" on-click="push"><i class="fa fa-check-circle-o"></i> Publish</a>
      </div>

      <div style="padding: 15px 0">
        <div class="checkbox">
          <label>
            <input type="checkbox" id="responseEmailInput" checked="checked"> Email me when the dataset is available in search.
            <div class="help-block">Datasets can take several minutes to show up in search.  We can send you and email when
              the dataset is ready.
            </div>
          </label>
        </div>
      </div>


      <div class="help-block" id="pushMessage" style="display:none">Queuing push to search...</div>
		</div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-push',

    ready : function() {
      this.requireEcosisAttrs = 3;
      this.warnEcosisAttrs = 8;

      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {

      if( ecosis.ds.package.isPrivate() ) {
        this.$.privateAlertPanel.style.display = 'block';
        this.$.main.style.display = 'none';
      } else {
        this.$.privateAlertPanel.style.display = 'none';
        this.$.main.style.display = 'block';

        this.updateLabels();
        this.updateCounts();
        this.$.preview.update({
          packageId: ecosis.ds.package_id,
          layout : 'column'
        }, true);
      }
    },

    updateLabels : function() {
      for( var key in ecosis.ds.package.data ) {
        if( key == 'owner_org' ) {
          for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
            if( ecosis.user.organizations[i].id == ecosis.ds.package.getOrganization() ) {
              this.$.owner_org_name.innerHTML = ecosis.user.organizations[i].display_name;
              break;
            }
          }

        } else if( this.$[key] ) {
          this.$[key].innerHTML = ecosis.ds.package.data[key];
        }
      }

      if( ecosis.ds.result && ecosis.ds.lastPushed ) {
        var resp = ecosis.ds.checkChanges();

        var last = '<br />Last Published: '+resp.lastPushed.toLocaleString();
        if( resp.unpublishedChanges ) {
          last += '<br />Last Updated: '+resp.lastUpdated.toLocaleString();
          last = '<span class="label label-warning">Updated since last publish</span> ' + last;
        } else {
          last = '<span class="label label-success">Published to search</span> ' + last;
        }

        this.$.available.innerHTML = last;
      } else {
        this.$.available.innerHTML = '<span class="label label-warning">Not Published</span>';
      }
    },

    updateCounts : function() {
			this.updatePushStatus();
		},

		updatePushStatus : function() {
			var count = ecosis.ds.getScore().score;

			if( count < this.requireEcosisAttrs ) {
				this.$.pushBtn.style.display = 'none';
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-danger" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.requireEcosisAttrs + ' are required to publish to search.' +
					'</span>';
				return;
			}

			this.$.pushBtn.style.display = 'inline-block';
			if( count < this.warnEcosisAttrs ) {
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-warning" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.warnEcosisAttrs + ' are recommended.' +
					'</span>';
				return;
			}

			this.$.ecosisInfo.innerHTML =
				'<span class="label label-success" style="font-size:14px">' +
					'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
				'</span>';

		},

    push : function() {
      this.$.pushBtn.setAttribute('disabled', '');
      this.$.pushBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Queuing...';
      this.$.pushMessage.style.display = 'block';

      var includeEmail = $(this.$.responseEmailInput).is(':checked');

      ecosis.ckan.pushToSearch(ecosis.ds.package_id, includeEmail,
          function(resp){
            this.$.pushBtn.removeAttribute('disabled');
            this.$.pushBtn.innerHTML = '<i class="fa fa-check-circle-o"></i> Publish';
            this.$.pushMessage.style.display = 'none';

            if( resp.error ) {
              // ERROR 12
              resp.code = 12;
              resp.message += '. Error publishing dataset.';
              return ecosis.errorPopup.show(resp);
            }

            var msg = 'Success.  Your dataset is processing.';
            if( resp.emailing && resp.email ) {
              msg += '  You will be emailed at '+resp.email+' when the dataset is ready.';
            } else {
              msg += '  Please give some time for your dataset to show in search.  No email will be sent.';
            }

            alert(msg);
            window.location = ecosis.ckan.host + '/dataset/' + ecosis.ds.package_id;
          }.bind(this)
      );
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }
  })
</script>
</div></body></html>